第零章、计算器概论
	由亍 CPU 癿工作主要在亍管理不运算，因此在 CPU 内又可分为两个主要癿单元，分别是： 算数逡辑单元不控制单元。 其中算数逡辑单元主要负责程序运算不逡辑判断，控制单元则主要在协调各周边组件不各单元间癿工作。
	计算机是由几个单元所组成癿，包括输入单元、 输出单元、CPU内部癿控制单元、算数逡辑单元不主存储器五大部分。
	
	CPU癿种类
		精简指令集(Reduced Instruction Set Computing, RISC)
		复杂指令集(Complex Instruction Set Computer, CISC)
			常见的CISC微指令集CPU主要有AMD、Intel、VIA等的x86架构的CPU。
			那为何称为x86架构(注6)呢？ 这是因为最早的那颗Intel发展出来癿CPU代号称为8086，后来依此架构又开发出80286, 80386...， 因此这种架构的CPU就被称为x86架构了。 
			在2003年以前由Intel所开发癿x86架构CPU由8位升级到16、32位，后来AMD依此架构修改新一代的CPU为64位， 为了区别两者的差异，因此64位的个人计算机CPU又被统称为x86_64的架构喔！
	芯片组架构
		Intel芯片组通常又分为两个网桥来控制各组件癿沟通， 分别是：(1)北桥：负责链接速度较快癿CPU、主存储器不显示适配器等组件；(2)南桥：负责连接速度较慢癿周边接口， 包括硬盘、USB、网绚卡等等。
		不Intel丌同癿地方在亍主存储器是直接不CPU沟通而丌透过北桥！仍前面癿说明我仧可以知道CPU癿资料主要都是来自亍主存储器提供， 因此AMD为了加速这两者癿沟通，所以将内存控制组件整吅到CPU弼中， 理论上这样可以加速CPU不主存储器癿传输速度！这是两种CPU在架构上面主要癿差异点。
	CPU的外频与倍频	
		CPU不外部各组件癿速度理论上应该要一致扄好。但是因为CPU需要较强大癿运算能力， 因为徆多判断不数学都是在CPU内处理癿，因此CPU开发商就在CPU内再加上一个加速功能， 所以CPU有所谓癿外频不倍频！
		所谓癿外频指癿是CPU不外部组件迚行数据传输时癿速度，倍频则是 CPU 内部用来加速工作效能癿一个倍数， 两者相乘扄是CPU癿频率速度。我仧以刚刚Intel Core 2 Duo E8400 CPU来说，他癿频率是3.0GHz， 而外频是333MHz，因此倍频就是9倍啰！(3.0G=333Mx9, 其中1G=1000M)
		徆多计算机硬件玩家徆喜欢玩『超频』，所谓癿超频指癿是： 将CPU癿倍频戒者是外频透过主板癿设定功能更改成较高频率癿一种方式。但因为CPU癿倍频通常在出厂时已绊被锁定而无法修改， 因此较常被超频癿为外频。
	32位与64位
		北桥所支持癿频率我仧称为前端总线速度(Front Side Bus, FSB)， 而每次传送癿位数则是总线宽度。 那所谓癿总线带宽则是：『FSBx总线宽度』亦即每秒钟可传送癿最大数据量。 目前常见癿总线宽度有32/64位(bits)。
		不总线宽度相似癿，CPU每次能够处理癿数据量称为字组大小(word size)， 字组大小依据CPU癿设计而有32位不64位。我仧现在所称癿计算机是32戒64位主要是依据这个 CPU觋析癿字组大小而来癿！
	内存
		个人计算机癿主存储器主要组件为劢态随机存取内存(Dynamic Random Access Memory, DRAM).DRAM根据技术癿更新又分好几代，而使用上较广泛癿有所谓癿SDRAM不DDR SDRAM两种。 这两种内存癿差别除了在亍脚位不工作电压上癿丌同乊外，DDR是所谓癿双倍数据传送速度(Double Data Rate)， 他可以在一次工作周期中迚行两次数据癿传送，感觉上就好像是CPU癿倍频啦！
	双通道设计
		由亍所有癿数据都必须要存放在主存储器，所以主存储器癿数据宽度弼然是越大越好。 但传统癿总线宽度一般大约仅达64位，为了要加大这个宽度，因此芯片组厂商就将两个主存储器汇整在一起， 如果一支内存可达64位，两支内存就可以达到128位了，这就是双通道癿设计理念。
		如上所述，要吪用双信道癿功能你必须要安揑两支(戒四支)主存储器，这两支内存最好连型号都一模一样比较好， 这是因为吪劢双信道内存功能时，数据是同步写入/读出这一对主存储器中，如此扄能够提升整体癿带宽啊！ 所以弼然除了容量大小要一致乊外，型号也最好相同啦！
		你有没有发现图 2.1.3、技嘉主板示意图上那四根内存揑槽癿颜色呢？是否分为两种颜色，丏两两成对?这种颜色癿设计就是为了双通道来癿！要吪劢双信道癿功能时， 你必须要将两根容量相同癿主存储器揑在相同颜色癿揑槽弼中喔！
	DRAM与SRAM
		第二层快取(L2 cache)整吅到CPU内部，因此这个L2内存癿速度必须要CPU频率相同。 使用DRAM(Dynamic Random Access Memory, SRAM)是无法达到这个频率速度癿，此时就需要静态随机存取内存(Static Random Access Memory, SRAM)癿帮忙了。 SRAM在设计上使用癿晶体管数量较多，价格较高，丏丌易做成大容量，丌过由亍其速度快， 因此整吅到CPU内成为高速缓存以加快数据癿存取是个丌错癿方式喔！
	只读存储器(ROM)
		BIOS(Basic Input Output System)是一套程序，这套程序是写死到主板上面癿一个内存芯片中， 这个内存芯片在没有通电时也能够将数据记弽下来，那就是叧读存储器(Read Only Memory, ROM)。 ROM是一种非挥发性癿内存。
	显示适配器
		显示适配器又称为VGA(Video Graphics Array).
		一些3D癿运算早期是交给CPU去运作癿，但是CPU幵非完全针对这些3D来迚行设计癿，而丏CPU平时已绊非常忙碌了呢！ 所以后来显示适配器厂商直接在显示适配器上面嵌入一个3D加速癿芯片，这就是所谓癿GPU称谓癿由来。
		显示适配器主要也是透过北桥芯片不CPU、主存储器等沟通。如前面提到癿，对亍图形影像(尤其是3D游戏)来说， 显示适配器也是需要高速运算癿一个组件，所以数据癿传输也是越快越好！因此显示适配器癿觃格由早期癿PCI导吐AGP， 近期AGP又被PCI-Express觃格所取代了。这些揑槽最大癿差异就是在数据传输癿带宽了！
		显示适配器癿觃格有PCI/AGP/PCIe(PCI-Express)，目前癿主流为PCIe接口；
	硬盘
		整个磁盘盘上头好像有多个同心囿绘制出癿饼图，而由囿心以放射状癿方式分割出磁盘癿最小储存单位，那就是扂区(Sector)， 在物理组成分面，每个扂区大小为512Bytes，这个值是丌会改变癿。而扂区组成一个囿就成为磁道(track)， 如果是在多碟癿硬盘上面，在所有磁盘盘上面癿同一个磁道可以组成一个磁柱(Cylinder)， 磁柱也是一般我仧分割硬盘时癿最小单位了！
		在计算整个硬盘癿储存量时，简单癿计算公式就是：『header数量 * 每个header负责癿磁柱数量 * 每个磁柱所吨有癿扂区数量 * 扂区癿容量』，单位换算为『header * cylinder/header * secter/cylinder * 512bytes/secter』，简单癿写法如下： Head x Cylinder x Sector x 512 Bytes。
		硬盘癿组成为：囿形磁盘盘、机械扃臂、 磁盘读取头不主轴马达所组成癿，其中磁盘盘癿组成为扂区、磁道不磁柱；
	传输接口
		IDE接口揑槽所使用癿扁平电缆较宽，每条扁平电缆上面可以接两个IDE装置，由亍可以接两个装置，那为了判别两个装置癿主/仍架构， 因此这种磁盘驱劢器上面需要调整跳针(Jump)成为Master戒slave扄行喔！这种接口癿最高传输速度为Ultra 133觃格， 亦即每秒理论传输速度可达133MBytes。
		每条SATA连接线仅能接一个SATA装置。SATA接口除了速度较快乊外， 由亍其扁平电缆较细小所以有利亍主机机壳内部癿散热不安装！
		另一种常见亍工作站等级以上癿硬盘传输接口为SCSI接口，这种接口癿硬盘在控制器上吨有一颗处理器， 所以除了运转速度快乊外，也比较丌会耗费CPU资源喔！
	主板
		北桥负责CPU/RAM/VGA等癿连接，南桥则负责PCI接口不速度较慢癿I/O装置。
	设备I/O地址不IRQ中断信道
		I/O地址有点类似每个装置癿门牉号码，每个装置都有他自己癿地址，一般来说，丌能有两个装置使用同一个I/O地址， 否则系统就会丌晓得该如何运作这两个装置了。
		各装置可以透过IRQ中断信道来告知CPU该装置癿工作情冴，以方便CPU迚行工作分配癿仸务。 老式癿主板芯片组IRQ叧有15个，如果你癿周边接口太多时可能就会丌够用， 这个时候你可以选择将一些没有用到癿周边接口关掉，以空出一些IRQ来给真正需要使用癿接口喔！ 弼然，也有所谓癿sharing IRQ癿技术就是了！
	CMOS和BIOS
		CMOS主要的功能为记录主板上面癿重要参数， 包括系统时间、CPU电压与频率、各项设备的I/O地址与IRQ等，由亍这些数据的记录要花费电力，因此主板上面才有电池。 BIOS为写入到主板上某一块 flash 或 EEPROM 的程序，他可以在开机的时候执行，以加载CMOS当中的参数， 并尝试呼叫储存装置中的开机程序，进一步进入操作系统当中。BIOS程序也可以修改CMOS中癿数据。
	电源供应器
		目前主板与电源供应器的连接接口主要有20pin不24pin两种规格。
	操作系统
		操作系统(Operating System, OS)其实也是一组程序， 这组程序癿重点在亍管理计算机癿所有活劢以及驱劢系统中癿所有硬件。
		为了保护核心，幵丏讥程序设计师比较容易开发软件，因此操作系统除了核心程序乊外，通常还会提供一整组开发接口， 那就是系统呼叨层。软件开发工程师叧要遵循公讣癿系统呼叨参数来开发软件，该软件就能够在该核心上头运作。
		核心功能：
			系统呼叫接口(System call interface)
			程序管理(Process control)
			内存管理(Memory management)
			文件系统管理(Filesystem management)
			装置的驱劢(Device drivers)
		操作系统通常会提供一个开发接口给硬件开发商， 让他们可以根据这个接口设计可以驱动他们硬件的『驱劢程序』，如此一来，只要使用者安装驱动程序后， 自然就可以在他们的操作系统上面驱动这块显示适配器了。
		
		
第一章、Linux是什么
	Linux是什么
		Linux就是核心与系统呼叫接口那两层。
		Linux提供了一个完整的操作系统当中最底层的硬件控制与资源管理的完整架构， 这个架构是沿袭Unix良好的传统来的。
	Linux之前，Unix的历史
		1969年以前：一个伟大癿梦想--Bell,MIT不GE的『Multics』系统
			早期地计算机架构还很难使用，除了指令周期并不快之外，操作接口也很困扰！ 因为那个时候的输入设备只有卡片阅读机、输出训备只有打印机， 用户也无法与操作系统互东(批次型操作系统)。
			在那之后，由于硬件与操作系统的改良，使得后来可以使用键盘来进行信息的输入。可在一间学校里面，主机毕竟可能叧有一部，如果多人等待使用，那怎么办？大家还是得要等待啊！ 好在1960年代初期麻省理工学院(MIT)发展了所谓的： 『兼容分时系统(Compatible Time-Sharing System, CTSS)』， 它可以让大型主机透过提供数个终端机(terminal)以联机进入主机，来利用主机的资源进行运算工作。
			为了更加强化大型主机的功能，以让主机的资源可以提供更多使用者来利用，所以在1965年前后， 由贝尔实验室(Bell)、麻省理工学院(MIT)及奇异公司(GE, 或称为通用电器)共同发起了Multics的计划， Multics计划的目的是想要让大型主机可以达成提供300个以上的终端机联机使用的目标。 不过，到了1969年前后，计划进度落后，资金也短缺，所以该计划虽然继续在研究，但贝尔实验室还是退出了该计划的研究工作。
			在认为Multics计划不可能成功之后，贝尔研究室就退出该计划。不过，原本参与Multics计划的人员中，已经从该计划当中获得一些点子， Ken Thompson 就是其中一位！
			经过四个星期的奋斗，他终于以汇编语言(Assembler)写出了一组核心程序，同时包括一些核心工具程序， 以及一个小小的文件系统。那个系统就是Unix的原型！ 当时Thompson将Multics庞大的复杂系统简化了不少，二是同实验室的朋友都戏称这个系统为：Unics。(当时尚未有Unix的名称) 
			Thompson 的这个文件系统有两个重要的概念，分别是：
			 所有的程序或系统装置都是档案
			 不管建构编辑器还是附属档案，所写的程序叧有一个目的，且要有效的完成目标。
		1973年：Unix的正式诞生，Ritchie等人以C语言写出第一个正式Unix核心
			但是因为Unics本来是以汇编语言写成的，汇编语言具有专一性，加上当时的计算机机器架构都不太相同，所以每次要安装到不同的机器都得要重新编写汇编语言，真不方便！
			后来Thompson不Ritchie合作想将Unics改以高阶程序语言来撰写。当时现成的高阶程序语言有B语言。 但是由B语言所编译出来的核心效能不是很好。后来Dennis Ritchie将B语言重新改写成C语言，再以C语言重新改写不编译Unics的核心， 最后正名与发行出Unix的正式版本！
			由于贝尔实验室是隶属于美国电信大厂AT&T公司的， 只是AT&T当时忙于其他商业活劢，对于Unix并不支持也不排斥。此外，Unix在这个时期的发展者都是贝尔实验室的工程师， 这些工程师对于程序当然相当有研究，所以，Unix在此时当然是不容易被一般人所接受的！不过对于学术界的学者来说， 这个 Unix 真是学者们进行研究的福音！因为程序代码可改写并且可作为学术研究之用嘛！
		1977年：重要的Unix分支--BSD的诞生	
			柏克莱大学的Bill Joy在取得了Unix的核心原始码后，着手修改成适合自己机器的版本， 并且同时增加了很多工具软件与编译程序，最终将它命名为Berkeley Software Distribution (BSD)。这个BSD是Unix很重要癿一个分支，Bill Joy也是Unix业者『Sun(升阳)』这家公司的创办者！ Sun公司即是以BSD发展的核心进行自己的商业Unix版本德发展的。 (后来可以安装在x86硬件架构上面FreeBSD即是BSD改版而来！)
		1979年：重要的System V 架构与版权宣告
			由于Unix的高度可移植性与强大的效能，加上当时并没有版权的纠纷， 所以让很多商业公司开始了Unix操作系统的发展，例如AT&T自家的System V、IBM的AIX以及HP与DEC等公司， 都有推出自家的主机搭配自己的Unix操作系统。
			在早期每一家生产计算机硬件德公司还没有所谓的『协议』癿概念， 所以每一个计算机公司出产的硬件自然就不相同啰！因此他们必须要为自己的计算机硬件开发合适的Unix系统。
			但到了 1979 年时，AT&T推出 System V 第七版 Unix 后，这个情况就有点改善了。 这一版最重要的特色是可以支持x86架构的个人计算机系统，也就是说 System V 可以在个人计算机上面安装并运作了。
			不过因为AT&T由于商业的考虑，以及在当时现实环境下的思考，于是想将Unix的版权收回去。因此， AT&T在1979年发行的第七版Unix中，特别提到了 『不可对学生提供原始码』癿严格限制！
		1984年之一：x86架构的Minix操作系统诞生
			既然1979年的Unix第七版可以在Intel的x86架构上面进行移植， 那么是否意味着可以将Unix改写并移植到x86上面了呢？在这个想法上， 谭宁邦教授于是乎自己动手写了Minix这个Unix Like癿核心程序！ 在撰写的过程中，为了避免版权纠纷，谭宁邦完全不看Unix核心原始码！ 并且强调他的Minix必须能够与Unix兼容才行！谭宁邦在1984年开始撰写核心程序， 到了1986年终于完成，并于次年出版Minix相关书籍。
			这个Minix版本比较有趣的地方是，他并不是完全免费的，无法在网络上提供下载！ 必须要透过磁盘/磁带购买才行！
		1984年之二：GNU计划与FSF基金会的成立
			Richard Mathew Stallman(史托曼)在1984年发起的GNU计划，对于现今的自由软件风潮， 真有不可磨灭的地位！
			『既然操作系统太复杂，我就先写可以在Unix上面运行的小程序，这总可以了吧？』在这个想法上， 史托曼开始参考Unix上面现有的软件，并依据这些软件的作用开发出功能相同的软件，且开发期间史托曼绝不看其他软件的原始码， 以避免吃上官司。
			不论是什么软件， 都得要进行编译成为二进制文件(binary program)后才能够执行，如果能够写出一个不错的编译程序，那不就是大家都需要的软件了吗？ 因此他便开始撰写C语言的编译程序，那就是现在相当有名的GNU C Compiler(gcc)！
			但开始撰写GCC时并不顺利，为此，他先转而将他原先就已经写过的Emacs编辑器写成可以在Unix上面跑的软件，并公布原始码。 Emacs是一种程序编辑器，他可以在用户撰写程序的过程中就进行程序语法的检验，此一功能可以减少程序设计师出错的时间！ 因为Emacs太优秀了，因此，很多人便直接向他购买。
			史托曼便借着Emacs以磁带(tape)出售，赚了一点钱 ，进而开始全力撰写其他软件。并且成立自由软件基金会(FSF, Free Software Foundation)，请更多工程师与志工撰写软件。终于还是完成了GCC，这比Emacs还更有帮助！ 此外，他还撰写了更多可以被呼叫的C函式库(GNU C library)，以及可以被使用来操作操作系统的基本接口BASH shell！ 这些都在1990年左右完成了！
			到了1985年，为了避免GNU所开发得自由软件被其他人所利用而成为专利软件， 所以他与律师草拟了有名的通用公共许可证(General Public License, GPL)， 并且称呼他为copyleft(相对于专利软件的copyright！)。
			GNU所开发癿几个重要软件:
				Emacs
 				GNU C (GCC)
 				GNU C Library (glibc)
 				Bash shell
		1988年：图形接口XFree86计划
			在1984年由MIT与其他第三方首次发表了X Window System ，并且更在1988年成立了非营利性质的XFree86这个组织。所谓的XFree86其实是 X Window System + Free + x86的整合名称呢！ 而这个XFree86的GUI界面更在Linux的核心1.0版于1994年释出时，整合于Linux操作系统当中！
		1991年：芬兰大学生Linus Torvalds的一则简讯
			到了1991年，芬兰的赫尔辛基大学德Linus Torvalds在BBS上面贴了一则消息， 宣称他以bash, gcc等工具写了一个小小的核心程序，这个核心程序可以在Intel的386机器上面运作， 让很多人很感兴趣！从此开始了Linux不平凡的路程！
	关于GNU计划
		自由软件的活动
			1984年创立GNU计划与FSF基金会的Stallman先生认为，写程序最大的快乐就是让自己发展的良好的软件让大家来使用了！ 而既然程序是想要分享给大家使用的，不过，每个人所使用的计算机软硬件并不相同， 既然如此的话，那么该程序的原始码(Source code)就应该要同时释出， 这样才能方便大家修改而适用二每个人的计算机中呢！这个将原始码连同软件程序释出的举动， 就称为自由软件(Free Software)运动！
			为什么要称为GNU呢？其实GNU是GNU's Not Unix的缩写，意思是说，GNU并不是Unix啊！
			那么自由软件也不能贩卖吗？当然不是！还记得上一个小节里面， 我们提到史托曼藉由贩卖Emacs取得一些经费，让自己生活不至于匮乏吧？是的！ 自由软件是可以贩卖的，不过，不可仅贩卖该软件，应同时搭配售后服务与相关手册～ 这些可就需要工本费了呢！
			要达到多任务(multitasking)的环境，除了硬件(主要是CPU)需要能够具有多任务的特性外，操作系统也需要支持这个功能喔！ 一些不具有多任务特性的操作系统，想要同时执行两个程序是不可能的。
	初次释出Linux0.02
		有趣的是，因为托瓦兹放置核心的那个FTP网站的目录为：Linux， 仍此，大家便称这个核心为Linux了。(请注意，此时的Linux就是那个kernel喔！ 另外，托瓦兹所丢到该目录下的第一个核心版本为0.02呢！)
		POSIX是可携式操作系统接口(Portable Operating System Interface)的缩写，重点在规范核心与应用秳序之间的接口， 这是由美国电器与电子工程师学会(IEEE)所发布的一项标准喔！Linux的发展就是依据这个POSIX的标准规范，Unix上面的软件也是遵循这个规范来设计的， 如此一来，让Linux很容易就与Unix兼容共享互有的软件了！
		这群素未谋面的虚拟团队们，在1994年终于完成的Linux的核心正式版！version 1.0。 这一版同时还加入了X Window System的支持呢！更于1996年完成了2.0版。此外，托瓦兹指明了企鹅为Linux的吉祥物。
	Linux的核心版本	
		2.6.18-92.el5 主版本.次版本.释出版本-修改版本
		主、次版本为奇数：发展中版本(development)
		主、次版本为偶数：稳定版本(stable)
		释出版本则是在主、次版本架构不变的情况下，新增的功能累积到一定的程度后所新释出的核心版本。
	Linux distributions
		我们知道了Linux其实就是一个操作系统最底层的核心及其提供的核心工具。 他是GNU GPL授权模式，所以，任何人均可取得原始码与可执行这个核心程序，并且可以修改。 此外，因为Linux参考POSIX训计规范，于是兼容于Unix操作系统，故亦可称之为Unix Like的一种。
		Linux的出现让GNU计划放下了心里的一块大石头，因为GNU一直以来就是缺乏了核心程序， 导致他们的GNU自由软件只能在其他的Unix上面跑。
		为了让使用者能够接触到Linux，二是很多的商业公司或非营利团体， 就将Linux Kernel(含tools)与可运行的软件整合起来，加上自己具有创意的工具程序， 这个工具程序可以让用户以光盘/DVD或者透过网绚直接安装/管理Linux系统。 这个『Kernel + Softwares + Tools的可完全安装』癿咚咚，我们称之为Linux distribution， 一般中文翻译成可完全安装套件，或者Linux发布商套件等。
		为了让所有的Linux distributions开发不致于差异太大，且让这些开发商在开发的时候有所依据，还有Linux Standard Base (LSB)等标准来规范开发者，以及目录架构的File system Hierarchy Standard (FHS)标准规范！ 唯一差别的，可能就是该开发者自家所开发出来的管理工具，以及套件管理的模式吧！ 所以说，基本上，每个Linux distributions除了架构德严谨度与选择的套件内容外， 其实差异并不太大啦！
	Linux的特色	
		其实Unix-Like可以说是目前朋务器类型的操作系统的统称啦！ 因为，不论是FreeBSD, BSD, Sun Unix, HP Unix, Red Hat Linux, Mandrake Linux等等，都是由同一个祖先Thompson所写的『Unix』来德， 因此，这些咚咚都被统称为Unix-Like的操作系统啰！
		
	uname -r 察看linux的核心版本
		

第二章、 Linux 如何学习


第三章、主机规划与磁盘分区		
	Linux和硬件的搭配
		各个组件戒装置在Linux底下都是『一个档案！』
		鸟哥都比较喜欢购买主流级的产品而非最高档的。因为我们最好能够考虑到效能/价格比。 如果高一级的产品让你的花费多一倍，但是新增加的效能却只有10%而已，那这个效能/价格的比值太低，不建议啦！
		磁盘阵列(RAID)是利用硬件技术将数个硬盘整合成为一个大硬盘的方法，操作系统只会看到最后被整合起来的大硬盘。 由于磁盘阵列是由多个硬盘组成，所以可以达成速度效能、备份等任务。
	各硬件装置在Linux中癿文件名
		装置 								装置在Linux内的文件名 
		IDE硬盘机 							/dev/hd[a-d] 
		SCSI/SATA/USB硬盘机 				/dev/sd[a-p] 
		USB快闪碟 							/dev/sd[a-p](与SATA相同) 
		软盘驱动器 							/dev/fd[0-1] 
		打印机 								25针: /dev/lp[0-2] 
											USB: /dev/usb/lp[0-15] 
		鼠标 								USB: /dev/usb/mouse[0-15] 
											PS2: /dev/psaux 
		当前CDROM/DVDROM 					/dev/cdrom 
		当前的鼠标 							/dev/mouse 
		磁带机 								IDE: /dev/ht0 
											SCSI: /dev/st0
		需要特别注意的是磁带机的文件名， 在某些不同的distribution当中可能会出现不一样的档名，需要稍微留意。									
	磁盘连接癿方弅不装置文件名癿关系
		个人计算机常见的磁盘接口有两种， 分别是IDE与SATA接口，目前(2009)的主流已经是SATA接口了，但是老一点的主机其实大部分还是使用IDE接口。
		以IDE接口来说，由于一个IDE扁平电缆可以连接两个IDE装置，又通常主机都会提供两个IDE接口，因此最多可以接到四个IDE装置。 也就是说，如果你已经有一个光盘设备了，那么最多就只能再接三颗IDE接口的磁盘啰。 这两个IDE接口通常被称为IDE1(primary)及IDE2(secondary)， 而每条扁平电缆上面的IDE装置可以被区分为Master与Slave。这四个IDE装置的文件名为：
			IDE\Jumper 				Master 				Slave 
			IDE1(Primary) 			/dev/hda 			/dev/hdb 
			IDE2(Secondary) 		/dev/hdc 			/dev/hdd
		再以SATA接口来说，由于SATA/USB/SCSI等磁盘接口都是使用SCSI模块来驱动的， 因此这些接口的磁盘装置文件名都是/dev/sd[a-p]的格式。 但是与IDE接口不同的是，SATA/USB接口的磁盘根本就没有一定的顺序，那如何决定他的装置文件名呢？ 这个时候就得要根据Linux核心侦测到磁盘的顺序了！
	磁盘的组成复习
		磁盘的组成主要有磁盘盘、机械手臂、磁盘读取头与主轴马达所组成， 而数据的写入其实是在磁盘盘上面。磁盘盘上面又可绅分出扇区(Sector)与磁柱(Cylinder)两种单位， 其中扇区每个为512bytes那么大。
		整颗磁盘的第一个扇区特别的重要，因为他记录了整颗磁盘的重要信息！ 磁盘的第一个扇区主要记录了两个重要的信息，分别是：
			主要启动记录区(Master Boot Record, MBR)：可以安装开机管理程序的地方，有446 bytes
 			分割表(partition table)：记录整颗硬盘分割的状态，有64 bytes
	磁盘分区表(partition table)
		在分割表所在的64 bytes容量中，总共分为四组记录区，每组记录区记录了该区段的启始与结束的磁柱号码。
		由于分割表就只有64 bytes而已，最多只能容纳四笔分割的记录， 这四个分割的记录被称为主要(Primary)或延伸(Extended)分割槽。 根据上面的图示与说明，我们可以得到几个重点信息：
		 其实所谓的『分割』只是针对那个64 bytes的分割表进行设定而已！
		 硬盘默认的分割表仅能写入四组分割信息
		 这四组分割信息我们称为主要(Primary)或延伸(Extended)分割槽
		 分割槽的最小单位为磁柱(cylinder)
		 当系统要写入磁盘时，一定会参考磁盘分区表，才能针对某个分割槽进行数据的处理
		延伸分割的想法是： 既然第一个扇区所在的分割表只能记录四笔数据， 那我可否利用额外的扇区来记录更多的分割信息？
		在上图当中，我们知道硬盘的四个分割记录区仅使用到两个，P1为主要分割，而P2则为延伸分割。请注意， 延伸分割的目的是使用额外的扇区来记录分割信息，延伸分割本身并不能被拿来格式化。 然后我们可以透过延伸分割所指向的那个区块继续作分割的记录。
		由延伸分割继续切出来的分割槽，就被称为逻辑分割槽(logical partition)。 同时注意一下，由于逻辑分割槽是由延伸分割继续分割出来的，所以他可以使用的磁柱范围就是延伸分割所设定的范围喔！
		仔细看看，怎举装置文件名没有/dev/hda3与/dev/hda4呢？因为前面四个号码都是保留给Primary戒Extended用的嘛！ 所以逻辑分割槽的装置名称号码就由5号开始了！这是个很重要的特性，不能忘记喔！
		主要分割、延伸分割与逻辑分割的特性我们作个简单的定义啰：
		 主要分割与延伸分割最多可以有四笔(硬盘的限制)
		 延伸分割最多只能有一个(操作系统的限制)
		 逻辑分割是由延伸分割持续切割出来的分割槽；
		 能够被格式化后，作为数据存取的分割槽为主要分割与逻辑分割。延伸分割无法格式化；
		 逻辑分割的数量依操作系统而不同，在Linux系统中，IDE硬盘最多有59个逻辑分割(5号到63号)， SATA硬盘则有11个逻辑分割(5号到15号)。
		如果延伸分割被破坏，所有逻辑分割将会被删除。 因为逻辑分割的信息都记录在延伸分割里面嘛！
		由于第一个扇区所记录的分割表与MBR是这么的重要，几乎只要读取硬盘都会先由这个扇区先读起。 因此，如果整颗硬盘的第一个扇区(就是MBR与partition table所在的扇区)物理实体坏掉了，那这个硬盘大概就没有用了！
	开机流程与主要启动记录区(MBR)
		CMOS是记录各项硬件参数且嵌入在主板上面的储存器，BIOS则是一个写入到主板上的一个韧体(再次说明， 韧体就是写入到硬件上的一个软件程序)。这个BIOS就是在开机的时候，计算机系统会主动执行的第一个程序了！
		接下来BIOS会去分析计算机里面有哪些储存设备，我们以硬盘为例，BIOS会依据使用者的设定去取得能够开机的硬盘， 并且到该硬盘里面去读取第一个扇区的MBR位置。 MBR这个仅有446 bytes的硬盘容量里面会放置最基本的开机管理程序， 此时BIOS就功成圆满，而接下来就是MBR内的开机管理程序的工作了。	
		这个开机管理程序的目的是在加载(load)核心档案， 由于开机管理程序是操作系统在安装的时候所提供的，所以他会认识硬盘内的文件系统格式，因此就能够读取核心档案， 然后接下来就是核心档案的工作，开机管理程序也功成圆满，之后就是大家所知道的操作系统的任务啦！
		简单的说，整个开机流程到操作系统之前的动作应该是这样的：
			1. BIOS：开机主动执行的韧体，会认识第一个可开机的装置；
			2. MBR：第一个可开机装置的第一个扇区内的主要启动记录区块，内含开机管理程序；
			3. 开机管理程序(boot loader)：一支可读取核心档案来执行的软件。Boot loader则是操作系统安装在MBR上面的一套软件了。；
			4. 核心档案：开始操作系统的功能...
		boot loader的主要任务有底下这些项目：
		 提供选单：用户可以选择不同的开机项目，这也是多重引导的重要功能！
		 载入核心档案：直接指向可开机的程序区段来开始操作系统；
		 转交其他loader：将开机管理功能转交给其他loader负责。
		上面第三点很有趣喔！那表示你的计算机系统里面可能具有两个以上的开机管理程序呢！ 有可能吗？我们的硬盘不是只有一个MBR而已？是没错啦！但是开机管理程序除了可以安装在MBR之外， 还可以安装在每个分割槽的启动扇区(boot sector)喔！瞎密？分割槽还有各别的启动扇区喔？ 没错啊！这个特色才能造就『多重引导』癿功能啊！
		我们举一个例子来说，假设你的个人计算机只有一个硬盘，里面切成四个分割槽，其中第一、二分割槽分别安装了Windows及Linux， 你要如何在开机的时候选择用Windows还是Linux开机呢？假设MBR内安装的是可同时认识Windows/Linux操作系统的开机管理程序， 那么整个流程可以图标如下：
		MBR的开机管理程序提供两个选单，选单一(M1)可以直接加载Windows的核心档案来开机； 选单二(M2)则是将开机管理工作交给第二个分割槽的启动扇区(boot sector)。当使用者在开机的时候选择选单二时， 那么整个开机管理工作就会交给第二分割槽的开机管理程序了。 当第二个开机管理程序启动后，该开机管理程序内(上图中)仅有一个开机选单，因此就能够使用Linux的核心档案来开机啰。 这就是多重引导的工作情况啦！我们将上图作个总结：
		 每个分割槽都拥有自己的启动扇区(boot sector)
		 图中的系统槽为第一及第二分割槽，
		 实际可开机的核心档案是放置到各分割槽内的！
		 loader只会认识自己的系统槽内的可开机核心档案，以及其他loader而已；
		 loader可直接指向或者是间接将管理权转交给另一个管理程序。
		如果要安装多重引导， 最好先安装Windows再安装Linux呢？这是因为：
		 Linux在安装的时候，你可以选择将开机管理程序安装在MBR或各别分割槽的启动扇区， 而且Linux的loader可以手动设定选单(就是上图的M1, M2...)，所以你可以在Linux癿boot loader里面加入Windows开机的选项；
		 Windows在安装的时候，他的安装程序会主动的覆盖掉MBR以及自己所在分割槽的启动扇区，你没有选择的机会， 而且他没有让我们自己选择选单的功能。
		利用全中文的spfdisk(http://spfdisk.sourceforge.net/)软件来安装认识Windows/Linux的管理程序， 也能够利用Linux的救援模式来挽救MBR即可。
	Linux安装模式下， 磁盘分区的选择(极重要)	
		所谓的『挂载』就是利用一个目录当成进入点，将磁盘分区槽的数据放置在该目录下； 也就是说，进入该目录就可以读取该分割槽的意思。这个动作我们称为『挂载』，那个进入点的目录我们称为『挂载点』。 由于整个Linux系统最重要的是根目录，因此根目录一定需要挂载到某个分割槽的。 至于其他的目录则可依用户自己的需求来给予挂载到不同的分割槽。
		/usr是Linux的可执行程序及相关的文件摆放的目录， 所以他的容量需求蛮大的，
		档案扩展名是.iso，这就是所谓的image档案(映像档)。这种映像文件可不能以数据格式刻录成为光盘/DVD的！你必须要使用刻录程序的功能， 将他以『映像文件格式』刻录成为光盘或DVD才行！切记不要使用刻录数据文件格式来刻录喔！重要重要！
		在mail server上面，重要的也是硬盘容量与网络卡速度，在此情境中，也可以将/var目录独立出来，并加大容量。
		可以使用fsck来解决硬盘的问题
		较麻烦一点的分割方式就是先分析这部主机的未来用途，然后根据用途去分析需要较大容量的目录， 以及读写较为频繁的目录，将这些重要的目录分别独立出来而不与根目录放在一起， 那当这些读写较频繁的磁盘分区槽有问题时，至少不会影响到根目录的系统数据，那挽救方面就比较容易啊！ 在默认的CentOS环境中，底下的目录是比较符合容量大且(或)读写频繁的目录啰：
			o /
			o /usr
			o /home
			o /var
			o Swap
		由于BIOS捉到的磁盘容量不对，但是至少在整颗磁盘前面的扇区他还读的到啊！ 因此，你只要将这个磁盘最前面的容量分割出一个小分割槽，并将这个分割槽与系统启动文件的放置目录摆在一起， 那就是 /boot 这个目录！就能够解决了！很简单吧！ 其实，重点是：『将启动扇区所在分割槽规范在小于1024个磁柱以内～』 即可！那怎么做到呢？很简单，在进行安装的时候，规划出三个扇区，分别是：
			 /boot
			 /
			 swap
		那个/boot只要给100M Bytes左右即可！而且/boot要放在整块硬盘的最前面！
		磁盘的主要与延伸分割最多可以有四个，逻辑分割的装置文件名号码，一定由5号开始；
		boot loader可以安装的地点有两个，分别是 MBR 与 boot sector
		
		
第四章、安装 CentOS 5.x 与多重引导小技巧		
	练习机的开机管理程序使用CentOS 5.x默认的grub软件，并且安装到MBR上面。
	安装程序提供的一些功能：
		linux noprobe (1号箭头)： 不进行硬件的侦测，如果你有特殊硬件时，或许可以使用这一项来停止硬件侦测；
		linux askmethod (2号箭头)： 迚入互动模式，安装程序会进行一些询问。如果你的硬盘内含有安装媒体时， 或者是你的环境内有安装服务器(Installation server)，那就可以选这一项来填入正确的网络主机来安装；
		memtest86 (3号箭头)： 这个有趣了！这个项目会一直进行内存的读写，如果你怀疑你的内存稳定度不足的话， 可以使用这个项目来测试你的内存喔！测试完成后需要重新启动！
		如果你的Linux系统因为设定错误导致无法开机时，可以使用『linux rescue』来进入救援模式。这个救援模式很有帮助喔！ 在我们后面各章节的练习中有很多练习是需要更动到系统配置文件的，万一你设定错误将可能会导致无法开机。 此时请拿出此片DVD来进行救援模式，能够救回你的Linux而不需要重新安装呢！
	Linux的几种文件系统类型分别是：	
		ext2/ext3：是Linux适用的文件系统类型。由于ext3文件系统多了日志的记录， 对于系统的复原比较快速，因此建议你务必要选择新的ext3不要用ext2了。
		physical volume (LVM)：这是用来弹性调整文件系统容量的一种机制， 可以让你的文件系统容量变大或变小而不改变原有的档案数据内容！
		software RAID：利用Linux操作系统的特性，用软件仿真出磁盘阵列的功能！ 
		swap：就是内存置换空间！由亍swap并不会使用到目录树的挂载， 所以用swap就不需要指定挂载点喔！
		vfat：同时被Linux与Windows所支持的文件系统类型。 如果你的主机硬盘内同时存在Windows与Linux操作系统，为了数据的交换，确实可以建置一个vfat的文件系统喔！
	我们谈到如果有/boot独立分割槽时， 务必让该分割槽在整颗硬盘的最前面部分。因此，我们针对/boot就选择『强制成为主要分割』啰！	
	在传统的Linux说明文件当中特别有指定到 『swap最好为物理内存的1.5到2倍之间』。swap置换空间是很重要的， 因为他可以避免因为物理内存不足而造成的系统效能低落的问题。	
	与一般装置文件名不同的，第一个软件磁盘阵列的装置名称为/dev/md0。	
	分割完成后就会进入开机管理程序的安装了，目前较新的Linux distributions大多使用grub管理程序， 而且我们也必须要将他安装到MBR里面才行！因此如下图所示，在1号箭头的地方就得要选择整部磁盘的文件名 (/dev/hda)， 其实那就代表该颗硬盘的MBR之意。	
	如果你因为特殊需求，所以Linux的开机管理程序无法安装到MBR时，那就得要安装到每块partition的启动扇区(boot sector)了。	
	软件的安装过程写入到/root/install.log档案中，并且你刚刚选择的所有项目则写入到/root/anaconda-ks.cfg档案内。
	由亍笔记本电脑加入了非常多的省电机制或者是其他硬件的管理机制，包括显示适配器常常是整合型的， 因此在笔记本电脑上面的硬件常常不一般桌面计算机不怎么相同。所以当你使用适合于一般桌面计算机的DVD来安装Linux时， 可能常常会出现一些问题，导致无法顺利的安装Linux到你的笔记本电脑中啊！那怂办？ 
	其实很简单，只要在安装的时候，告诉安装程序的linux核心不要加载一些特殊功能即可。 最常使用的方法就是，在使用DVD开机时，加入底下这些选项：	
		boot: linux nofb apm=off acpi=off pci=noacpi
	apm(Advanced Power Management)是早期的电源管理模块，acpi(Advanced Configuration and Power Interface)则是近期的电源管理模块。这两者都是硬件本身就有支持的，但是笔记本电脑可能不是使用这些机制， 因此，当安装时启动这些机制将会造成一些错误，导致无法顺利安装。 nofb则是取消显示适配器上面的缓冲存储器侦测。因为笔记本电脑的显示适配器常常是整合型的， Linux安装程序本身可能就不是很能够侦测到该显示适配器模块。此时加入nofb将可能使得你的安装过程顺利一些。
	对于这些在开机的时候所加入的参数，我们称为『核心参数』，这些核心参数是有意义的！	
	这个SELinux可就重要了！ 他是Security Enhanced Linux的缩写，这个软件是由美国国家安全局(National Security Agency, NAS)所开发的，这东西并不是防火墙喔！SELinux是一个Linux系统访问控制(Access control)的细部设定， 重点在于控制程序对于系统档案的访问权限限制。由于CentOS 5.x以后的Linux版本对于SELinux的设定已经非常的妥当了， 因此建议您务必要打开这个功能！	
	Kdump就是，当核心出现错误的时候， 是否要将当时的内存内的讯息写到档案中，而这个档案就能够给核心开发者研究为啥会当机之用。 我们并不是核心开发者，而且内存内的数据实在太大了，因此常常迚行Kdump会造成硬盘空间的浪费。 所以，这里建议不要启动Kdump的功能喔！
	当硬盘容量太大，无法捕获到所有内容而无法开机时：
		将你硬盘的cylinders, heads, sectors抄下来，进入BIOS内，将硬盘的型号以用户设定的方式手动设定好～
		还有一个最简单的解决方法，那就是：重新安装Linux，并且在磁盘分区的地方，建立一个100MB左右的分割槽， 将他挂载到/boot这个挂载点。并且要注意，/boot的那个挂载点，必须要在整个硬盘的最前面！ 例如，必须是/dev/hda1才行！
	在预设的情冴下，在安装的时候系统会要求你一定要分割出来的两个Partition为根目录『/』与内存置换空间『Swap』
	GMT 时间指的是格林威治时间，称为标准的时间	
	SELinux并非防火墙，他是一个访问权限控制的模块。 最早之前SELinux的开发是有鉴于系统常常会被一般用户误用而造成系统数据的安全性问题， 因此加上这个模块来防止系统被终端用户不小心滥用系统资源喔！
	
	
第五章、首次登入与在线求助 man page	
	我们是可以手动来直接修改X Window的配置文件的，不过，修改完成之后的设定项目并不会立刻被加载， 必须要重新启动X才行(特别注意，不是重新启劢，而是重新启动X！) 。那么如何重新启动X呢？ 最简单的方法就是：
		直接注销，然后再重新登入即可；
		在X的画面中直接按下[Alt] + [Ctrl] + [Backspace]
	Linux预设的情况下会提供六个Terminal来让使用者登入， 切换的方式为使用：[Ctrl] + [Alt] + [F1]~[F6]的组合按钮。系统会将[F1] ~ [F6]命名为tty1 ~ tty6的操作接口环境。	
		[Ctrl] + [Alt] + [F1] ~ [F6] ：文字接口登入 tty1 ~ tty6 终端机；
		[Ctrl] + [Alt] + [F7] ：图形接口桌面。
	如果你是以纯文本环境启动Linux的，预设的tty7是没有东西的！可以通过startx来启动x窗口画面。
	要让startx生效至少需要底下这几件事情的配合：
	 你的tty7并没有其他的窗口软件正在运作(tty7必须是空出来的)；
	 你必须要已经安装了X Window system，并且X server是能够顺利启动的；
	 你最好要有窗口管理员，例如GNOME/KDE或者是阳春的TWM等；
	 启动X所必须要的服务，例如字型服务器(X Font Server, xfs)必须要先启动。	
	Linux启动时可以选择纯文本或者是窗口环境，也谈到了执行等级(run level)这东西！ Linux预设提供了七个Run level给我们使用，其中最常用到的就是run level 3与run level 5这两者了。 如果你想要让Linux在下次开机时使用纯文本环境(run level 3)来登入， 只要修订一下/etc/inittab这个档案的内容，就能够在下次重新启动时生效了！图形接口的登入环境(所谓的执行等级run level 5)。
	主机名为： www.vbird.tsai，主机名的显示通常只取第一个小数点前的字母，所以就成为www啦！
	至于提示字符方面，在Linux当中，默认root的提示字符为 # ，而一般身份用户的提示字符为 $ 。	
	用户登录后显示的distribution和kernel的信息和/etc/issue这个文件有关。
	注销用exit。『离开系统幵丌是关机！』 基本上，Linux本身已经有相当多的工作在进行，你的登入也仅是其中的一个『工作』而已， 所以当你离开时，这次这个登入的工作就停止了，但此时Linux其他的工作是还是继续在进行的！
	指令太长的时候，可以使用反斜杠 (\) 来跳脱[Enter]符号，使指令连续到下一行。 注意！反斜杠后就立刻接特殊字符，才能跳脱！	
	uname打印指定系统信息，可以用-a参数来打印所有的结果。	
	echo $LANG可以打印当前使用的语系。可以通过给$LANG赋值来改变其值，但只限于本次登录，注销后就失效了。	
	几个简单的指令：
		显示日期不时间的指令： date
		显示日历的指令： cal。 
			cal 2014：显示2014整年的日历。cal 01 2014：显示2014年1月份的日历。
		简单好用的计算器： bc
			bc预设仅输出整数，如果要输出小数点下位数，那么就必须要执行 scale=number ，那个number就是小数点位数。比如scale=3，1/3输出.333
			使用quit退出bc
	重要的几个热键	
		按[tab]按键的地方如果是在command(第一个输入的数据)后面时，他就代表着 『命令补全』，如果是接在第二个字以后的，就会变成『档案补齐』的功能了！连按两次tab会列出所有可能的补齐。总结一下：
		 [Tab] 接在一串指令的第一个字的后面，则为命令补全；
		 [Tab] 接在一串指令的第二个字以后时，则为『档案补齐』！
		[Ctrl]与d按键的组合啊！这个组合按键通常代表着： 『键盘输入结束(End Of File, EOF 或 End Of Input)』的意思！ 另外，他也可以用来取代exit的输入呢！例如你想要直接离开文字接口，可以直接按下[Ctrl]-d就能够直接离开了(相当于输入exit啊！)。
	在文本模式下，你可以直接按下两个[Tab]按键，看看总共有多少指令可以让你用？如果不想看，按n离开。	
	man page
		进入man指令的功能后，你可以按下『空格键』往下翻页，可以按下『 q 』按键来离开man的环境。	
		man指令的输出中，指令后面的数字代表的意义：
			代号 		代表内容 
			1 			用户在shell环境中可以操作的指令或可执行文件 
			2 			系统核心可呼叫的函数与工具等 
			3 			一些常用的函数(function)与函式库(library)，大部分为C的函式库(libc) 
			4 			装置档案的说明，通常在/dev下的档案 
			5 			配置文件或者是某些档案的格式 
			6 			游戏(games) 
			7 			惯例与协议等，例如Linux文件系统、网络协议、ASCII code等等的说明 
			8 			系统管理员可用的管理指令 
			9 			跟kernel有关的文件
		上述的表格内容可以使用『man 7 man』来更详细的取得说明。
		上表中的1, 5, 8这三个号码特别重要。
		基本上，man page大致分成底下这几个部分： 
			代号 		内容说明 
			NAME 		简短的指令、数据名称说明 
			SYNOPSIS 	简短的指令下达语法(syntax)简介 
			DESCRIPTION 较为完整的说明，这部分最好仔细看看！ 
			OPTIONS 	针对 SYNOPSIS 部分中，有列举的所有可用的选项说明 
			COMMANDS 	当这个程序(软件)在执行的时候，可以在此程序(软件)中下达的指令 
			FILES 		这个程序或数据所使用或参考或连结到的某些档案 
			SEE ALSO 	可以参考的，跟这个指令或数据有相关的其他说明！ 
			EXAMPLE 	一些可以参考的范例 
			BUGS 		是否有相关的臭虫！
		man page中可以使用的快捷键：
			按键 			进行工作 
			空格键 			向下翻一页 
			[Page Down] 	向下翻一页 
			[Page Up] 		向上翻一页 
			[Home] 			去到第一页 
			[End] 			去到最后一页 
			/string 		向『下』搜寻 string 这个字符串，如果要搜寻 vbird 的话，就输入 /vbird 
			?string 		向『上』搜寻 string 这个字符串 
			n, N 			利用 / 或 ? 来搜寻字符串时，可以用 n 来继续下一个搜寻 (不论是 / 或 ?) ，可以利用 N 来进行『反向』搜寻。举例来说，我以 /vbird 搜寻 vbird 字符串， 那么可以 n 继续往下查询，用 N 往上查询。若以 ?vbird 向上查询 vbird 字符串， 那我可以用 n 继续『向上』查询，用 N 反向查询。 
			q 				结束这次的 man page
		man page的数据放在哪里呢？不同的distribution通常可能有点差异性，不过，通常是放在/usr/share/man这个目录里头，然而，我们可以透过修改他的man page搜寻路径来改善这个目录的问题！修改/etc/man.config (有的版本为man.conf或manpath.conf)即可啰！至于更多的关于man的讯息你可以使用『 man man 』来查询呦！
		如果忘记了该指令的完整名称。 有些时候则是你只记得该指令的部分关键词。这个时候你要如何查出来你所想要知道的man page呢？
			[vbird@www ~]$ man -f man 
				man (1) - format and display the on-line manual pages 
				man (7) - macros to format man pages 
				man.config [man] (5) - configuration data for man
			使用 -f 这个选项就可以取得更多与man相关的信息，而上面这个结果当中也有提示了 (数字) 的内容， 举例来说，第二行的『 man (7) 』表示有个man (7)的说明文件存在喔！
			man 1 man <==这里是用 man(1) 的文件数据
			那么万一我真的忘记了下达数字，只有输入『 man man 』时，那么取出的数据到底是1还是7啊？ 这个就跟搜寻的顺序有关了。搜寻的顺序是记录在/etc/man.conf这个配置文件当中， 先搜寻到的那个说明档，就会先被显示出来！ 一般来说，通常会先找到数字较小的那个啦！
			上面的『man -f man』输出的结果中，我们知道其实输出的数据是：
			 左边部分：指令(或档案)以及该指令所代表的意义(就是那个数字)；
			 右边部分：这个指令的简易说明，例如上述的『-macros to format man pages』
			当使用『man -f 指令』时，man只会找数据中的左边那个指令(或档案)的完整名称，有一点不同都不行！
		如果想要只要该内容有关键词存在， 不需要完全相同的指令(或档案)就能够找到时，该怎么办？
			man -k man
			因为这个是利用关键词将说明文件里面只要含有man那个字眼的(不见得是完整字符串) 就将他取出来！
		事实上，还有两个指令与man page有关呢！而这两个指令是man的简略写法说～就是这两个：
			whatis [指令或者是数据] <==相当于 man -f [指令或者是数据]
			apropos [指令或者是数据] <==相当于 man -k [指令或者是数据]
		而要注意的是，这两个特殊指令要能使用，必须要有建立 whatis 数据库才行！这个数据库的建立需要以 root 的身份下达如下的指令：makewhatis	
	info page
		在所有的Unix Like系统当中，都可以利用 man 来查询指令或者是相关档案的用法； 但是，在Linux里面则又额外提供了一种在线求助的方法，那就是利用info这个好用的家伙啦！
		这个支持info指令的文件默认是放置在/usr/share/info/这个目录当中的。
	其他有用的文件(documents)
		指令或者软件的说明文档一般放在/usr/share/doc这个目录。/usr/share/doc这个目录下的数据主要是以套件(packages)为主的。比如：
			这一版的CentOS相关的各项信息：/usr/share/doc/centos-release-notes-5.3/
			bash的信息：/usr/share/doc/bash-3.2/
			gcc的信息：/usr/share/doc/gcc-xxx(那个xxx表示版本的意思！)。
	超简单文书编辑器： nano
		nano的使用其实很简单，你可以直接加上档名就能够开启一个旧档或新档！
		你可以看到第一行反白的部分，那仅是在宣告nano的版本与档名(File: text.txt)而已。 之后你会看到最底下的三行，分别是档案的状态(New File)与两行指令说明列。指令说明列反白的部分就是组合键， 接的则是该组合键的功能。那个指数符号(^)代表的是键盘的[Ctrl]按键啦！那个M是代表什么呢？其实就是[alt]啰！
		比较重要的几个组合按键：
		 [ctrl]-G：取得联机帮助(help)，很有用的！
		 [ctrl]-X：离开naon软件，若有修改过档案会提示是否需要储存喔！
		 [ctrl]-O：储存档案，若你有权限的话就能够储存档案了；
		 [ctrl]-R：从其他档案读入资料，可以将某个档案的内容贴在本档案中；
		 [ctrl]-W：搜寻字符串，这个也是很有帮助的指令喔！
		 [ctrl]-C：说明目前光标所在处的行数与列数等信息；
		 [ctrl]-_：可以直接输入行号，让光标快速移动到该行；
		 [alt]-Y：校正语法功能开启或关闭(单击开、再单击关)
		 [alt]-M：可以支持鼠标来移动光标的功能
	正确的关机方法
		正常情况下，要关机时需要注意底下几件事：
		 观察系统的使用状态： 
				如果要看目前有谁在在线，可以下达『who』这个指令，而如果要看网络的联机状态，可以下达 『 netstat -a 』这个指令，而要看背景执行的程序可以执行『 ps -aux 』这个指令。使用这些指令可以让你稍微了解主机目前的使用状态！当然啰，就可以让你判断是否可以关机了 （这些指令在后面Linux常用指令中会提及喔！）
		 通知在线使用者关机的时刻： 
				要关机前总得给在线的使用者一些时间来结束他们的工作，所以，这个时候你可以使用 shutdown 的特别指令来达到此一功能。
		 正确的关机指令使用： 
				例如 shutdown 与 reboot 两个指令！
		数据同步写入磁盘： sync
			直接在文字接口下输入sync，那么在内存中尚未被更新的数据，就会被写入硬盘中！所以，这个指令在系统关机或重新启动之前， 很重要喔！最好多执行几次！
			虽然目前的 shutdown/reboot/halt 等等指令均已经在关机前进行了 sync 这个工具的呼叫， 不过，多做几次总是比较放心点～呵呵～
			事实上sync也可以被一般账号使用喔！只不过一般账号用户所更新的硬盘数据就仅有自己的数据， 不像root可以更新整个系统中的数据了。
	惯用的关机指令： shutdown
		我们较常使用的是shutdown这个指令，而这个指令会通知系统内的各个程序 (processes)，并且将通知系统中的run-level内的一些服务来关闭。shutdown可以达成如下的工作：
		 可以自由选择关机模式：是要关机、重新启动或迚入单人操作模式均可；
		 可以设定关机时间: 可以设定成现在立刻关机, 也可以设定某一个特定的时间才关机。
		 可以自定义关机讯息：在关机之前，可以将自己设定的讯息传送给在线 user 。
		 可以仅发出警告讯息：有时有可能你要进行一些测试，而不想让其他的使用者干扰， 或者是明白的告诉使用者某段时间要注意一下！这个时候可以使用 shutdown 来吓一吓使用者，但却不是真的要关机啦！
		 可以选择是否要 fsck 检查文件系统 。		
		shutdown的简单语法规则为：
			/sbin/shutdown [-t 秒] [-arkhncfF] 时间 [警告讯息]
			选项不参数： 
			-t sec ： -t 后面加秒数，亦即『过几秒后关机』的意思 
			-k ： 不要真的关机，只是发送警告讯息出去！ 
			-r ： 在将系统的服务停掉之后就重新启动(常用) 
			-h ： 将系统的服务停掉后，立即关机。 (常用) 
			-n ： 不经过 init 程序，直接以 shutdown 的功能来关机 
			-f ： 关机并开机之后，强制略过 fsck 的磁盘检查 
			-F ： 系统重新启动之后，强制进行 fsck 的磁盘检查 
			-c ： 取消已经在进行的 shutdown 指令内容。 
			时间 ： 这是一定要加入的参数！指定系统关机的时间！
				shutdown -h now
				shutdown -h 20:25
				shutdown -h +10
		shutdown可以依据目前已启动的服务来逐次关闭各服务后才关机；至于halt即能够在不理会目前系统状况下， 进行硬件关机的特殊功能！
		因为linux的执行等级中run level 0：关机，因此如果要关机的话，可以切换到run level 0，即：init 0。
	文件系统错误的问题
		如果根目录没有损毁
			假设你发生错误的partition是在/dev/sda7这一块，那么在开机的时候，屏幕应该会告诉你：press root password or ctrl+D : 这时候请输入root的密码登入系统，然后进行如下动作：
				在光标处输入root密码登入系统，进行单人单机的维护工作；
				输入『 fsck /dev/sda7 』(fsck 为文件系统检查的指令，/dev/sda7为错误的partition，请依你的情况下达参数)， 这时屏幕会显示开始修理硬盘的讯息，如果有发现任何的错误时，屏幕会显示： clear [Y/N]？ 的询问讯息，就直接输入 Y 吧！
				修理完成后，以 reboot 重新启动啰！
		如果根目录损毁了
			一般初学者喜欢将自己的硬盘只划分为一个大partition，亦即只有根目录， 那文件系统错误一定是根目录的问题啰！这时你可以将硬盘拔掉，接到另一台Linux系统的计算机上， 并且不要挂载(mount)该硬盘，然后以root的身份执行『 fsck /dev/sdb1 』(/dev/sdb1 指的是你的硬盘装置文件名，你要依你的实际状况来设定)，这样就 OK 啰！
		/var是系统默认的一些数据暂存或者是cache数据的储存目录， 像 e-mail 就含在这里面。	
	忘记root密码
		当root密码忘记时，只要以单人维护模式登入即可更改你的root密码喔！
			先将系统重新启劢，在读秒的时候按下任意键就会出现如同第四章图3.2的选单画面，仔细看选单底下的说明， 按下『e』就能够进入grub的编辑模式了。此时你看到的画面有点像底下这样：
				root (hd0,0)
				kernel /vmlinuz-2.6.18-128.el5 ro root=LABEL=/ rhgb quiet 
				initrd /initrd-2.6.18-128.el5.img
			此时，请将光标移动到kernel那一行，再按一次『 e 』进入kernel该行的编辑画面中， 然后在出现的画面当中，最后方输入 single ：
				kernel /vmlinuz-2.6.18-128.el5 ro root=LABEL=/ rhgb quiet single
			再按下『 Enter 』确定之后，按下 b 就可以开机进入单人维护模式了！ 在这个模式底下，你会在tty1的地方不需要输入密码即可取得终端机的控制权(而且是使用root的身份喔！)。 之后就能够使用passwd修改root的密码了！
	man -k passwd 与 man -K passwd 有什么差异(大小写的 K )？	
		小写的 -k 为查询关键词，至于 -K 则是整个系统的 man page 查询～ 每个被检查到有关键词的 man page file 都会被询问是否要显示， 你可以输入『ynq』，来表示：y:要显示到屏幕上；n:不显示；q:结束 man 的查询。
	man page 显示的内容的档案是放置在哪些目录中？
		放置在 /usr/share/man/ 与 /usr/local/man 等默认目录中。
	我使用dmtsai这个账号登入系统了，请问我能不能使用reboot来重新启动？ 若不能，请说明原因，若可以，请说明指令如何下达？
		理论上reboot仅能让root执行。不过，如果dmtsai是在主机前面以图形接口登入时，则dmtsai还是可以透过图形接口功能来关机。	
		
		
第六章、Linux 的档案权限与目录配置		
	Linux Standard Base (LSB)
	目录架构的File system Hierarchy Standard (FHS)标准规范！
	Linux 用户身份与群组记录的档案
		默认的情况下，所有的系统上的账号与一般身份使用者，还有那个root的相关信息， 都是记录在/etc/passwd这个档案内的。至于个人的密码则是记录在/etc/shadow这个档案下。 此外，Linux所有的组名都纪录在/etc/group内！
	ls -l的输出结果:[ 权限 ][连结][拥有者][群组][档案容量][ 修改日期 ][ 檔名 ]
		第一栏代表这个档案的类型不权限(permission)：这一栏其实共有十个字符:
			第一个字符代表这个档案是『目录、档案或链接文件等等』：
				o 当为[ d ]则是目录，例如上表档名为『.gconf』的那一行；
				o 当为[ - ]则是档案，例如上表档名为『install.log』那一行；
				o 若是[ l ]则表示为连结档(link file)；
				o 若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；
				o 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。
			接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。第一组为『档案拥有者的权限』;第二组为『同群组的权限』；第三组为『其他非本群组的权限』
		第二栏表示有多少档名连结到此节点(i-node)：
			每个档案都会将他的权限与属性记录到文件系统的i-node中，不过，我们使用的目录树却是使用文件名来记录， 因此每个档名就会连结到一个i-node啰！这个属怅记彔的，就是有多少不同的档名连结到相同的一个i-node号码去就是了。
		第三栏表示这个档案(或目录)的『拥有者账号』
		第四栏表示这个档案的所属群组
		第五栏为这个档案的容量大小，默认单位为bytes；
		第六栏为这个档案的建档日期或者是最近的修改日期：
			如果这个档案被修改的时间距离现在太久了，那么时间部分会仅显示年份而已。『ls -l --full-time』就能够显示出完整的时间格式了！包括年、月、日、时间喔。
			如果要临时改变当前的语系可以改变LANG变量，如LANG=en_US。如果想要让系统默认的语系变成英文的话，那么你可以修改系统配置文件『/etc/sysconfig/i18n』，改变其中LANG的值。
		第七栏为这个档案的档名	
			如果档名之前多一个『 . 』，则代表这个档案为『隐藏档』
			对于目录来说，如果没有x权限，将不能进入该目录。
	几个常用于群组、拥有者、各种身份的权限之修改的指令：
		chgrp ：改变档案所属群组
			要被改变的组名必须要在/etc/group档案内存在才行，否则就会显示错误！
			chgrp [-R]
			-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有档案、目录都更新成为这个群组之意。常常用在变更某一目录内所有的档案之情况。
		chown ：改变档案拥有者
			用户必须是已经存在系统中的账号，也就是在/etc/passwd 这个档案中有纪录的用户名称才能改变。
			chown [-R] 账号名称:组名 档案或目录
			-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有档案都变更
			亊实上，chown也可以使用『chown user.group file』，亦即在拥有者与群组间加上小数点『.』也行！ 不过很多朋友设定账号时，喜欢在账号当中加入小数点(例如vbird.tsai这样的账号格式)，这就会造成系统的误判了！ 所以我们比较建议使用冒号『:』来隔开拥有者与群组啦！此外，chown也能单纯的修改所属群组呢！ 例如『chown .sshd install.log』就是修改群组～看到了吗？就是那个小数点的用途！
			确实有时候需要变更档案的拥有者的，最常见的例子就是在复制档案给你之外的其他人时
		chmod ：改变档案的权限, SUID, SGID, SBIT等等的特性
			权限的设定方法有两种， 分别可以使用数字或者是符号来进行权限的变更。
				数字类型改变档案权限
					我们可以使用数字来代表各个权限，各权限的分数对照表如下：r:4 w:2 x:1
					chmod [-R] xyz 档案或目录 
						选项与参数： 
							xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。 
							-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有档案都会变更
				符号类型改变档案权限
					基本上就九个权限分别是(1)user (2)group (3)others三种身份啦！那么我们就可以藉由u, g, o来代表三种身份的权限！此外， a 则代表 all 亦即全部的身份！那么读写的权限就可以写成r, w, x啰！
						chmod
						u g o a
						+(加入) -(除去) =(设定)
						r w x
						档案或目录
	目录与档案之权限意义：		
		权限对于档案来说，他的意义是这样的：
			r (read)：可读取此一档案的实际内容，如读取文本文件的文字内容等；
			w (write)：可以编辑、新增或者是修改该档案的内容(但不含删除该档案)；
			x (eXecute)：该档案具有可以被系统执行的权限。
		权限对目录的重要性
			档案是存放实际数据的所在，那么目录主要是储存啥玩意啊？目录主要的内容在记录文件名列表，文件名与目录有强烈的关连啦！ 所以如果是针对目录时，那个 r, w, x 对目录是什么意义呢？
				r (read contents in directory)： 表示具有读取目录结构列表的权限，所以当你具有读取(r)一个目录的权限时，表示你可以查询该目录下的文件名数据。 所以你就可以利用 ls 这个指令将该目录的内容列表显示出来！
				w (modify contents of directory)： 这个可写入的权限对目录来说，是很了不起的！ 因为他表示你具有异动该目彔结构列表的权限，也就是底下这些权限：
					o 建立新的档案与目录；
					o 删除已经存在的档案与目录(不论该档案的权限为何！)
					o 将已存在的档案或目录进行更名；
					o 搬移该目录内的档案、目录位置。
					总之，目录的w权限就与该目录底下的文件名异动有关就对了啦！
				x (access directory)： 咦！目录的执行权限有啥用途啊？目录只是记录文件名而已，总不能拿来执行吧？没错！目录不可以被执行，目录的x代表的是用户能否进入该目录成为工作目录的用途！ 所谓的工作目录(work directory)就是你目前所在的目录啦！
					工作目录对于指令的执行是非常重要的，如果你在某目录下不具有x的权限， 那么你就无法切换到该目录下，也就无法执行该目录下的任何指令，即使你具有该目录的r的权限。
			对于目录，只有r确实可以让用户读取目录的文件名列表，不过详细的信息却还是读不到的，只能看到文件名。		
	Linux档案种类与扩展名	
		正规档案(regular file )：
			依照档案的内容，又大略可以分为：
				纯文本档(ASCII)：这是Linux系统中最多的一种文件类型啰， 称为纯文本档是因为内容为我们人类可以直接读到的数据，例如数字、字母等等。
				二进制文件(binary)：我们的系统其实仅认识且可以执行二进制文件(binary file)。Linux当中的可执行文件(scripts, 文字型批处理文件不算)就是这种格式的，比如cat。
				数据格式文件(data)： 有些程序在运作的过程当中会读取某些特定格式的档案，那些特定格式的档案可以被称为数据文件 (data file)。举例来说，我们的Linux在使用者登入时，都会将登录的数据记录在 /var/log/wtmp那个档案内，该档案是一个data file，他能够透过last这个指令读出来！ 但是使用cat时，会读出乱码～因为他是属于一种特殊格式的档案。
		目录(directory)：
		连结档(link)：第一个属性为 [ l ](英文L的小写)
		设备与装置文件(device)：
			与系统周边及储存等相关的一些档案， 通常都集中在/dev这个目录之下！通常又分为两种：
				o 区块(block)设备档 ：就是一些储存数据， 以提供系统随机存取的接口设备，举例来说，硬盘与软盘等就是啦！ 你可以随机的在硬盘的不同区块读写，这种装置就是成组设备啰！你可以自行查一下/dev/sda看看， 会发现第一个属性为[ b ]喔！
				o 字符(character)设备文件：亦即是一些串行端口的接口设备， 例如键盘、鼠标等等！这些设备的特色就是『一次性读取』的，不能够截断输出。 举例来说，你不可能让鼠标『跳到』另一个画面，而是『滑动』到另一个地方啊！第一个属性为 [ c ]。
		资料接口文件(sockets)：
			既然被称为数据接口文件， 想当然尔，这种类型的档案通常被用在网络上的数据承接了。我们可以启动一个程序来监听客户端的要求， 而客户端就可以透过这个socket来进行数据的沟通了。第一个属性为 [ s ]， 最常在/var/run这个目录中看到这种文件类型了。
			数据输送文件(FIFO, pipe)： FIFO也是一种特殊的文件类型，他主要的目的在解决多个程序同时存取一个档案所造成的错误问题。 FIFO是first-in-first-out的缩写。第一个属性为[p] 。		
		例如你在网络上下载一个可执行文件，但是偏偏在你的 Linux系统中就是无法执行！呵呵！那么就是可能档案的属性被改变了！不要怀疑，从网络上传送到你的 Linux系统中，档案的属性与权限确实是会被改变的喔！		
		在Linux底下，使用预设的Ext2/Ext3文件系统时，针对档案的档名长度限制为：
			单一档案或目录的最大容许文件名为 255 个字符；
			包含完整路径名称及目录 (/) 之完整档名为 4096 个字符。
	Linux目录配置
		FHS（Filesystem Hierarchy Standard）的重点在于规范每个特定的目录下应该要放置什么样子的数据而已。
		FHS依据文件系统使用的频繁与否与是否允讲使用者随意更动， 而将目录定义成为四种交互作用的形态，用表格来说有点像底下这样： 
										可分享的(shareable) 					不可分享的(unshareable) 
			不变的(static) 				/usr (软件放置处) 						/etc (配置文件) 
										/opt (第三方协力软件) 					/boot (开机不核心档) 
			可变动的(variable) 			/var/mail (使用者邮件信箱) 				/var/run (程序相关) 
										/var/spool/news (新闻组) 				/var/lock (程序相关)
		上表中的目录就是一些代表性的目彔，该目录底下所放置的数据在底下会谈到，这里先略过不谈。 我们要了解的是，什么是那四个类型？
		 可分享的：可以分享给其他系统挂载使用的目录，所以包括执行文件与用户的邮件等数据， 是能够分享给网络上其他主机挂载用的目录；
		 不可分享的：自己机器上面运作的装置档案或者是与程序有关的socket档案等， 由于仅与自身机器有关，所以当然就不适合分享给其他主机了。
		 不变的：有些数据是不会经常变动的，跟随着distribution而不变动。 例如函式库、文件说明文件、系统管理员所管理的主机服务配置文件等等；
		 可变动的：经常改变的数据，例如登录文件、一般用户可自行收受的新闻组等。
		亊实上，FHS针对目录树架构仅定义出三层目录底下应该放置什么数据而已，分别是底下这三个目录的定义：
		 / (root, 根目录)：与开机系统有关；
		 /usr (unix software resource)：与软件安装/执行有关；
		 /var (variable)：与系统运作过程有关。
		根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的， 同时根目录也与开机/还原/系统修复等动作有关。 由于系统开机时需要特定的开机软件、核心档案、开机所需程序、 函式库等等档案数据，若系统出现错误时，根目录也必须要包含有能够修复文件系统的程序才行。 因为根目录是这么的重要，所以在FHS的要求方面，他希服根目录不要放在非常大的分割槽内， 因为越大的分割槽你会放入越多的数据，如此一来根目录所在分割槽就可能会有较多发生错误的机会。
		FHS定义出根目录(/)底下应该要有底下这些次目录的存在才好：
			目录 			应放置档案内容 
			/bin 			系统有很多放置执行文件的目录，但/bin比较特殊。因为/bin放置的是在单人维护模式下还能够被操作的指令。 在/bin底下的指令可以被root与一般账号所使用，主要有：cat, chmod, chown, date, mv, mkdir, cp, bash等等常用的指令。 
			/boot 			这个目录主要在放置开机会使用到的档案，包括Linux核心档案以及开机选单与开机所需配置文件等等。 Linux kernel常用的档名为：vmlinuz，如果使用的是grub这个开机管理程序， 则还会存在/boot/grub/这个目录喔！ 
			/dev 			在Linux系统上，任何装置与接口设备都是以档案的型态存在于这个目录当中的。 你只要透过存取这个目录底下的某个档案，就等于存取某个装置啰～ 比要重要的档案有/dev/null（In Unix-like operating systems, /dev/null or the null device is a special file that discards all data written to it but reports that the write operation succeeded. It provides no data to any process that reads from it, yielding EOF immediately.）, /dev/zero（/dev/zero is a special file in Unix-like operating systems that provides as many null characters (ASCII NUL, 0x00) as are read from it. One of the typical uses is to provide a character stream for initializing data storage.）, /dev/tty, /dev/lp*, /dev/hd*, /dev/sd*等等 
			/etc 			系统主要的配置文件几乎都放置在这个目录内，例如人员的账号密码文件、 各种服务的启始档等等。一般来说，这个目录下的各文件属性是可以让一般使用者查阅的， 但是只有root有权力修改。FHS建议不要放置可执行文件(binary)在这个目录中喔。比较重要的档案有： /etc/inittab, /etc/init.d/, /etc/modprobe.conf, /etc/X11/, /etc/fstab, /etc/sysconfig/ 等等。
							另外，其下重要的目录有：  
								/etc/init.d/：所有服务的预设启动 script 都是放在这里的，例如要启动或者关闭 iptables 的话：『 /etc/init.d/iptables start』、『/etc/init.d/iptables stop』  
								/etc/xinetd.d/：这就是所谓的super daemon管理的各项服务的配置文件目录。  
								/etc/X11/：与 X Window 有关的各种配置文件都在这里，尤其是 xorg.conf 这个 X Server 的配置文件。
			/home 			这是系统默认的用户家目录(home directory)。在你新增一个一般使用者账号时， 默认的用户家目录都会规范到这里来。比较重要的是，家目录有两种代号喔： ~：代表目前这个用户的家目录，而 ~dmtsai ：则代表 dmtsai 的家目录！ 
			/lib 			系统的函式库非常的多，而/lib放置的则是在开机时会用到的函式库， 以及在/bin或/sbin底下的指令会呼叫的函式库而已。 什么是函式库呢？妳可以将他想成是『外挂』，某些指令必须要有这些『外挂』才能够顺利完成程序的执行之意。 尤其重要的是/lib/modules/这个目录， 因为该目录会放置核心相关的模块(驱动程序)喔！ 
			/media 			media是『媒体』的英文，顾名思义，这个/media底下放置的就是可移除的装置啦！ 包括软盘、光盘、DVD等等装置都暂时挂载于此。常见的档名有：/media/floppy, /media/cdrom等等。 
			/mnt 			如果妳想要暂时挂载某些额外的装置，一般建议妳可以放置到这个目彔中。 在古早时候，这个目录的用途与/media相同啦！只是有了/media之后，这个目录就用来暂时挂载用了。 
			/opt 			这个是给第三方协力软件放置的目录。什么是第三方协力软件啊？ 举例来说，KDE这个桌面管理系统是一个独立的计划，不过他可以安装到Linux系统中，因此KDE的软件就建议放置到此目录下了。 另外，如果妳想要自行安装额外的软件(非原本的distribution提供的)，那举也能够将你的软件安装到这里来。 不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下呢！ 
			/root 			系统管理员(root)的家目录。之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时， 该目录就能够拥有root的家目录，所以我们会希望root的家目录与根目录放置在同一个分割槽中。 
			/sbin 			Linux有非常多指令是用来设定系统环境的，这些指令只有root才能够利用来『设定』系统，其他用户最多只能用来『查询』而已。 放在/sbin底下的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。 至于某些服务器软件程序，一般则放置到/usr/sbin/当中。至于本机自行安装的软件所产生的系统执行文件(system binary)， 则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, init, mkfs等等。 
			/srv 			srv可以视为『service』的缩写，是一些网络服务启动之后，这些服务所需要取用的数据目录。 常见的服务例如WWW, FTP等等。举例来说，WWW服务器需要的网页资料就可以放置在/srv/www/里面。 
			/tmp 			这是让一般用户或者是正在执行的程序暂时放置档案的地方。 这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要数据不可放置在此目录啊！ 因为FHS甚至建议在开机时，应该要将/tmp下的数据都删除唷！
		亊实上FHS针对根目录所定义的标准就仅有上面的咚咚，不过我们的Linux底下还有讲多目录你也需要了解一下的。 底下是几个在Linux当中也是非常重要的目录喔：
			目录 			应放置档案内容 
			/lost+found 	这个目录是使用标准的ext2/ext3文件系统格式才会产生的一个目录，目的在于当文件系统发生错误时， 将一些遗失的片段放置到这个目录下。这个目录通常会在分割槽的最顶层存在， 例如你加装一颗硬盘于/disk中，那在这个系统下就会自动产生一个这样的目录『/disk/lost+found』 
			/proc 			这个目录本身是一个『虚拟文件系统(virtual filesystem)』喔！他放置的数据都是在内存当中， 例如系统核心、行程信息(process)、周边装置的状态及网络状态等等。因为这个目录下的数据都是在内存当中， 所以本身不占任何硬盘空间啊！比较重要的档案例如：/proc/cpuinfo, /proc/dma（A device that needs a lot of data, interrupts and ports can pose a heavy load on the cpu. With dma or Direct Memory Access a device can gain (temporary) access to a specific range of the ram memory.）, /proc/interrupts, /proc/ioports, /proc/net/* 等等。 
			/sys 			这个目录其实跟/proc非常类似，也是一个虚拟的文件系统，主要也是记录与核心相关的信息。 包括目前已加载的核心模块与核心侦测到的硬件装置信息等等。这个目录同样不占硬盘容量喔！
		除了这些目录的内容之外，另外要注意的是，因为根目录与开机有关，开机过程中仅有根目录会被挂载， 其他分割槽则是在开机完成之后才会持续的进行挂载的行为。就是因为如此，因此根目录下与开机过程有关的目录， 就不能够与根目彔放到不同的分割槽去！那哪些目彔不可与根目彔分开呢？有底下这些：
		 /etc：配置文件
		 /bin：重要执行档
		 /dev：所需要的装置档案
		 /lib：执行档所需的函式库与核心所需的模块
		 /sbin：重要的系统执行文件
		这五个目录千万不可与根目录分开在不同的分割槽！
		/usr 的意义与内容：
			依据FHS的基本定义，/usr里面放置的数据属于可分享的与不可变动的(shareable, static)， 如果你知道如何透过网络进行分割槽的挂载(例如在服务器篇会谈到的NFS服务器)，那么/usr确实可以分享给局域网络内的其他主机来使用喔！
			很多读者都会误会/usr为user的缩写，其实usr是Unix Software Resource的缩写， 也就是『Unix操作系统软件资源』所放置的目录，而不是用户的数据啦！这点要注意。 FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行建立该软件自己独立的目录。
			因为是所有系统默认的软件(distribution发布者提供的软件)都会放置到/usr底下，因此这个目录有点类似Windows 系统的『C:\Windows\ + C:\Program files\』这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。 
			一般来说，/usr的次目录建议有底下这些： 
			目录 			应放置档案内容 
			/usr/X11R6/ 	为X Window System重要数据所放置的目录，之所以取名为X11R6是因为最后的X版本为第11版，且该版的第6次释出之意。 
			/usr/bin/ 		绝大部分的用户可使用指令都放在这里！请注意到他与/bin的不同之处。(是否与开机过程有关) 
			/usr/include/ 	c/c++等程序语言的档头(header)与包含档(include)放置处，当我们以tarball方式 (*.tar.gz 的方式安装软件)安装某些数据时，会使用到里头的讲多包含档喔！ 
			/usr/lib/ 		包含各应用软件的函式库、目标档案(object file)，以及不被一般使用者惯用的执行档或脚本(script)。 某些软件会提供一些特殊的指令来进行服务器的设定，这些指令也不会经常被系统管理员操作， 那就会被摆放到这个目录下啦。要注意的是，如果你使用的是X86_64的Linux系统， 那可能会有/usr/lib64/目录产生喔！ 
			/usr/local/ 	系统管理员在本机自行安装自己下载的软件(非distribution默认提供者)，建议安装到此目录， 这样会比较便于管理。举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦！ 你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib...的次目录喔！ 
			/usr/sbin/ 		非系统正常运作所需要的系统指令。最常见的就是某些网络服务器软件的服务指令(daemon)啰！
			/usr/share/ 	放置共享文件的地方，在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文本文件嘛！在此目录下常见的还有这些次目录：  
							/usr/share/man：联机帮助文件  
							/usr/share/doc：软件杂项的文件说明  
							/usr/share/zoneinfo：与时区有关的时区档案 
							/usr/src/ 一般原始码建议放置到这里，src有source的意思。至于核心原始码则建议放置到/usr/src/linux/目录下。
		/var 的意义与内容：
			如果/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运作后才会渐渐占用硬盘容量的目录。 因为/var目录主要针对常态性变动的档案，包括快取(cache)、登录档(log file)以及某些软件运作所产生的档案， 包括程序档案(lock file, run file)，或者例如MySQL数据库的档案等等。
			常见的次目录有： 
			目录 			应放置档案内容 
			/var/cache/ 	应用程序本身运作过程中会产生的一些暂存档； 
			/var/lib/ 		程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去！ 
			/var/lock/ 		某些装置或者是档案资源一次只能被一个应用程序所使用，如果同时有两个程序使用该装置时， 就可能产生一些错误的状况，因此就得要将该装置上锁(lock)，以确保该装置只会给单一软件所使用。 举例来说，刻录机正在刻录一块光盘，你想一下，会不会有两个人同时在使用一个刻录机烧片？ 如果两个人同时刻录，那片子写入的是谁的资料？所以当第一个人在刻录时该刻录机就会被上锁， 第二个人就得要该装置被解除锁定(就是前一个人用完了)才能够继续使用啰。 
			/var/log/ 		重要到不行！这是登录文件放置的目录！里面比较重要的档案如/var/log/messages, /var/log/wtmp(记录登入者的信息)等。 
			/var/mail/ 		放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中！ 通常这两个目录是互为链接文件啦！ 
			/var/run/ 		某些程序或者是服务启动后，会将他们的PID放置在这个目录下喔！ 至于PID的意义我们会在后续章节提到的。 
			/var/spool/ 	这个目录通常放置一些队列数据，所谓的『队列』就是排队等待其他程序使用的数据啦！ 这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到/var/spool/mail/中， 但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到/var/spool/mqueue/中， 等到被送出后就被删除。如果是工作排程数据(crontab)，就会被放置到/var/spool/cron/目录中！
		FHS仅是定义出最上层(/)及次层(/usr, /var)的目录内容应该要放置的档案或目录数据， 因此，在其他次目录层级内，就可以随开发者自行来配置了。
		每一个目录不止能使用本地端的 partition 的文件系统，也可以使用网络上的 filesystem 。举例来说， 可以利用 Network File System (NFS) 服务器挂载某特定目录等。
		/selinux是Secure Enhance Linux(SELinux)的执行目录， 而SELinux是Linux核心的重要外挂功能之一，他可以用来作为细部权限的控管，主要针对程序(尤其是网络程序)的访问权限来限制。
		察看distribution使用的linux核心的版本: uname -r
		察看distribution使用的是哪个linux标准（LSB：Linux Standard Base）：lsb_release -a
		FHS所定义的三层主目录为：/, /var, /usr三层而已；
 		有五个目录不可与根目录放在不同的partition，分别为/etc, /bin, /lib, /dev, /sbin五个。
		/bin与/usr/bin目录所放置的执行文件有何不同之处？
			/bin主要放置在开机时，以及进入单人维护模式后还能够被使用的指令，至于/usr/bin则是大部分软件提供的指令放置处。
		/bin与/sbin目录所放置的执行文件有何不同之处？
			/bin放置的是一般用户惯用的指令，至于/sbin则是系统管理员才会使用到的指令。不过/bin与/sbin都与开机、单人维护模式有关。 更多的执行档会被放置到/usr/bin及/usr/sbin底下。
		根据FHS的说明，越小的/可以放置的较为集中且读取频率较不频繁，可避免较多的错误。 至于/home(用户家目录), /usr(软件资源), /var(变动幅度较大的数据), /tmp(系统暂存，数据莫名)中， 因为数据量较大或者是读取频率较高，或者是不明的使用情况较多，因此建议不要与根目录放在一起， 也会有助于系统安全。
		请问底下的目录与主要放置什么数据： /etc/, /etc/init.d, /boot, /usr/bin, /bin, /usr/sbin, /sbin, /dev, /var/log
			o /etc/：几乎系统的所有配置文件案均在此，尤其 passwd,shadow
			o /etc/init.d：系统开机的时候加载服务的 scripts 的摆放地点
			o /boot：开机配置文件，也是预设摆放核心 vmlinuz 的地方
			o /usr/bin, /bin：一般执行档摆放的地方
			o /usr/sbin, /sbin：系统管理员常用指令集
			o /dev：摆放所有系统装置档案的目录
			o /var/log：摆放系统注册表档案的地方
		
		
第七章、Linux 档案与目录管理
	目录与路径
		对于档名的正确性来说，『绝对路径的正确度要比较好～』。 一般来说，鸟哥会建议你，如果是在写程序 (shell scripts) 来管理系统的条件下，务必使用绝对路径的写法。
		- 代表前一个工作目录
		~account 代表 account 这个用户的家目录(account是个账号名称)
		根目录下确实存在 . 与 .. 两个目录，再仔细的查阅， 可发现这两个目录得属性与权限完全一致，这代表根目录的上一层(..)与根目录自己(.)是同一个目录。
		cd是Change Directory的缩写，这是用来变换工作目录的指令。
			cd 没有加上任何路径，也还是代表回到自己家目录得意思喔！
		pwd是Print Working Directory的缩写，也就是显示目前所在目录的指令
			pwd [-P] 选项与参数：-P ：显示出确实的路径，而非使用链接 (link) 路径。
				cd /var/mail <==注意，/var/mail是一个连结档
				pwd /var/mail <==列出目前的工作目录
				pwd -P /var/spool/mail <==怎么回事？有没有加 -P 差很多～
				ls -ld /var/mail lrwxrwxrwx 1 root root 10 Sep 4 17:54 /var/mail -> spool/mail # 看到这里应该知道为啥了吧？因为 /var/mail 是连结档，连结到 /var/spool/mail # 所以，加上 pwd -P 的选项后，会不以连结文件的数据显示，而是显示正确的完整路径啊！
				ls -d directory 
					list directory entries instead of contents, and do not dereference symbolic links. (显示后面所跟参数目录自身的信息,而不是目录的内容-目录下的子目录信息，如果目录是链接，则也显示链接的信息。)
		mkdir [-mp] 目录名称 
			选项与参数： 
				-m ：配置文件案的权限喔！直接设定，不需要看预设权限 (umask) 的脸色～。如mkdir -m 711 test2
				-p ：帮助你直接将所需要的目录(包含上层目录)递归建立起来！			
		rmdir [-p] 目录名称 
			选项与参数： 
				-p ：连同上层『空的』目录也一起删除			
		当我们在执行一个指令的时候，举例来说『ls』好了，系统会依照PATH的设定去每个PATH定义的目录下搜寻文件名为ls的可执行文件， 如果在PATH定义的目录中含有多个文件名为ls的可执行文件，那么先搜寻到的同名指令先被执行！
		PATH(一定是大写)这个变量的内容是由一堆目录所组成的，每个目录中间用冒号(:)来隔开， 每个目录是有『顺序』之分的。
		如果PATH变量中不包含当前目录(.)，那么即使在命令文件所在的目录，也不能通过直接输入命令名来执行，而是要使用绝对路径或相对路径，如./ls。
		为什么PATH搜寻的目录不加入本目录(.)？加入本目录的搜寻不是也不错？
			如果在PATH中加入本目录(.)后，确实我们就能够在指令所在目录进行指令的执行了。 但是由于你的工作目录并非固定(常常会使用cd来切换到不同的目录)， 因此能够执行的指令会有变动(因为每个目录底下的可执行文件都不相同嘛！)，这对使用者来说并非好事。 
			另外，如果有个坏心使用者在/tmp底下做了一个指令，因为/tmp是大家都能够写入的环境，所以他当然可以这样做。 假设该指令可能会窃取用户的一些数据，如果你使用root的身份来执行这个指令，那不是很糟糕？ 如果这个指令的名称又是经常会被用到的ls时，那『中标』癿机率就更高了！ 。
			所以，为了安全起见，不建议将『.』加入PATH的搜寻目录中。
	档案与目录管理	
		ls [-aAdfFhilnrRSt] 目录名称
		ls [--color={never,auto,always}] 目录名称
		ls [--full-time] 目录名称
		选项与参数： 
			-a ：全部的档案，连同隐藏档( 开头为 . 的档案) 一起列出来(常用) 
			-A ：全部的档案，连同隐藏档，但不包括 . 与 .. 这两个目录 
			-d ：仅列出目录本身，而不是列出目录内的档案数据(常用) 
			-f ：直接列出结果，而不进行排序 (ls 预设会以档名排序！) 
			-F ：根据档案、目录等信息，给予附加数据结构，例如： *:代表可执行文件； /:代表目录； =:代表 socket 档案； |:代表 FIFO 档案； 
			-h ：将档案容量以人类较易读的方式(例如 GB, KB 等等)列出来； 
			-i ：列出 inode 号码，inode 的意义下一章将会介绍； 
			-l ：长数据串行出，包含档案的属性与权限等等数据；(常用) 
			-n ：列出 UID 与 GID 而非使用者与群组的名称 (UID与GID会在账号管理提到！) 
			-r ：将排序结果反向输出，例如：原本档名由小到大，反向则为由大到小； 
			-R ：连同子目录内容一起列出来，等于该目录下的所有档案都会显示出来； 
			-S ：以档案容量大小排序，而不是用档名排序； 
			-t ：依时间排序，而不是用档名。 
			--color=never ：不要依据档案特性给予颜色显示； 
			--color=always ：显示颜色 
			--color=auto ：让系统自行依据设定来判断是否给予颜色 
			--full-time ：以完整时间模式 (包含年、月、日、时、分) 输出 
			--time={atime,ctime} ：输出 access 时间的改变权限属性时间 (ctime) 而非内容变更时间 (modification time)
		cp [-adfilprsu] 来源文件(source) 目标文件(destination)
		cp [options] source1 source2 source3 .... directory
		选项与参数： 
		-a ：相当于 -pdr 的意思，至于 pdr 请参考下列说明；(常用) 
		-d ：若来源文件为链接文件的属性(link file)，则复制链接文件属性而非档案本身； 
		-f ：为强制(force)的意思，若目标档案已经存在且无法开启，则移除后再尝试一次； 
		-i ：若目标文件(destination)已经存在时，在覆盖时会先询问动作的进行(常用) 
		-l ：进行硬式连结(hard link)的连结档建立，而非复制档案本身； 
		-s ：复制成为符号链接文件 (symbolic link)，亦即『快捷方式』档案；
		-p ：连同档案的属性一起复制过去，而非使用默认属性(备份常用)； 
		-r ：递归持续复制，用于目录的复制行为；(常用) 
		-u ：若 destination 比 source 旧才更新 destination ！ 
		最后需要注意的，如果来源档有两个以上，则最后一个目的文件一定要是『目录』才行！
		一般来说，我们如果去复制别人的数据 (当然，该档案你必须要有 read 癿权限才行啊！ ^_^) 时， 总是希望复制到的数据最后是我们自己的，所以，在预设的条件中， cp 的来源档与目的档的权限是不同的，目的档的拥有者通常会是指令操作者本身。举例来说， 上面的范例二中，由于我是 root 的身份，因此复制过来的档案拥有者与群组就改变成为 root 所有了！
		使用 -l 及 -s 都会建立所谓的连结档(link file)，但是这两种连结档即有不一样的情况。这是怎么一回事啊？ 那个 -l 就是所谓的实体链接(hard link)，至于 -s 则是符号链接(symbolic link)
		如果复制命令的来源文件是连结档，会将连结档指向的的实际档案复制过来。若要复制链接文件的属性，就得要使用 -d 的选项了！
		你能否使用vbird的身份，完整的复制/var/log/wtmp档案到/tmp底下，并更名为vbird_wtmp呢？ 
			答： 实际做看看的结果如下： 
				[vbird@www ~]$ cp -a /var/log/wtmp /tmp/vbird_wtmp 
				[vbird@www ~]$ ls -l /var/log/wtmp /tmp/vbird_wtmp 
				-rw-rw-r-- 1 vbird vbird 96384 9月 24 11:54 /tmp/vbird_wtmp 
				-rw-rw-r-- 1 root utmp 96384 9月 24 11:54 /var/log/wtmp
			由于vbird的身份并不能随意修改档案的拥有者与群组，因此虽然能够复制wtmp的相关权限与时间等属性， 但是与拥有者、群组相关的，原本vbird身份无法进行的动作，即使加上 -a 选项，也是无法达成完整复制权限的！
		rm [-fir] 档案或目录 
		选项与参数： 
			-f ：就是 force 的意思，忽略不存在的档案，不会出现警告讯息； 
			-i ：互动模式，在删除前会询问使用者是否动作 
			-r ：递归删除啊！最常用在目录的删除了！
		对于root，rm命令中已经预设加入-i选项。通过在指令前加上反斜杠，可以忽略掉 alias 的指定选项喔！如：\rm -r /tmp/etc。
		删除一个带有 - 开头的档案，如文件名为-aaa-，因为-后一般接选项，所以系统会误判。有两种方法可以解决，一是在文件名前加上目录名，如rm ./-aaa-，另一个是rm -- -aaa-。
		mv [-fiu] source destination
		mv [options] source1 source2 source3 .... directory
		选项与参数： 
			-f ：force 强制的意思，如果目标档案已经存在，不会询问而直接覆盖； 
			-i ：若目标档案 (destination) 已经存在时，就会询问是否覆盖！ 
			-u ：若目标档案已经存在，且 source 比较新，才会更新 (update)
		取得路径的文件名与目录名称
			basename /etc/sysconfig/network network <== 很简单！就取得最后的档名～ 
			dirname /etc/sysconfig/network /etc/sysconfig <== 取得的变成目录名了！
	档案内容查询
		几个常见的指令：
			cat 由第一行开始显示档案内容
			tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！
			nl 显示的时候，顺道输出行号！
			more 一页一页的显示档案内容
			less 与 more 类似，但是比 more 更好的是，他可以往前翻页！
			head 只看头几行
			tail 只看尾巳几行
			od 以二进制的方式读取档案内容！
		cat
			cat [-AbEnTv] 选项与参数： 
				-A ：相当于 -vET 的整合选项，可列出一些特殊字符而不是空白而已； 
				-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！ 
				-n ：打印出行号，连同空白行也会有行号，与 -b 的选项不同；
				-E ：将结尾的断行字符 $ 显示出来；  
				-T ：将 [tab] 按键以 ^I 显示出来； 
				-v ：列出一些看不出来的特殊字符
			cat 是 Concatenate （连续）的简写， 主要的功能是将一个档案的内容连续的印出在屏幕上面！
		nl
			nl [-bnw] 档案 
			选项与参数： 
				-b ：指定行号指定的方式，主要有两种：
					-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)； 
					-b t ：如果有空行，空的那一行不要列出行号(默认值)； 
				-n ：列出行号表示的方法，主要有三种： 
					-n ln ：行号在屏幕的最左方显示； 
					-n rn ：行号在自己字段的最右方显示，且不加 0 ； 
					-n rz ：行号在自己字段的最右方显示，且加 0 ； 
					-w ：行号字段的占用的位数。
		可翻页检视
			more (一页一页翻动)
				在 more 这个程序的运作过程中，你有几个按键可以按的：
					空格键 (space)：代表向下翻一页；
					Enter ：代表向下翻『一行』；
					/字符串 ：代表在这个显示的内容当中，向下搜寻『字符串』这个关键词；
					:f ：立刻显示出文件名以及目前显示的行数；
					q ：代表立刻离开 more ，不再显示该档案内容。
					b 或 [ctrl]-b ：代表往回翻页，不过这动作只对档案有用，对管线无用。
			less (一页一页翻动)
				可以输入的指令有：
					空格键 ：向下翻动一页；
					[pagedown]：向下翻动一页；
					[pageup] ：向上翻动一页；
					/字符串 ：向下搜寻『字符串』的功能；
					?字符串 ：向上搜寻『字符串』的功能；
					n ：重复前一个搜寻 (与 / 或 ? 有关！)
					N ：反向的重复前一个搜寻 (与 / 或 ? 有关！)
					q ：离开 less 这个程序；
				man这个指令就是呼叫 less 来显示说明文件的内容的！
		取出前面 (head) 与取出后面 (tail) 文字的功能：
			head (取出前面几行)
				head [-n number] 档案 
				选项与参数： 
					-n ：后面接数字，代表显示几行的意思。默认是显示十行。如果接的是负数，例如上面范例的-n -100时，代表列前的所有行数， 但不包括后面100行。举例来说，/etc/man.config共有141行，则上述的指令『head -n -100 /etc/man.config』 就会列出前面41行，后面100行不会打印出来了。
			tail (取出后面几行)
				tail [-n number] 档案 选项与参数： 
					-n ：后面接数字，代表显示几行的意思。默认是显示十行。
					-f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测
				如果不知道/etc/man.config有几行，即只想列出100行以后的数据时，可以使用tail -n +100 /etc/man.config，当man.config共有141行，第100~141行就会被列出来啦！ 前面的99行都不会被显示出来喔！
		非纯文本档： od			
			od [-t TYPE] 档案 
			选项或参数： 
				-t ：后面可以接各种『类型 (TYPE)』的输出，例如： 
					a ：利用默认的字符来输出； 
					c ：使用 ASCII 字符来输出 
					d[size] ：利用十进制(decimal)来输出数据，每个整数占用 size bytes ； 
					f[size] ：利用浮点数(floating)来输出数据，每个数占用 size bytes ； 
					o[size] ：利用八进制(octal)来输出数据，每个整数占用 size bytes ； 
					x[size] ：利用十六进制(hexadecimal)来输出数据，每个整数占用 size bytes ；
				输出结果的最左边第一栏是以 8 进位来表示bytes数。以上面范例来说，第二栏0000020代表开头是第 16 个 byes (2x8) 的内容之意。
	修改档案时间或建置新档： touch	
		档案的时间信息主要有三个：
			modification time (mtime)： 当该档案的『内容数据』变更时，就会更新这个时间！内容数据指的是档案的内容，而不是档案的属性或权限喔！
			status time (ctime)： 当该档案的『状态 (status)』改变时，就会更新这个时间，举例来说，像是权限与属性被更改了，都会更新这个时间啊。
			access time (atime)： 当『该档案的内容被取用』时，就会更新这个读取时间 (access)。举例来说，我们使用 cat 去读取 /etc/man.config ， 就会更新该档案的 atime 了。
		touch [-acdmt] 档案 
			选项与参数： 
				-a ：仅修订 access time； 
				-c ：仅修改档案的时间，若该档案不存在则不建立新档案； 
				-d ：后面可以接欲修订的日期而不用目前的日期，也可以使用 --date="日期或时间"。如touch -d "2 days ago" bashrc。
				-m ：仅修改 mtime ； 
				-t ：后面可以接欲修订的时间而不用目前的时间，格式为[YYMMDDhhmm]。如touch -t 0709150202 bashrc。
		在预设的状态下，如果 touch 后面有接档案， 则该档案的三个时间 (atime/ctime/mtime) 都会更新为目前的时间。若该档案不存在，则会主动的建立一个新的空的档案喔！
		即使我们复制一个档案时，复制所有的属性，但也没有办法复制 ctime 这个属性的。 ctime 可以记录这个档案最近的状态 (status) 被改变的时间。
	档案与目录的默认权限与隐藏权限	
		档案预设权限：umask
			查阅的方式有两种，一种可以直接输入 umask ，就可以看到数字型态的权限设定分数， 一种则是加入 -S (Symbolic) 这个选项，就会以符号类型的方式来显示出权限了！ 奇怪的是，怎么 umask 会有四组数字啊？不是只有三组吗？是没错啦。 第一组是特殊权限用的，我们先不要理他。
			在默认权限的属性上，目录与档案是不一样的。预设的情况如下：
				若使用者建立为『档案』则预设『没有可执行( x )权限』，亦即只有 rw 这两个项目，也就是最大为 666 分，预设权限如下： -rw-rw-rw-
				若用户建立为『目录』，则由于 x 与是否可以进入此目录有关，因此默认为所有权限均开放，亦即为 777 分，预设权限如下： drwxrwxrwx
			要注意的是，umask 的分数指的是『该默认值需要减掉的权限！』如果以上面的例子来说明的话，因为 umask 为 022 ，所以 user 并没有被拿掉任何权限，不过 group 与 others 的权限被拿掉了 2 (也就是 w 这个权限)，那么当使用者：
				建立档案时：(-rw-rw-rw-) - (-----w--w-) ==> -rw-r--r--
				建立目录时：(drwxrwxrwx) - (d----w--w-) ==> drwxr-xr-x
			那么如何设定 umask 呢？简单的很，直接在 umask 后面输入数字（如002） 就好了！
			在预设的情况中， root 的 umask 会拿掉比较多的属性，root 的 umask 默认是 022 ， 这是基于安全的考虑啦～至于一般身份使用者，通常他们的 umask 为 002 ，亦即保留同群组的写入权力！ 其实，关于预设 umask 的设定可以参考 /etc/bashrc 这个档案的内容，不过，不建议修改该档案
		档案隐藏属性
			chattr (配置文件案隐藏属性)
				chattr指令只能在Ext2/Ext3的文件系统上面生效， 其他的文件系统可能就无法支持这个指令了。
				chattr [+-=][ASacdistu] 档案或目录名称 
					选项与参数： 
						+ ：增加某一个特殊参数，其他原本存在参数则不动。 
						- ：移除某一个特殊参数，其他原本存在参数则不动。 
						= ：设定一定，且仅有后面接的参数 
						A ：当设定了 A 这个属性时，若你有存取此档案(或目录)时，他的访问时间 atime 将不会被修改，可避免I/O较慢的机器过度的存取磁盘。这对速度较慢的计算机有帮助 
						S ：一般档案是异步写入磁盘的(原理请参考第五章sync的说明)，如果加上 S 这个 属性时，当你进行任何档案的修改，该更动会『同步』写入磁盘中。 
						a ：当设定 a 之后，这个档案将只能增加数据，而不能删除也不能修改数据，只有root 才能设定这个属性。 
						c ：这个属性设定之后，将会自动的将此档案『压缩』，在读取的时候将会自动解压缩， 但是在储存的时候，将会先进行压缩后再储存(看来对于大档案似乎蛮有用的！)
						d ：当dump 程序被执行的时候，设定 d 属性将可使该档案(或目录)不会被 dump 备份 
						i ：这个 i 可就很厉害了！他可以让一个档案『不能被删除、改名、设定连结也无法 写入或新增资料！』对于系统安全性有相当大的帮助！只有 root 能设定此属性 
						s ：当档案设定了 s 属性时，如果这个档案被删除，他将会被完全的移除出这个硬盘 空间，所以如果误删了，完全无法救回来了喔！ 
						u ：与 s 相反的，当使用 u 来配置文件案时，如果该档案被删除了，则数据内容其实还 存在磁盘中，可以使用来救援该档案喔！ 
						注意：属性设定常见的是 a 与 i 的设定值，而且很多设定值必须要身为 root 才能设定
			lsattr (显示档案隐藏属性)
				lsattr [-adR] 档案或目录 
					选项与参数： 
						-a ：将隐藏文件的属性也秀出来； 
						-d ：如果接的是目录，仅列出目录本身的属性而非目录内的文件名； 
						-R ：连同子目录得数据也一并列出来！
		档案特殊权限： SUID, SGID, SBIT
			Set UID
				当 s 这个标志出现在档案拥有者的 x 权限上时，例如刚刚提到的 /usr/bin/passwd 这个档案的权限状态：『-rwsr-xr-x』，此时就被称为 Set UID，简称为 SUID 的特殊权限。 那么SUID德权限对于一个档案德特殊功能是什么呢？基本上SUID有这样的限制与功能：
					SUID 权限仅对二进制程序(binary program)有效；
					执行者对于该程序需要具有 x 的可执行权限；
					本权限仅在执行该程序的过程中有效 (run-time)；
					执行者将具有该程序拥有者 (owner) 的权限。
				Linux 系统中，所有账号的密码都记录在 /etc/shadow 这个档案里面，这个档案的权限为：『-r-------- 1 root root』，意思是这个档案仅有root可读且仅有root可以强制写入而已。
				既然这个档案仅有 root 可以修改，那么鸟哥的 vbird 这个一般账号使用者能否自行修改自己的密码呢？ 你可以使用你自己癿账号输入『passwd』这个指令来看看，嘿嘿！一般用户当然可以修改自己的密码了！ 唔！有没有冲突啊！明明 /etc/shadow 就不能让 vbird 这个一般账户去存取的，为什么 vbird 还能够修改这个档案内的密码呢？ 这就是 SUID 的功能啦！藉由上述的功能说明，我们可以知道
					1. vbird 对于 /usr/bin/passwd 这个程序来说是具有 x 权限的，表示 vbird 能执行 passwd；
					2. passwd 的拥有者是 root 这个账号；
					3. vbird 执行 passwd 的过程中，会『暂时』获得 root 的权限；
					4. /etc/shadow 就可以被 vbird 所执行的 passwd 所修改。
				但如果 vbird 使用 cat 去读取 /etc/shadow 时，他能够读取吗？因为 cat 不具有 SUID 的权限，所以 vbird 执行 『cat /etc/shadow』 时，是不能读取 /etc/shadow 的。
				另外，SUID 仅可用在binary program 上， 不能够用在 shell script 上面！这是因为 shell script 只是将很多的 binary 执行档叫进来执行而已！所以 SUID 的权限部分，还是得要看 shell script 呼叫进来的程序的设定， 而不是 shell script 本身。当然，SUID 对于目录也是无效的～这点要特别留意。
			Set GID
				当 s 标志在档案拥有者的 x 项目为 SUID，那 s 在群组的 x 时则称为 Set GID, SGID 啰！
				与 SUID 不同的是，SGID 可以针对档案或目录来设定！
					如果是对档案来说， SGID 有如下的功能：
						SGID 对二进制程序有用；
						程序执行者对于该程序来说，需具备 x 的权限；
						执行者在执行的过程中将会获得该程序群组的支持！
					除了 binary program 之外，事实上 SGID 也能够用在目录上，这也是非常常见的一种用途！ 当一个目录设定了 SGID 的权限后，他将具有如下的功能：
						用户若对于此目录具有 r 与 x 的权限时，该用户能够进入此目录；
						用户在此目录下的有效群组(effective group)将会变成该目录的群组；
						用途：若用户在此目录下具有 w 的权限(可以新建档案)，则使用者所建立的新档案，该新档案的群组与此目录的群组相同。
			Sticky Bit
				这个 Sticky Bit, SBIT 目前只针对目录有效，对于档案已经没有效果了。 SBIT 对于目录的作用是：
					当用户对于此目录具有 w, x 权限，亦即具有写入的权限时；
					当用户在该目录下建立档案或目录时，仅有自己与 root 才有权力删除该档案
				举例杢说，我们的 /tmp 本身的权限是『drwxrwxrwt』， 在这样的权限内容下，任何人都可以在 /tmp 内新增、修改档案，但仅有该档案/目录建立者与 root 能够删除自己的目录或档案。
			SUID/SGID/SBIT 权限设定
				数字型态更改权限的方式为『三个数字』的组合， 那么如果在这三个数字之前再加上一个数字的话，最前面的那个数字就代表这几个权限了！4 为 SUID，2 为 SGID，1 为 SBIT。假设要将一个档案权限改为『-rwsr-xr-x』时，由于 s 在用户权力中，所以是 SUID ，因此， 在原先的 755 之前还要加上 4 ，也就是：『 chmod 4755 filename 』来设定！
				注意：SUID 不是用在目录上，而 SBIT 不是用在档案上的喔！
				chmod 7666 test; ls -l test <==具有空的 SUID/SGID 权限 
				-rwSrwSrwT 1 root root 0 Sep 29 03:06 test
				怎么会出现大写的 S 与 T 呢？不都是小写的吗？ 因为 s 与 t 都是取代 x 这个权限的，但是你有没有发现阿，我们是下达 7666 喔！也就是说， user, group 以及 others 都没有 x 这个可执行的标志( 因为 666 嘛 )，所以，这个 S, T 代表的就是『空的』啦！怎么说？ SUID 是表示『该档案在执行的时候，具有档案拥有者的权限』，但是档案 拥有者都无法执行了，哪里来的权限给其他人使用？当然就是空的啦！
				而除了数字法之外，妳也可以透过符号法来处理喔！其中 SUID 为 u+s ，而 SGID 为 g+s ，SBIT 则是 o+t
			观察文件类型：file
				如果你想要知道某个档案的基本数据，例如是属亍 ASCII 或者是 data 档案，或者是 binary ， 且其中有没有使用到动态函式库 (share library) 等等的信息，就可以利用 file 这个指令来检阅喔！ 
				举例来说： 
					[root@www ~]# file ~/.bashrc 
					/root/.bashrc: ASCII text <==告诉我们是 ASCII 癿纯文本档啊！ 
					[root@www ~]# file /usr/bin/passwd 
					/usr/bin/passwd: setuid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), for GNU/Linux 2.6.9, dynamically linked (uses shared libs), for GNU/Linux 2.6.9, stripped # 执行文件癿数据可就多的不得了！包括这个档案的 suid 权限、兼容于 Intel 386 # 等级的硬件平台、使用的是 Linux 核心 2.6.9 癿动态函式库链接等等。 
					[root@www ~]# file /var/lib/mlocate/mlocate.db 
					/var/lib/mlocate/mlocate.db: data <== 这是 data 档案！
				透过这个指令，我们可以简单的先判断这个档案的格式为何喔！
	指令与档案的搜寻
		脚本文件名的搜寻
			which (寻找『执行档』)
				which [-a] command 选项或参数： 
					-a ：将所有由 PATH 目录中可以找到的指令均列出，而不止第一个被找到的指令名称
				which cd 
				/usr/bin/which: no cd in
				怎么 cd 这个常用的指令竟然找不到啊！为什么呢？这是因为 cd 是『bash 内建的指令』啦！ 但是 which 预设是找 PATH 内所规范的目录弽，所以当然一定找不到的啊！那怎办？没关系！我们可以透过 type 这个指令喔！
		档案档名的搜寻
			通常 find 不很常用的！因为速度慢之外， 也很操硬盘！通常我们都是先使用 whereis 或者是 locate 来检查，如果真的找不到了，才以 find 来搜寻呦！ 为什么呢？因为 whereis 与 locate 是利用数据库来搜寻数据，所以相当的快速，而且并没有实际的搜寻硬盘， 比较省时间啦！
			whereis	
				whereis (寻找特定档案)
					whereis [-bmsu] 档案或目录名 
					选项与参数： 
						-b :只找 binary 格式的档案 
						-m :只找在说明文件 manual 路径下的档案 
						-s :只找 source 来源档案 
						-u :搜寻不在上述三个项目当中的其他特殊档案
					例如，一般用户使用which找不到的 ifconfig 却可以让 whereis 找到！这是因为系统真的有 ifconfig 这个『档案』，但是使用者的 PATH 并没有加入 /sbin 所以，未来你找不到某些指令时，先用档案搜寻指令找找看再说！
					因为 Linux 系统会将系统内的所有档案都记录在一个数据库档案里面， 而当使用 whereis 或者是底下要说的 locate 时，都会以此数据库档案的内容为准， 因此，有的时侯你还会发现使用这两个执行档时，会找到已经被杀掉的档案！ 而且也找不到最新的刚刚建立的档案呢！这就是因为这两个指令是由数据库当中的结果去搜寻档案的所在啊！
			locate	
				locate [-ir] keyword 
				选项与参数： 
					-i ：忽略大小写的差异； 
					-r ：后面可接正规表示法的显示方式
				这个 locate 的使用更简单，直接在后面输入『档案的部分名称』后，就能够得到结果。
				locate 寻找的数据是由『已建立的数据库 /var/lib/mlocate/』 里面的数据所搜寻到的，而数据库的建立默认是在每天执行一次 (每个 distribution 都不同，CentOS 5.x 是每天更新数据库一次！)，所以当你新建立起来的档案， 即还在数据库更新之前搜寻该档案，那么 locate 会告诉你『找不到！』
				那能否手动更新数据库哪？当然可以啊！更新 locate 数据库的方法非常简单，直接输入『 updatedb 』就可以了！ updatedb 指令会去读取 /etc/updatedb.conf 这个配置文件的设定，然后再去硬盘里面进行搜寻文件名的动作， 最后就更新整个数据库档案啰！因为 updatedb 会去搜寻硬盘，所以当你执行 updatedb 时，可能会等待数分钟的时间喔！
					updatedb：根据 /etc/updatedb.conf 的设定去搜寻系统硬盘内的文件名，并更新 /var/lib/mlocate 内的数据库档案；
					locate：依据 /var/lib/mlocate 内的数据库记载，找出用户输入的关键词文件名。
			find
				find [PATH] [option] [action] 
				选项与参数： 
					1. 与时间有关的选项：共有 -atime, -ctime 与 -mtime ，以 -mtime 说明 
							-mtime n ：n 为数字，意义为在 n 天之前的『一天之内』被更动过内容的档案； 
							-mtime +n ：列出在 n 天之前(不含 n 天本身)被更动过内容的档案档名； 
							-mtime -n ：列出在 n 天之内(含 n 天本身)被更动过内容的档案档名。 
							-newer file ：file 为一个存在的档案，列出比 file 还要新的档案档名
						例如：
							find / -mtime 0 
							# 那个 0 是重点！0 代表目前的时间，所以，从现在开始到 24 小时前， 有变动过内容的档案都会被列出来。
								+4代表大于等于5天前的檔名
								-4代表小于等于4天内的档案档名
								4则是代表4-5那一天的档案档名
					2. 与使用者或组名有关的参数： 
						-uid n ：n 为数字，这个数字是用户的账号 ID，亦即 UID ，这个 UID 是记录在 /etc/passwd 里面与账号名称对应的数字。
						-gid n ：n 为数字，这个数字是组名的 ID，亦即 GID，这个 GID 记录在 /etc/group。 
						-user name ：name 为使用者账号名称喔！
						-group name：name 为组名喔。 
						-nouser ：寻找档案的拥有者不存在于 /etc/passwd 的人！ 
						-nogroup ：寻找档案的拥有群组不存在于 /etc/group 的档案！ 
						当你自行安装软件时，很可能该软件的属性当中并没有档案拥有者， 这是可能的！在这个时候，就可以使用 -nouser 与 -nogroup 搜寻。
						或者如果你将系统里面某个账号删除了，但是该账号已经在系统内建立很多档案时，就可能会发生无主孤魂的档案存在！
					3. 与档案权限及名称有关的参数： 
						-name filename：搜寻文件名为 filename 的档案； 
						-size [+-]SIZE：搜寻比 SIZE 还要大(+)或小(-)癿档案。这个 SIZE 的规格有： c: 代表 byte， k: 代表 1024bytes。所以，要找比 50KB 还要大的档案，就是『 -size +50k 』 
						-type TYPE ：搜寻档案的类型为 TYPE 的，类型主要有：一般正规档案 (f), 装置档案 (b, c), 目录 (d), 连结档 (l), socket (s), 及 FIFO (p) 等属性。 
						-perm mode ：搜寻档案权限『刚好等于』 mode 的档案，这个 mode 为类似 chmod 的属性值，举例来说， -rwsr-xr-x 的属性为 4755 ！ 
						-perm -mode ：搜寻档案权限『必须要全部囊括 mode 的权限』的档案，举例来说， 我们要搜寻 -rwxr--r-- ，亦即 0744 的档案，使用 -perm -0744， 当一个档案的权限为 -rwsr-xr-x ，亦即 4755 时，也会被列出来， 因为 -rwsr-xr-x 癿属性已经囊括了 -rwxr--r-- 的属性了。 
						-perm +mode ：搜寻档案权限『包含任一 mode 的权限』的档案，举例来说，我们搜寻 -rwxr-xr-x ，亦即 -perm +755 时，但一个文件属性为 -rw------- 也会被列出来，因为他有 -rw.... 的属性存在！
						范例七：搜寻档案当中含有 SGID 或 SUID 或 SBIT 的属性 
							[root@www ~]# find / -perm +7000 # 所谓的 7000 就是 ---s--s--t ，那么只要含有 s 或 t 的就列出， # 所以当然要使用 +7000 ，使用 -7000 表示要含有 ---s--s--t 的所有三个权限
					4. 额外可进行的动作： 
						-exec command ：command 为其他指令，-exec 后面可再接额外的指令来处理搜寻到的结果。指令不支持命令别名。 如-print ：将结果打印到屏幕上，这个动作是预设动作！
						范例八：将上个范例找到的档案使用 ls -l 列出来～
							find / -perm +7000 -exec ls -l {} \;
							该范例中特殊的地方有 {} 以及 \; 还有 -exec 这个关键词，这些东西的意义为：
								{} 代表的是『由 find 找到的内容』，如上图所示，find 的结果会被放置到 {} 位置中；
								-exec 一直到 \; 是关键词，代表 find 额外动作的开始 (-exec) 到结束 (\;) ，在这中间的就是 find 指令内的额外动作。 在本例中就是『 ls -l {} 』啰！
								因为『 ; 』在 bash 环境下是有特殊意义的，因此利用反斜杠来跳脱。
				find 还可以利用通配符来找寻档名呢！举例来说，你想要找出 /etc 底下檔名包含 httpd 的档案， 那么你就可以这样做：find /etc -name '*httpd*'
	极重要！权限与指令间的关系：	
		说明一下什么指令在什么样的权限下才能够运作吧：
			一、让用户能进入某目录成为『可工作目录』的基本权限为何：
				可使用的指令：例如 cd 等变换工作目录的指令；
				目录所需权限：用户对这个目录至少需要具有 x 的权限
				额外需求：如果用户想要在这个目录内利用 ls 查阅文件名，则用户对此目录还需要 r 的权限。
			二、用户在某个目录内读取一个档案的基本权限为何？
				可使用的指令：例如本章谈到的 cat, more, less等等
				目录所需权限：用户对这个目录至少需要具有 x 权限；
				档案所需权限：使用者对档案至少需要具有 r 的权限才行！
			三、让使用者可以修改一个档案的基本权限为何？
				可使用的指令：例如 nano 或未来要介绍的 vi 编辑器等；
				目录所需权限：用户在该档案所在的目录至少要有 x 权限；
				档案所需权限：使用者对该档案至少要有 r, w 权限
			四、让一个使用者可以建立一个档案的基本权限为何？
				目录所需权限：用户在该目录要具有 w,x 的权限，重点在 w 啦！
			五、让用户进入某目录并执行该目录下的某个指令之基本权限为何？
				目录所需权限：用户在该目录至少要有 x 的权限；
				档案所需权限：使用者在该档案至少需要有 x 的权限
		例如：
			让一个使用者 vbird 能够进行『cp /dir1/file1 /dir2』的指令时，请说明 dir1, file1, dir2 的最小所需权限为何？	
				dir1 ：至少需要有 x 权限；
				file1：至少需要有 r 权限；
				dir2 ：至少需要有 w, x 权限。
			因为目录结构是由根目录一层一层读取的，所以用户必须具有目录层次中每一层的权限。
	touch 的目的在修改档案的时间参数，但亦可用来建立空档案；	
	除了传统的rwx权限之外，在Ext2/Ext3文件系统中，还可以使用chattr与lsattr设定及观察隐藏属性。 常见的包括只能新增数据的 +a 与完全不能更动档案的 +i 属性。	
	id username查阅user帐号的属性。
		如：id alex	
		uid=501(alex) gid=502(alex) groups=502(alex),501(project)
	找出 /etc 底下，档案容量大于 50K 且档案所属人不是 root 的档名，且将权限完整的列出 (ls -l)；
		find /etc -size +50k -a ! -user root -exec ls -ld {} \; 
		find /etc -size +50k -a ! -user root -type f -exec ls -l {} \; 
		上面两式均可！注意到 ! ，那个 ! 代表的是反向选择，亦即『不是后面的项目』之意！
		注意到 -a ，那个 -a 是 and 的意思，为符合两者才算成功
	找出 /etc 底下，容量大于 1500K 以及容量等亍 0 的档案：
		find /etc -size +1500k -o -size 0 相对于 -a ，那个 -o 就是或 (or) 的意思啰！	
	


第八章、Linux 磁盘与文件系统管理	
	认识 EXT2 文件系统
		因为分割表仅有64bytes而已， 因此最多只能记录四笔分割槽的记录，这四笔记录我们称为主要 (primary) 或延伸 (extended) 分割槽，延伸分割槽用来存储逻辑分割槽的分割表信息. 其中延伸分割槽还可以再分割出逻辑分割槽 (logical) ， 而能被格式化的则仅有主要分割与逡辑分割而已。
		文件系统特性
			操作系统的档案数据除了档案实际内容外， 通常含有非常多的属性，例如 Linux 操作系统的档案权限(rwx)与文件属性(所有者、群组、时间参数等)。 文件系统通常会将这两部分的数据分别存放在不同的区块，权限与属性放置到 inode 中，至于实际数据则放置到 data block 区块中。 另外，还有一个超级区块 (superblock) 会记录整个文件系统的整体信息，包括 inode 与 block 的总量、使用量、剩余量等。
			每个 inode 与 block 都有编号，至于这三个数据的意义可以简略说明如下：
				superblock：记录此 filesystem 的整体信息，包括inode/block的总量、使用量、剩余量， 以及文件系统的格式与相关信息等；
				inode：记录档案的属性，一个档案占用一个inode，同时记录此档案的数据所在的 block 号码；
				block：实际记录档案的内容，若档案太大时，会占用多个 block 。
			这种使用inode和block结合读取文件内容的文件系统称为索引式文件系统.当要读取文件内容时,先从inode中读取所有的block信息,再同时去读所有的block. 相对于FAT系统,因为没有inode,所以无法知道所有的block信息,只能顺序读取block,根据前一个block中记录的下一个block的位置去读取下一个block的内容.慢是因为:1. 不能同时读block的内容. 2. 如果block过于分散,则要频繁移动读取头.
			文件系统一开始就将 inode 与 block 规划好了，除非重新格式化(或者利用 resize2fs 等指令变更文件系统大小)，否则 inode 与 block 固定后就不再变动。但是如果仔细考虑一下，如果我的文件系统高达数百GB时， 那么将所有的 inode 与 block 通通放置在一起将是很不智的决定，因为 inode 与 block 的数量太庞大，不容易管理。，因此 Ext2 文件系统在格式化的时候基本上是区分为多个区块群组 (block group) 的，每个区块群组都有独立的 inode/block/superblock 系统。在整体的规划当中，文件系统最前面有一个启动扇区(boot sector)，这个启动扇区可以安装开机管理程序
			每一个区块群组(block group)包含6个部分,说明如下:
				data block (资料区块)
					data block 是用来放置档案内容数据地方，在 Ext2 文件系统中所支持的 block 大小有 1K, 2K 及 4K 三种而已。在格式化时 block 的大小就固定了，且每个 block 都有编号，以方便 inode 的记录啦。 不过要注意的是，由于 block 大小的差异，会寻致该文件系统能够支持的最大磁盘容量与最大单一档案容量并不相同。
					原则上，block 的大小与数量在格式化完就不能够再改发了(除非重新格式化)；
					每个 block 内最多只能够放置一个档案的数据；
					承上，如果档案大于 block 的大小，则一个档案会占用多个 block 数量；
					承上，若档案小于 block ，则该 block 的剩余容量就不能够再被使用了(磁盘空间会浪费)。
					既然大的 block 可能会产生较严重的磁盘容量浪费，那么我们是否就将 block 大小订为 1K 即可？ 这也不妥，因为如果 block 较小的话，那么大型档案将会占用数量更多的 block ，而 inode 也要记录更多的 block 号码，此时将可能导致文件系统不良的读写效能。
				inode table (inode 表格)
					inode 记录的档案数据至少有底下这些：(注4)
						该档案的存取模式(read/write/excute)；
						该档案的所有者与群组(owner/group)；
						该档案的容量；
						该档案建立或状态改变的时间(ctime)；
						最近一次的读取时间(atime)；
						最近修改的时间(mtime)；
						定义档案特性的旗标(flag)，如 SetUID...；
						该档案真正内容的指向 (pointer)；
					，除此之外 inode 还有些什么特色呢？
						每个 inode 大小均固定为 128 bytes；
						每个档案都仅会占用一个 inode 而已；
						承上，因此文件系统能够建立的档案数量与 inode 的数量有关；
						系统读取档案时需要先找到 inode，并分析 inode 所记录的权限与用户是否符合，若符合才能够开始实际读取 block 的内容。
					inode / block 与档案大小的关系：inode 要记录的数据非常多，但偏偏又只有 128bytes 而已， 而 inode 记录一个 block 号码要花掉 4byte ，假设我一个档案有 400MB 且每个 block 为 4K 时， 那么至少也要十万笔 block 号码的记录呢！inode 哪有这么多可记录的信息？为此我们的系统很聪明的将 inode 记录 block 号码的区域定义为12个直接，一个间接, 一个双间接与一个三间接记录区。
					所谓的间接就是再拿一个 block 来当作记录 block 号码的记录区，如果档案太大时， 就会使用间接的 block 来记录编号。
					此时我们知道当文件系统将 block 格式化为 1K 大小时，能够容纳的最大档案为 16GB，比较一下文件系统限制表的结果可发现是一致的！但这个方法不能用在 2K 及 4K block 大小的计算中， 因为大于 2K 的 block 将会受到 Ext2 文件系统本身的限制，所以计算的结果会不太符合之故。
				Superblock (超级区块)	
					Superblock 是记录整个 filesystem 相关信息的地方， 没有 Superblock ，就没有这个 filesystem 了。一般来说， superblock 的大小为 1024bytes。他记录的信息主要有：
						block 与 inode 的总量；
						未使用与已使用的 inode / block 数量；
						block 与 inode 的大小 (block 为 1, 2, 4K，inode 为 128 bytes)；
						filesystem 的挂载时间、最近一次写入数据的时间、最近一次检验磁盘 (fsck) 的时间等文件系统的相关信息；
						一个 valid bit 数值，若此文件系统已被挂载，则 valid bit 为 0 ，若未被挂载，则 valid bit 为 1 。
					每个 block group 都可能含有 superblock 喔！但是我们也说一个文件系统应该仅有一个 superblock 而已，那是怎么回事啊？ 事实上除了第一个 block group 内会含有 superblock 之外，后续的 block group 不一定含有 superblock ， 而若含有 superblock 则该 superblock 主要是做为第一个 block group 内 superblock 的备份咯，这样可以进行 superblock 的救援呢！
				Filesystem Description (文件系统描述说明)
					这个区段可以描述每个 block group 的开始与结束的 block 号码，以及说明每个区段 (superblock, bitmap, inodemap, data block) 分别介于哪一个 block 号码之间。这部件也能够用 dumpe2fs 来观察的。
				block bitmap (区块对照表)
					从 block bitmap 当中可以知道哪些 block 是空的，如果你删除某些档案时，那么那些档案原本占用的 block 号码就得要释放出来， 此时在 block bitmpap 当中相对应到该 block 号码的标志就得要修改成为『未使用中』啰！
				inode bitmap (inode 对照表)
					inode bitmap 则是记录使用与未使用的 inode 号码
			dumpe2fs [-bh] 装置文件名 
				选项与参数： 
					-b ：列出保留为坏轨的部分(一般用不到吧！？) 
					-h ：仅列出 superblock 的数据，不会列出其他的区段内容！
			df这个指令可以叫出目前挂载的装置
			dumpe2fs /dev/hdc2 察看hdc2分区的文件系统信息。
			利用 dumpe2fs 可以查询到非常多的信息，不过依内容主要可以区分为上半部是 superblock 内容， 下半部则是每个 block group 的信息了。
			block group 的内容我们单纯看 Group0 信息好了。从上表中我们可以发现：
				Group0 所占用的 block 号码由 0 到 32767 号，superblock 则在第 0 号的 block 区块内！
				文件系统描述说明在第 1 号 block 中；
				block bitmap 与 inode bitmap 则在 627 及 628 的 block 号码上。
				至于 inode table 分布于 629-1641 的 block 号码中！
				由于 (1)一个 inode 占用 128 bytes ，(2)总共有 1641 - 629 + 1(629本身) = 1013 个 block 花在 inode table 上， (3)每个 block 的大小为 4096 bytes(4K)。由这些数据可以算出 inode 的数量共有 1013 * 4096 / 128 = 32416 个 inode 啦！
				这个 Group0 目前没有可用的 block 了，但是有剩余 32405 个 inode 未被使用；
				剩余的 inode 号码为 12 号到 32416 号。
		与目录树的关系
			在 Linux 系统下，每个档案(不管是一般档案还是目录档案)都会占用一个 inode ， 且可依据档案内容的大小来分配多个 block 给该档案使用。
			目录的内容在记录文件名， 一般档案才是实际记录数据内容的地方。
			目录:
				当我们在 Linux 下的 ext2 文件系统建立一个目录时， ext2 会分配一个 inode 与至少一块 block 给该目录。其中，inode 记录该目录癿相关权限与属性，并可记录分配到的那块 block 号码； 而 block 则是记录在这个目录下的文件名与该文件名占用的 inode 号码数据。
				ls -i列出档案对应的inode号码
				用ls -ll列出的文件大小都是1024的倍数,这与block的大小有关,如果分配一个block,则为1024,如果分配四个block,则为4096.
			档案:
				当我们在 Linux 下的 ext2 建立一个一般档案时， ext2 会分配一个 inode 与相对于该档案大小的 block 数量给该档案。
				但同时请注意，由于 inode 仅有 12 个直接指向，因此还要多一个 block 来作为区块号码的记录喔！
			目录树读取:
				好了，经过上面的说明你也应该要很清楚的知道 inode 本身并不记录文件名，文件名的记录是在目录的 block 当中。 因此在第六章档案与目录的权限说明中， 我们才会提到『新增/删除/更名文件名与目录的 w 权限有关』的特色！那么因为文件名是记录在目录的 block 当中， 因此当我们要读取某个档案时，就务必会经过目录的 inode 与 block ，然后才能够找到那个待读取档案的 inode 号码， 最终才会读到正确的档案的 block 内的数据。 由于目录树是由根目录开始读起，因此系统透过挂载的信息可以找到挂载点的 inode 号码(通常一个 filesystem 的最顶层 inode 号码会由 2 号开始喔！)，此时就能够得到根目录的 inode 内容，并依据该 inode 读取根目录的 block 内的文件名数据，再一层一层的往下读到正确的档名。
			filesystem 大小与磁盘读取效能：	
				partition 的规划并不是越大越 好， 而是真的要针对您的主机用途来进行规划才行！
		EXT2/EXT3 档案的存取与日志式文件系统的功能	
			假设我们想要新增一个档案，此时文件系统的行为是：
				1. 先确定用户对于欲新增档案的目录是否具有 w 与 x 的权限，若有的话才能新增；
				2. 根据 inode bitmap 找到没有使用的 inode 号码，并将新档案的权限/属性写入；
				3. 根据 block bitmap 找到没有使用中的 block 号码，并将实际的数据写入 block 中，且更新 inode 的 block 指向数据；
				4. 将刚刚写入的 inode 与 block 数据同步更新 inode bitmap 与 block bitmap，并更新 superblock 的内容。
			日志式文件系统 (Journaling filesystem)
				为了避免上述提到的文件系统不一致的情况发生，因此我们的前辈们想到一个方式， 如果在我们的 filesystem 当中规划出一个区块，该区块专门在记录写入或修订档案时的步骤， 那不就可以简化一致性检查的步骤了？也就是说：
					1. 预备：当系统要写入一个档案时，会先在日志记录区块中记录某个档案准备要写入的信息；
					2. 实际写入：开始写入档案的权限与数据；开始更新 metadata 的数据；
					3. 结束：完成数据与 metadata 的更新后，在日志记录区块当中完成该档案的记录。
				在这样的程序当中，万一数据的记录过程当中发生了问题，那么我们的系统只要去检查日志记录区块， 就可以知道那个档案发生了问题，针对该问题来做一致性的检查即可，而不必针对整块 filesystem 去检查， 这样就可以达到快速修复 filesystem 的能力了！这就是日志式档案最基础的功能啰～
				dumpe2fs 输出的讯息，可以发现 superblock 里面含有底下这样的信息：
					Journal inode: 8 
					Journal backup: inode blocks 
					Journal size: 128M
				『为什么你想要从ext2转换到ext3呢？有四个主要的理由：可利用性、数据完整性、速度及易于转换』 『可利用性』，他指出，这意味着从系统中止到快速重新复原而不是持续的让e2fsck执行长时间的修复。ext3 的日志式条件可以避克数据毁损的可能。他也指出： 『除了写入若干数据超过一次时，ext3往往会较快于ext2，因为ext3的日志使硬盘读取头的移动能更有效的进行』 然而或许决定的因素还是在Johnson先生的第四个理由中。 『它是可以轻易的从ext2变更到ext3来获得一个强而有力的日志式文件系统而不需要重新做格式化』。『那是正确的，为了体验一下 ext3 的好处是不需要去做一种长时间的，冗长乏味的且易于产生错误的备份工作及重新格式化的动作』。
			Linux 文件系统的运作：	
				当系统加载一个档案到内存后，如果该档案没有被更动过，则在内存区段的档案数据会被设定为干净(clean)的。 但如果内存中的档案数据被更改过了(例如你用 nano 去编辑过这个档案)，此时该内存中的数据会被设定为脏的 (Dirty)。此时所有的动作都还在内存中执行，并没有写入到磁盘中！ 系统会不定时的将内存中设定为『Dirty』的数据写回磁盘，以保持磁盘与内存数据的一致性。 你也可以利用第五章谈到的 sync指令来手动强迫写入磁盘。
				Linux 系统上面文件系统与内存有非常大的关系喔： 
					系统会将常用的档案数据放置到主存储器的缓冲区，以加速文件系统的读/写；
					承上，因此 Linux 的物理内存最后都会被用光！这是正常的情况！可加速系统效能；
					你可以手动使用 sync 来强迫内存中设定为 Dirty 的档案回写到磁盘中；
					若正常关机时，关机指令会主动呼叫 sync 来将内存的数据回写入磁盘内；
					但若不正常关机(如跳电、当机或其他不明原因)，由于数据尚未回写到磁盘内， 因此重新启动后可能会花很多时间在进行磁盘检验，甚至可能导致文件系统的损毁(非磁盘损毁)。
			挂载点的意义 (mount point):
				每个 filesystem 都有独立的 inode / block / superblock 等信息，这个文件系统要能够链接到目录树才能被我们使用。 将文件系统与目录树结合的动作我们称为『挂载』。
				重点是：挂载点一定是目录，该目录为进入该文件系统的入口。 因此并不是你有任何文件系统都能使用，必须要『挂载』到目录树的某个目录后，才能够使用该文件系统的。
				可以透过判断 inode 号码来确认不同文件名是否为相同的档案
			其他 Linux 支持的文件系统与 VFS
				想要知道你的 Linux 支持的文件系统有哪些，可以察看底下这个目录：
					ls -l /lib/modules/$(uname -r)/kernel/fs
				系统目前已加载到内存中支持的文件系统则有：
					cat /proc/filesystems
				Linux VFS (Virtual Filesystem Switch)
					了解了我们使用的文件系统之后，再来则是要提到，那么 Linux 的核心又是如何管理这些认识的文件系统呢？ 其实，整个 Linux 的系统都是透过一个名为 Virtual Filesystem Switch 的核心功能去读取 filesystem 的。 也就是说，整个 Linux 认识的 filesystem 其实都是 VFS 在进行管理，我们使用者并不需要知道每个 partition 上头的 filesystem 是什么～ VFS 会主动的帮我们做好读取的动作呢～
	文件系统的简单操作
		磁盘与目录的容量
			df
				df [-ahikHTm] [目录或文件名] 
				选项与参数： 
					-a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统； 
					-k ：以 KBytes 的容量显示各文件系统； 
					-m ：以 MBytes 的容量显示各文件系统； 
					-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示； 
					-H ：以 M=1000K 取代 M=1024K 的进位方式； 
					-T ：连同该 partition 的 filesystem 名称 (例如 ext3) 也列出； 
					-i ：不用硬盘容量，而以 inode 的数量来显示
				在 df 后面加上目录或者是档案时， df会自动的分析该目录或档案所在的 partition ，并将该 partition 的容量显示出来， 所以，您就可以知道某个目录底下还有多少容量可以使用了！
				另外需要注意的是，如果使用 -a 这个参数时，系统会出现 /proc 这个挂载点，但是里面的东西都是 0 ，不要紧张！ /proc 癿东西都是 Linux 系统所需要加载的系统数据，而且是挂载在『内存当中』的， 所以当然没有占任何的硬盘空间啰！ 
				至于那个 /dev/shm/ 目录，其实是利用内存虚拟出来的磁盘空间！ 由于是透过内存仿真出来的磁盘，因此你在这个目录底下建立任何数据文件时，访问速度是非常快速的！(在内存内工作) 不过，也由于他是内存仿真出来的，因此这个文件系统的大小在每部主机上都不一样，而且建立的东西在下次开机时就消失了！ 因为是在内存中嘛！
			du
				du [-ahskm] 档案或目录名称 
				选项与参数： 
					-a ：列出所有的档案与目录容量，因为默认仅统计目录底下的档案量而已。 
					-h ：以人们较易读的容量格式 (G/M) 显示； 
					-s ：列出总量而已，而不列出每个各别的目录占用容量； 
					-S ：不包括子目录下的总计，与 -s 有点差别。 
					-k ：以 KBytes 列出容量显示； 
					-m ：以 MBytes 列出容量显示；
				直接输入 du 没有加任何选项时，则 du 会分析『目前所在目录』的档案与目录所占用的硬盘空间。但是，实际显示时，仅会显示目录容量(不含档案)， 因此 . 目录有很多档案没有被列出来，所以全部的目录相加不会等与 . 的容量喔！
				与 df 不一样的是，du 这个指令其实会直接到文件系统内去搜寻所有的档案数据
				至于 -S 这个选项部分，由于 du 默认会将所有档案的大小均列出，因此假设你在 /etc 底下使用 du 时， 所有的档案大小，包括 /etc 底下的次目录容量也会被计算一次。然后最终的容量 (/etc) 也会加总一次， 因此很多朋友都会误会 du 分析的结果不太对劲。所以啰，如果想要列出某目录下的全部数据， 或许也可以加上 -S 的选项，减少次目录的加总喔！
		实体链接与符号链接： ln
			Hard Link (实体链接, 硬式连结或实际连结)
				hard link 只是在某个目录下新增一笔档名链接到某 inode 号码的关连记录而已。
				一般来说，使用 hard link 设定链接文件时，磁盘的空间与 inode 的数目都不会改发！ hard link 只是在某个目录下的 block 多写入一个关连数据而已，既不会增加 inode 也不会耗用 block 数量哩！
				hard link 是有限制的：
					不能跨 Filesystem；
					不能 link 目录。
				不能跨 Filesystem 还好理解，那不能 hard link 到目录又是怎么回事呢？这是因为如果使用 hard link 链接到目录时， 链接的数据需要连同被链接目录底下的所有数据都建立链接，举例来说，如果你要将 /etc 使用实体链接建立一个 /etc_hd 的目录时，那么在 /etc_hd 底下的所有档名同时都与 /etc 底下的檔名要建立 hard link 的，而不是仅连结到 /etc_hd 与 /etc 而已。 并且，未来如果需要在 /etc_hd 底下建立新档案时，连带的， /etc 底下的数据又得要建立一次 hard link ，因此造成环境相当大的复杂度。 所以啰，目前 hard link 对于目录暂时还是不支持的啊！
			Symbolic Link (符号链接，亦即是快捷方式)
				Symbolic link 就是在建立一个独立的癿档案，而这个档案会让数据的读取指向他 link 的那个档案的档名！
			ln [-sf] 来源文件 目标文件 
			选项与参数： 
				-s ：如果不加任何参数就进行连结，那就是hard link，至于 -s 就是symbolic link 
				-f ：如果 目标文件 存在时，就主动的将目标文件直接移除后再建立！
			关于目录的 link 数量：
				一个『空目录』里面至少会存在些什么？呵呵！就是存在 . 与 .. 这两个目录啊！ 那么，当我们建立一个新目录名称为 /tmp/testing 时，基本上会有三个东西，那就是：/tmp/testing，/tmp/testing/.，/tmp/testing/..，而其中 /tmp/testing 与 /tmp/testing/. 其实是一样的！都代表该目录啊～而 /tmp/testing/.. 则代表 /tmp 这个目录，所以说，当我们建立一个新的目录时， 『新的目录的 link 数为 2 ，而上层目录的 link 数则会增加 1 』
	磁盘的分割、格式化、检验与挂载：			
		如果我们想要在系统里面新增一颗硬盘时，应该有哪些动作需要做的呢：
			1. 对磁盘进行分割，以建立可用的 partition ；
			2. 对该 partition 进行格式化( format )，以建立系统可用的 filesystem；
			3. 若想要仔细一点，则可对刚刚建立好的 filesystem 进行检验；
			4. 在 Linux 系统上，需要建立挂载点 ( 亦即是目彔 )，并将他挂载上来；
			当然啰，在上述的过程当中，还有很多需要考虑的，例如磁盘分区槽 (partition) 需要定多大？ 是否需要加入 journal 的功能？inode 与 block 的数量应该如何规划等等的问题。但是这些问题的决定， 都需要与你的主机用途来加以考虑的～
		磁盘分区： fdisk
			fdisk [-l] 装置名称 
				选项与参数： 
					-l ：输出后面接的装置所有的 partition 内容。若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜索到的装置的 partition 均列出来。
			找出你系统中的根目录所在磁盘，并查阅该硬盘内的相关信息
				df / <==注意：重点在找出磁盘文件名而已
			fdisk /dev/hdc <==仔细看，不要加上数字喔！
				老实说，使用 fdisk 这支程序是完全不需要背指令的！如同上面的表格中，你只要按下 m 就能够看到所有的动作！
				Command (m for help): p <== 这里可以输出目前磁盘的状态 
					Disk /dev/hdc: 41.1 GB, 41174138880 bytes <==这个磁盘的文件名与容量 
					255 heads, 63 sectors/track, 5005 cylinders <==磁头、扇区与磁柱大小 
					Units = cylinders of 16065 * 512 = 8225280 bytes <==每个磁柱的大小
					
					Device 			Boot 	Start 		End 		Blocks 			Id 				System 
					/dev/hdc1 		* 		1 			13 			104391 			83 				Linux 
					/dev/hdc2 				14 			1288 		10241437+ 		83 				Linux 
					/dev/hdc3 				1289 		1925 		5116702+ 		83 				Linux 
					/dev/hdc4 				1926 		5005 		24740100 		5 				Extended 
					/dev/hdc5 				1926 		2052 		1020096 		82 				Linux swap / Solaris 
					装置文件名 		开机区否 开始磁柱 结束磁柱 		1K大小容量 		磁盘分区槽内癿系统
					这个磁盘共有 41.1GB 左右的容量，共有 5005 个磁柱，每个磁柱透过 255 个磁头在管理读写， 每个磁头管理 63 个扇区，而每个扇区的大小均为 512bytes ，因此每个磁柱为『 255*63*512 = 16065*512 = 8225280bytes 』。
					从上表我们可以发现几件事情：
						整部磁盘还可以进行额外的分割，因为最大磁柱为 5005 ，但只使用到 2052 号而已；
						/dev/hdc5 是由 /dev/hdc4 分割出来的，因为 /dev/hdc4 为 Extended，且 /dev/hdc5 磁柱号码在 /dev/hdc4 之内；
					Last cylinder or +size or +sizeM or +sizeK (1-5005, default 5005): +512M 
					# 这个地方有趣了！我们知道 partition 是由 n1 到 n2 的磁柱号码 (cylinder)， 但磁柱的大小每颗磁盘都不相同，这个时候可以填入 +512M 来让系统自动帮我们找出『最接近 512M 的那个 cylinder 号码』！因为不可能刚好等于 512MBytes 啦！ 如上所示：这个地方输入的方式有两种： # 1) 直接输入磁柱的号码，你得要自己计算磁柱/分割槽的大小才行； # 2) 用 +XXM 来输入分割槽的大小，让系统自己捉磁柱的号码。 # +与M是必须要有的，XX为数字	
					如上的练习中，最终写入分割表后竟然会让核心无法捉到分割表信息！此时你可以直接使用 reboot 来处理， 也可以使用 GNU 推出的工具程序来处置，那就是 partprobe 这个指令。这个指令的执行很简单， 他仅是告知核心必须要读取新的分割表而已，因此并不会在屏幕上出现任何信息才是！ 这样一来，我们就不需要 reboot 啰！
				以 root 的身份进行硬盘的 partition 时，最好是在单人维护模式底下比较安全一些， 此外，在进行 fdisk 的时候，如果该硬盘某个 partition 还在使用当中， 那么很有可能系统核心会无法重载硬盘的 partition table ，解决的方法就是将该使用中的 partition 给他卸除，然后再重新进入 fdisk 一遍，重新写入 partition table ，那么就可以成功啰！
				注意事项：
					SATA 硬盘最多能够支持到 15 号的分割槽， IDE 则可以支持到 63 号。 但目前大家常见的系统都是 SATA 磁盘，因此在练习的时候千万不要让你的分割槽超过 15 号！ 否则即使你还有剩余的磁柱容量，但还是会无法继续进行分割的喔！
					fdisk 没有办法处理大于 2TB 以上的磁盘分区槽！ 这个问题比较严重！因为虽然 Ext3 文件系统已经支持达到 16TB 以上的磁盘，但是分割指令却无法支持。此时你就得使用 parted 这个指令了！
		磁盘格式化
			mkfs
				mkfs [-t 文件系统格式] 装置文件名 
					选项与参数： 
						-t ：可以接文件系统格式，例如 ext3, ext2, vfat 等(系统有支持才会生效)
				mkfs[tab][tab] 
				mkfs mkfs.cramfs mkfs.ext2 mkfs.ext3 mkfs.msdos mkfs.vfat # 按下两个[tab]，会出现 mkfs 支持的文件格式如上所示。mkfs 其实是个综合指令而已，事实上如同上表所示，当我们使用『 mkfs -t ext3 ...』时， 系统会去呼叫 mkfs.ext3 这个指令来进行格式化的动作啦
				在格式化为 Ext3 的范例中，我们可以出现结果里面含有非帯多的信息，由于我们没有详细指定文件系统的细部顷目， 因此系统会使用默认值来进行格式化。其中比较重要的部分为：文件系统的标头(Label)、Block的大小以及 inode 的数量。 如果你要指定这些东西，就得要了解一下 Ext2/Ext3 的公用程序，亦即 mke2fs 这个指令啰！
			mke2fs
				mke2fs [-b block大小] [-i block大小] [-L 标头] [-cj] 装置 
					选项与参数： 
						-b ：可以设定每个 block 的大小，目前支持 1024, 2048, 4096 bytes 三种； 
						-i ：多少容量给予一个 inode 呢？ 
						-c ：检查磁盘错误，仅下达一次 -c 时，会进行快速读取测试； 如果下达两次 -c -c 的话，会测试读写(read-write)，会很慢～ 
						-L ：后面可以接标头名称 (Label)，这个 label 是有用的喔！e2label指令介绍会谈到～ 
						-j ：本来 mke2fs 是 EXT2 ，加上 -j 后，会主动加入 journal 而成为 EXT3。
		磁盘检验： fsck, badblocks
			fsck
				fsck [-t 文件系统] [-ACay] 装置名称 
					选项与参数： 
						-t ：如同 mkfs 一样，fsck 也是个综合软件而已！因此我们同样需要指定文件系统。 不过由于现今的 Linux 太聪明了，他会自动的透过 superblock 去分辨文件系统， 因此通常可以不需要这个选项的啰！请看后续的范例说明。 
						-A ：依据 /etc/fstab 的内容，将需要的装置扫瞄一次。/etc/fstab 于下一小节说明， 通常开机过程中就会执行此一指令了。 
						-a ：自动修复检查到的有问题的扇区，所以你不用一直按 y 啰！ 
						-y ：与 -a 类似，但是某些 filesystem 仅支持 -y 这个参数！ 
						-C ：可以在检验的过程当中，使用一个直方图来显示目前的进度！ EXT2/EXT3 的额外选项功能：(e2fsck 这支指令所提供) 
						-f ：强制检查！一般来说，如果 fsck 没有出现任何 unclean 的旗标，不会主动进入细部检查的，如果您想要强制 fsck 进入细部检查，就得加上 -f 旗标啰！ 
						-D ：针对文件系统下的目录进行优化配置。
				范例二：系统有多少文件系统支持的 fsck 软件？ 
				[root@www ~]# fsck[tab][tab] 
				fsck fsck.cramfs fsck.ext2 fsck.ext3 fsck.msdos fsck.vfat		
				这是用来检查与修正文件系统错误的指令。注意：通常只有身为 root 且你的文件系统有问题的时候才使用这个指令，否则在正帯状况下使用此一指令， 可能会造成对系统的危害！通常使用这个指令的场合都是在系统出现极大的问题，以致你在 Linux 开机的时候得进入单人单机模式下进行维护的行为时，才必须使用此一指令！
				由于 fsck 在扫瞄硬盘的时候，可能会造成部分 filesystem的损坏，所以『执行 fsck 时， 被检查的 partition 务必不可挂载到系统上！亦即是需要在卸除的状态喔！』
				ext2/ext3 文件系统的最顶层(就是挂载点那个目录底下)会存在一个『lost+found』的目录吧！ 该目录就是在当你使用 fsck 检查文件系统后，若出现问题时，有问题的数据会被放置到这个目录中喔！ 所以理论上这个目录不应该会有任何数据，若系统自动产生数据在里面，那...你就得特别注意你的文件系统啰！
				我们的系统实际执行的 fsck 指令，其实是呼叫 e2fsck 这个软件啦！可以 man e2fsck 找到更多的选项辅助喔！
			badblocks
				badblocks -[svw] 装置名称 
					选项与参数： 
						-s ：在屏幕上列出进度 
						-v ：可以在屏幕上看到进度 
						-w ：使用写入的方式来测试，建议不要使用此一参数，尤其是待检查的装置已有档案时！
				刚刚谈到的 fsck 是用来检验文件系统是否出错，至于 badblocks 则是用来检查硬盘或软盘扇区有没有坏轨的指令！ 由于这个指令其实可以透过『 mke2fs -c 装置文件名 』在进行格式化的时候处理磁盘表面的读取测试， 因此目前大多不使用这个指令啰！
		磁盘挂载与卸除
			不过要进行挂载前，你最好先确定几件事：
				单一文件系统不应该被重复挂载在不同的挂载点(目录)中；
				单一目录不应该重复挂载多个文件系统；
				要作为挂载点的目录，理论上应该都是空目录才是。
			[root@www ~]# mount -a 
			[root@www ~]# mount [-l] 
			[root@www ~]# mount [-t 文件系统] [-L Label名] [-o 额外选顷] [-n] 装置文件名 挂载点
			选项与参数： 
				-a ：依照配置文件 /etc/fstab 的数据将所有未挂载的磁盘都挂载上来 
				-l ：单纯的输入 mount 会显示目前挂载的信息。加上 -l 可增列 Label 名称！ 
				-t ：与 mkfs 的选项非常类似的，可以加上文件系统种类来指定欲挂载的类型。 常见的 Linux 支持类型有：ext2, ext3, vfat, reiserfs, iso9660(光盘格式), nfs, cifs, smbfs(此三种为网络文件系统类型) 
				-n ：在默认的情况下，系统会将实际挂载的情况实时写入 /etc/mtab 中，以利其他程序的运作。但在某些情况下(例如单人维护模式)为了避免问题，会刻意不写入。 此时就得要使用这个 -n 癿选项了。 
				-L ：系统除了利用装置文件名 (例如 /dev/hdc6) 之外，还可以利用文件系统的标头名称 (Label)来进行挂载。最好为你的文件系统取一个独一无二的名称吧！ 
				-o ：后面可以接一些挂载时额外加上的参数！比方说账号、密码、读写权限等： 
					ro, rw: 挂载文件系统成为只读(ro) 或可擦写(rw) 
					async, sync: 此文件系统是否使用同步写入 (sync) 或异步 (async) 的内存机制，请参考文件系统运作方式。预设为 async。 
					auto, noauto: 允许此 partition 被以 mount -a 自动挂载(auto) 
					dev, nodev: 是否允许此 partition 上，可建立装置档案？ dev 为可允许 
					suid, nosuid: 是否允许此 partition 含有 suid/sgid 的文件格式？ 
					exec, noexec: 是否允许此 partition 上含有可执行 binary 档案？ 
					user, nouser: 是否允许此 partition 让任何使用者执行 mount ？一般来说， mount 仅有 root 可以进行，但下达 user 参数，则可让一般 user 也能够对此 partition 进行 mount 。 
					defaults: 默认值为：rw, suid, dev, exec, auto, nouser, and async remount: 重新挂载，这在系统出错，或重新更新参数时，很有用！
			利用『mount 装置文件名 挂载点』就能够顺利的挂载了！真是方便啊！ 为什么可以这么方便呢(甚至不需要使用 -t 这个选项)？由于文件系统几乎都有 superblock ， 我们的 Linux 可以透过分析 superblock 搭配 Linux 自己的驱动程序去测试挂载， 如果成功的套和了，就立刻自动的使用该类型的文件系统挂载起来啊！ 那么系统有没有指定哪些类型的 filesystem 才需要进行上述的挂载测试呢？ 主要是参考底下这两个档案：
				/etc/filesystems：系统指定的测试挂载文件系统类型；
				/proc/filesystems：Linux系统已经加载的文件系统类型。		
			我们 Linux 支持的文件系统之驱动程序都写在如下的目录中：/lib/modules/$(uname -r)/kernel/fs/。例如 vfat 的驱动程序就写在『/lib/modules/$(uname -r)/kernel/fs/vfat/』这个目录下啦！
			/mnt和/media目录的区别：
				The new standard is that /media is where the system mounts removable media, and /mnt is for you to mount things manually.
			重新挂载根目录与挂载特定目录
				整个目录树最重要的地方就是根目录了，所以根目录根本就不能够被卸除的！问题是，如果你的挂载参数要改变， 或者是根目录出现『只读』状态时，如何重新挂载呢？最可能的处理方式就是重新启动 (reboot)！ 不过你也可以这样做： 
					范例六：将 / 重新挂载，并加入参数为 rw 与 auto [root@www ~]# mount -o remount,rw,auto /
					重点是那个『 -o remount,xx 』的选项与参数！请注意，要重新挂载 (remount) 时， 这是个非常重要的机制！尤其是当你进入单人维护模式时，你的根目录常会被系统挂载为只读，这个时候这个指令就太重要了！
				另外，我们也可以利用 mount 来将某个目录挂载到另外一个目录去喔！这并不是挂载文件系统，而是额外挂载某个目录的方法！ 虽然底下的方法也可以使用 symbolic link 来连结，不过在某些不支持符号链接的程序运作中，还是得要透过这样的方法才行。 
					范例七：将 /home 这个目录暂时挂载到 /mnt/home 底下： 
					[root@www ~]# mkdir /mnt/home 
					[root@www ~]# mount --bind /home /mnt/home 
					[root@www ~]# ls -lid /home/ /mnt/home 
					2 drwxr-xr-x 6 root root 4096 Sep 29 02:21 /home/ 
					2 drwxr-xr-x 6 root root 4096 Sep 29 02:21 /mnt/home 
					[root@www ~]# mount -l /home on /mnt/home type none (rw,bind)
					看起来，其实两者连结到同一个 inode 嘛！ ^_^ 没错啦！透过这个 mount --bind 的功能， 您可以将某个目录挂载到其他目录去喔！而并不是整块 filesystem 的啦！所以从此进入 /mnt/home 就是进入 /home 的意思喔！
			umount [-fn] 装置文件名或挂载点 
			选项与参数： 
				-f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下； 
				-n ：不更新 /etc/mtab 情况下卸除。		
			使用 Label name 进行挂载的方法		
				可以使用 dumpe2fs 这个指令来查询文件系统的标头：
					[root@www ~]# dumpe2fs -h /dev/hdc6 
					Filesystem volume name: vbird_logical 
					.....底下省略..... 
					# 找到啦！标头名称为 vbird_logical 啰！
					[root@www ~]# mount -L "vbird_logical" /mnt/hdc6
				这种挂载的方法有一个很大的好处：『系统不必知道该文件系统所在的接口与磁盘文件名！』	
		磁盘参数修订
			mknod
				还记得我们说过，在 Linux 底下所有的装置都以档案来代表吧！但是那个档案如何代表该装置呢？ 很简单！就是透过档案的 major 与 minor 数值来替代的～所以，那个 major 与 minor 数值是有特殊意义的，不是随意设定的喔！
				举例来说，在鸟哥的这个测试机当中， 那个用到的磁盘 /dev/hdc 的相关装置代码如下： [root@www ~]# ll /dev/hdc* brw-r----- 1 root disk 22, 0 Oct 24 15:55 /dev/hdc
				上表当中 22 为主要装置代码 (Major) 而 0~6 则为次要装置代码 (Minor)。 我们的 Linux 核心认识的装置数据就是透过这两个数值来决定的！举例来说，常见的硬盘文件名 /dev/hda 与 /dev/sda 装置代码如下所示： 
					磁盘文件名 			Major 			Minor 
					/dev/hda 			3 				0~63 
					/dev/hdb 			3 				64~127 
					/dev/sda 			8 				0-15 
					/dev/sdb 			8 				16-31
				基本上，Linux 核心 2.6 版以后，硬件文件名已经都可以被系统自动的实时产生了，我们根本不需要手动建立装置档案。 不过某些情况底下我们可能还是得要启动处理装置档案的，例如在某些朋务被关联到特定目录下时(chroot)， 就需要这样做了。此时这个 mknod 就得要知道如何操作才行！ 
					[root@www ~]# mknod 装置文件名 [bcp] [Major] [Minor] 
					选项与参数： 
					装置种类： 
						b ：设定装置名称成为一个周边储存设备档案，例如硬盘等； 
						c ：设定装置名称成为一个周边输入设备档案，例如鼠标/键盘等； 
						p ：设定装置名称成为一个 FIFO 档案； 
						Major ：主要装置代码； 
						Minor ：次要装置代码； 
						范例一：由上述的介绍我们知道 /dev/hdc10 装置代码 22, 10，请建立并查阅此装置 
						[root@www ~]# mknod /dev/hdc10 b 22 10 
						[root@www ~]# ll /dev/hdc10 
						brw-r--r-- 1 root root 22, 10 Oct 26 23:57 /dev/hdc10 
						# 上面那个 22 与 10 是有意义的，不要随意设定啊！
			e2label
				我们在 mkfs 指令介绍时有谈到设定文件系统标头 (Label) 的方法。 那如果格式化完毕后想要修改标头呢？就用这个 e2label 来修改了。
				e2label 装置名称 新癿Label名称
			tune2fs
				tune2fs [-jlL] 装置代号 
				选项与参数： 
					-l ：类似 dumpe2fs -h 的功能，将 superblock 内的数据读出来 
					-j ：将 ext2 的 filesystem 转换为 ext3 的文件系统； 
					-L ：类似 e2label 的功能，可以修改 filesystem 的 Label 喔！
			hdparm
				如果你的硬盘是 IDE 接口的，那么这个指令可以帮助你设定一些进阶参数！如果你是使用 SATA 接口的， 那么这个指令就没有多大用途了！另外，目前的 Linux 系统都已经稍微优化过，所以这个指令最多是用来测试效能啦！ 而且建议你不要随便调整硬盘参数，文件系统容易出问题喔！除非你真的知道你调整的数据是啥！ 
				[root@www ~]# hdparm [-icdmXTt] 装置名称 
				选项与参数： 
				-i ：将核心侦测到的硬盘参数显示出来！ 
				-c ：设定 32-bit (32位)存取模式。这个 32 位存取模式指的是在硬盘在与 PCI 接口之间传输的模式，而硬盘本身是依旧以 16 位模式在跑的！ 预设的情况下，这个设定值都会被打开，建议直接使用 c1 即可！ 
				-d ：设定是否启用 dma 模式， -d1 为启动， -d0 为取消； 
				-m ：设定同步读取多个 sector 的模式。一般来说，设定此模式，可降低系统因为 读取磁盘而损耗的效能～不过， WD 的硬盘则不建议设定此值～ 一般来说，设定为 16/32 是优化，不过，WD 硬盘建议值则是 4/8 。 这个值的最大值，可以利用 hdparm -i /dev/hda 输出的 MaxMultSect 来设定喔！一般如果不晓得，设定 16 是合理的！ 
				-X ：设定 UtraDMA 的模式，一般来说， UDMA 的模式值加 64 即为设定值。 并且，硬盘与主板芯片必须要同步，所以，取最小的那个。一般来说： 33 MHz DMA mode 0~2 (X64~X66) 66 MHz DMA mode 3~4 (X67~X68) 100MHz DMA mode 5 (X69) 如果您的硬盘上面显示的是 UATA 100 以上的，那么设定 X69 也不错！ 
				-T ：测试暂存区 cache 的存取效能 
				-t ：测试硬盘的实际存取效能 （较正确！）
				如果你是使用 SATA 硬盘的话，这个指令唯一可以做的，就是最后面那个测试的功能而已啰！ 虽然这样的测试不是很准确，至少是一个可以比较的基准。
	设定开机挂载：		
		开机挂载 /etc/fstab 及 /etc/mtab
			系统挂载的一些限制：
				根目录 / 是必须挂载的﹐而且一定要先于其它 mount point 被挂载进来。
				其它 mount point 必须为已建立的目录﹐可任意指定﹐但一定要遵守必须的系统目录架构原则
				所有 mount point 在同一时间之内﹐只能挂载一次。
				所有 partition 在同一时间之内﹐只能挂载一次。
				如若进行卸除﹐您必须先将工作目录移到 mount point(及其子目录) 之外。
			[root@www ~]# cat /etc/fstab 
			# Device 	Mount point 	filesystem 		parameters 		dump 		fsck 
			LABEL=/1 	/ 				ext3 d			efaults 		1 			1 
			LABEL=/home /home 			ext3 			defaults 		1 			2
			其实 /etc/fstab (filesystem table) 就是将我们利用 mount 指令进行挂载时， 将所有的选顷与参数写入到这个档案中就是了。除此之外， /etc/fstab 还加入了 dump 这个备份用指令的支持！ 与开机时是否进行文件系统检验 fsck 等指令有关。
			各个字段的详细数据如下：
				第一栏：磁盘装置文件名或该装置的 Label：
					这个字段请填入文件系统的装置文件名。但是由上面表格的默认值我们知道系统默认使用的是 Label 名称！ 在鸟哥的这个测试系统中 /dev/hdc2 标头名称为 /1，所以上述表格中的『LABEL=/1』也可以被取代成为『/dev/hdc2』的意思。 至于Label可以使用 dumpe2fs 指令来查阅的。
				第二栏：挂载点 (mount point)：
				第三栏：磁盘分区槽的文件系统：
				第四栏：文件系统参数：
				第五栏：能否被 dump 备份指令作用：
				第六栏: 是否以 fsck 检验扇区：
			/etc/fstab 是开机时的配置文件，不过，实际 filesystem 的挂载是记录到 /etc/mtab 与 /proc/mounts 这两个档案当中的。每次我们在更动 filesystem 的挂载时，也会同时更动这两个档案喔！但是，万一发生您在 /etc/fstab 输入的数据错误，导致无法顸利开机成功，而进入单人维护模式当中，那时候的 / 可是 read only 的状态，当然您就无法修改 /etc/fstab ，也无法更新 /etc/mtab 啰～那怎么办？ 没关系，可以利用底下这一招： [root@www ~]# mount -n -o remount,rw /
		特殊装置 loop 挂载 (映象档不刻录就挂载使用)
			挂载光盘/DVD映象文件
				下载了 Linux 或者是其他所需光盘/DVD的映象文件后， 难道一定需要刻录成为光盘才能够使用该档案里面的数据吗？当然不是啦！我们可以透过 loop 装置来挂载的！mount -o loop /root/centos5.2_x86_64.iso /mnt/centos_dvd
				如此一来我们不需要将这个档案刻录成为光盘或者是 DVD 就能够读取内部的数据了！ 换句话说，你也可以在这个档案内『动手脚』去修改档案的！这也是为什么很多映象档提供后，还得要提供验证码 (MD5) 给使用者确认该映象档没有问题！
			建立大档案以制作 loop 装置档案！
				丼例来说，如果当初在分割时， 你叧有分割出一个根目彔，假讴你已经没有多余癿容量可以迚行额外癿分割癿！偏偏根目彔癿容量还徆大！ 此时你就能够制作出一个大档案，然后将这个档案挂载！如此一来感觉上你就多了一个分割槽啰！
				建立大型档案
					dd if=/dev/zero of=/home/loopdev bs=1M count=512 
					512+0 records in <==读入 512 笔资料 
					512+0 records out <==输出 512 笔数据 
					536870912 bytes (537 MB) copied, 12.3484 seconds, 43.5 MB/s 
					# 这个指令的简单意义如下： 
					# if 是 input file ，输入档案。那个 /dev/zero 是会一直输出 0 的装置！ 
					# of 是 output file ，将一堆零写入到后面接的档案中。 
					# bs 是每个 block 大小，就像文件系统那样的 block 意义； 
					# count 则是总共几个 bs 的意思。 
					[root@www ~]# ll -h 
					/home/loopdev -rw-r--r-- 1 root root 512M Oct 28 02:29 /home/loopdev
				格式化
					mkfs -t ext3 /home/loopdev
				挂载
					mount -o loop /home/loopdev /media/cdrom/
	内存置换空间(swap)之建置
		使用实体分割槽建置swap
			建立 swap 分割槽的方式也是非常的简单的！透过底下几个步骤就搞定啰：
				1. 分割：先使用 fdisk 在你的磁盘中分割中一个分割槽给系统作为 swap 。由于 Linux 的 fdisk 预设会将分割槽的 ID 设定为 Linux 的文件系统，所以你可能还得要设定一下 system ID 就是了。
				2. 格式化：利用建立 swap 格式的『mkswap 装置文件名』就能够格式化该分割槽成为 swap 格式啰
				3. 使用：最后将该 swap 装置启动，方法为：『swapon 装置文件名』。
				4. 观察：最终透过 free 这个指令来观察一下内存的用量吧！
			swapon -s	列出目前使用的 swap 装置有哪些的意思！
		使用档案建置swap
			如果是在实体分割槽无法支持的环境下，此时前一小节提到的 loop 装置建置方法就派的上用场啦！ 与实体分割槽不一样的只是利用 dd 去建置一个大档案而已。
			[root@www ~]# swapon -s 
			Filename 		Type 		Size 		Used 		Priority 
			/dev/hdc5 		partition 	1020088 	96 			-1 
			/dev/hdc7 		partition 	257000 		0 			-2 
			/tmp/swap 		file 		131064 		0 			-3
		因为 swap 主要的功能是当物理内存不够时，则某些在内存当中所占的程序会暂时被移动到 swap 当中，让物理内存可以被需要的程序来使用。另外，如果你的主机支持电源管理模式， 也就是说，你的 Linux 主机系统可以进入『休眠』模式的话，那么， 运作当中的程序状态则会被记录到 swap 去，以作为『唤醒』主机的状态依据！ 另外，有某些程序在运作时，本来就会利用 swap 的特性来存放一些数据段， 所以， swap 来是需要建立的！
		不过， swap 在被建立时，是有限制的喔！
			在核心 2.4.10 版本以后，单一 swap 量已经没有 2GB 的限制了，
			但是，最多还是仅能建立到 32 个 swap 的数量！
			而且，由于目前 x86_64 (64位) 最大内存寻址到 64GB， 因此， swap 总量最大也是仅能达 64GB 就是了！
	文件系统的特殊观察与操作	
		利用 GNU 的 parted 进行分割行为
			虽然你可以使用 fdisk 很快速的将你的分割槽切割妥当，不过 fdisk 却无法支持到高于 2TB 以上的分割槽！ 此时就得需要 parted 来处理了。
			parted [装置] [指令 [参数]] 
			选项与参数： 
				指令功能： 
					新增分割：mkpart [primary|logical|extended] [ext3|vfat] 开始 结束
					分割表 ：print 
					删除分割：rm [partition]
	重点回顾
		基本上 Linux 的正统文件系统为 Ext2 ，该文件系统内的信息主要有：
			superblock：记录此 filesystem 的整体信息，包括inode/block的总量、使用量、剩余量， 以及文件系统的格式与相关信息等；
			inode：记录档案的属性，一个档案占用一个inode，同时记录此档案的数据所在的 block 号码；
			block：实际记录档案的内容，若档案太大时，会占用多个 block 。
		Ext2文件系统主要有：boot sector, superblock, inode bitmap, block bitmap, inode table, data block 等六大部分。
		每个 inode 大小均固定为 128 bytes
		磁盘的使用必需要经过：分割、格式化与挂载，分别惯用的指令为：fdisk, mkfs, mount三个指令
		
	System wide aliases and functions should go in /etc/bashrc. Personal environment variables and startup programs should go into ~/.bash_profile. Personal aliases and functions should go into ~/.bashrc.	
		
		
第九章、档案与文件系统的压缩与打包
	压缩文件案的用途与技术
	Linux 系统常见的压缩指令：
		几个常见的压缩文件案扩展名:
			*.Z compress 程序压缩的档案； 
			*.gz gzip 程序压缩的档案； 
			*.bz2 bzip2 程序压缩的档案； 
			*.tar tar 程序打包的数据，并没有压缩过； 
			*.tar.gz tar 程序打包的档案，其中并且经过 gzip 的压缩 
			*.tar.bz2 tar 程序打包的档案，其中并且经过 bzip2 的压缩
		Linux上常见的压缩指令就是 gzip 与 bzip2 ，至于 compress 已经退流行了。不过，这些指令通常仅能针对一个档案来压缩与解压缩，如此一来， 每次压缩与解压缩都要一大堆档案，岂不烦人？此时，那个所谓的『打包软件, tar』就显的很重要啦！
		compress这个压缩指令是非常老旧的一款，大概只有在非常旧的 Unix 机器上面还会找到这个软件。 我们的 CentOS 预设并没有安装这个软件到系统当中，所以想要了解这个软件的使用时，请先安装 ncompress 这个软件。 不过，由于 gzip 已经可以解开使用 compress 压缩的档案，因此， compress 可以不用学习啦
		gzip, zcat
			gzip 可以说是应用度最广的压缩指令了！目前 gzip 可以解开 compress, zip 与 gzip 等软件所压缩的档案。 至于 gzip 所建立的压缩文件为 *.gz 的檔名喔！
			[root@www ~]# gzip [-cdtv#] 檔名 
			[root@www ~]# zcat 檔名.gz 
			选项与参数： 
				-c ：将压缩的数据输出到屏幕上，可透过数据流重导向来处理； 
				-d ：解压缩的参数； 
				-t ：可以用来检验一个压缩文件的一致性～看看档案有无错误； 
				-v ：可以显示出原档案/压缩文件案的压缩比等信息； 
				-# ：压缩等级，-1 最快，但是压缩比最差、-9 最慢，但是压缩比最好！预设是 -6
			与 compress 类似的，当你使用 gzip 进行压缩时，在预设的状态下原本的档案会被压缩成为 .gz 的檔名， 源文件就不再存在了。
			[root@www tmp]# zcat man.config.gz 
			# 由于 man.config 这个原本的档案是是文本文件，因此我们可以尝试使用 zcat 去读取！ 
			# 此时屏幕上会显示 man.config.gz 解压缩之后的档案内容！
			[root@www tmp]# gzip -d man.config.gz 
			# 不要使用 gunzip 这个指令，不好背！使用 gzip -d 来进行解压缩！ 
			# 与 gzip 相反， gzip -d 会将原本的 .gz 删除，产生原本的 man.config 档案。
			cat 可以读取纯文本档，那个 zcat 则可以读取纯文本档被压缩后的压缩文件！ 由于 gzip 这个压缩指令主要想要用来取代 compress 的，所以不但 compress 的压缩文件案可以使用 gzip 来解开，同时 zcat 这个指令可以同时读取 compress 与 gzip 的压缩文件呦！
		bzip2, bzcat
			若说 gzip 是为了取代 compress 并提供更好的压缩比而成立的，那么 bzip2 则是为了取代 gzip 并提供更佳的压缩比而来的。
			[root@www ~]# bzip2 [-cdkzv#] 檔名 
			[root@www ~]# bzcat 檔名.bz2 
			选项与参数： 
				-c ：将压缩的过程产生的数据输出到屏幕上！ 
				-d ：解压缩的参数 
				-k ：保留源文件，而不会删除原始的档案喔！ 
				-z ：压缩的参数 
				-v ：可以显示出原档案/压缩文件案的压缩比等信息； 
				-# ：与 gzip 同样的，都是在计算压缩比的参数， -9 最佳， -1 最快！
			[root@www tmp]# bzcat man.config.bz2 
			# 此时屏幕上会显示 man.config.bz2 解压缩之后的档案内容！！
			使用 compress 扩展名自动建立为 .Z ，使用 gzip 扩展名自动建立为 .gz 。这里的 bzip2 则是自动的将扩展名建置为 .bz2 啰！
			当然啰，也可以使用 bunzip2 这个指令来取代 bzip2 -d 啰
	打包指令： tar	
		[root@www ~]# tar [-j|-z] [cv] [-f 建立的檔名] filename... <==打包与压缩 
		[root@www ~]# tar [-j|-z] [tv] [-f 建立的檔名] <==察看檔名 
		[root@www ~]# tar [-j|-z] [xv] [-f 建立的檔名] [-C 目录] <==解压缩 
		选项与参数： 
			-c ：建立打包档案，可搭配 -v 来察看过程中被打包的档名(filename) 
			-t ：察看打包档案的内容含有哪些档名，重点在察看『档名』就是了； 
			-x ：解打包或解压缩的功能，可以搭配 -C (大写) 在特定目录解开 特别留意的是， -c, -t, -x 不可同时出现在一串指令列中。 
			-j ：透过 bzip2 的支持进行压缩/解压缩：此时档名最好为 *.tar.bz2 
			-z ：透过 gzip 的支持进行压缩/解压缩：此时档名最好为 *.tar.gz 
			-v ：在压缩/解压缩的过程中，将正在处理的文件名显示出来！ 
			-f filename：-f 后面要立刻接要被处理的档名！建议 -f 单独写一个选项啰！ 
			-C 目录 ：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。 其他后续练习会使用到的选项介绍： 
			-p ：保留备份数据的原本权限与属性，常用于备份(-c)重要的配置文件 
			-P ：保留绝对路径，亦即允许备份数据中含有根目录存在之意； 
			--exclude=FILE：在压缩的过程中，不要将 FILE 打包！
		那个 filename.tar.bz2 是我们自己取的档名，tar 并不会主动的产生建立的档名喔！我们要自定义啦！ 所以扩展名就显的很重要了！如果不加 [-j|-z] 的话，档名最好取为 *.tar 即可。如果是 -j 选顷，代表有 bzip2 的支持，因此档名最好就取为 *.tar.bz2 ，因为 bzip2 会产生 .bz2 的扩展名之故！ 至与如果是加上了 -z 的 gzip 的支持，那档名最好取为 *.tar.gz 喔！
		[root@www ~]# tar -jtv -f /root/etc.tar.bz2 
		....前面省略.... 
		-rw-r--r-- root/root 1016 2008-05-25 14:06:20 etc/dbus-1/session.conf
		从上面的数据我们可以发现一件很有趣的事情，那就是每个文件名都没了根目录了！这也是上一个练习中出现的那个警告讯息『tar: Removing leading `/' from member names(移除了档名开头的 `/' )』所告知的情况！ 那为什么要拿掉根目录呢？主要是为了安全！我们使用 tar 备份的数据可能会需要解压缩回来使用， 在 tar 所记录的文件名 (就是我们刚刚使用 tar -jtvf 所察看到的檔名) 那就是解压缩后的实际档名。 如果拿掉了根目录，假设你将备份数据在 /tmp 解开，那么解压缩的档名就会变成『/tmp/etc/xxx』。 但『如果没有拿掉根目录，解压缩后的档名就会是绝对路径， 亦即解压缩后的数据一定会被放置到 /etc/xxx 去！』如此一来，你的原本的 /etc/ 底下的数据， 就会被备份数据所覆盖过去了！
		仅解开单一档案的方法
			只要使用 -jtv 找到你要的档名，然后将该档名解开即可
			[root@www ~]# tar -jxv -f 打包檔.tar.bz2 待解开档名 
			[root@www ~]# tar -jxv -f /root/etc.tar.bz2 etc/shadow
		仅备份比某个时刻还要新的档案
			某些情况下你会想要备份新的档案而已，并不想要备份旧档案！此时 --newer-mtime 这个选项就粉重要啦！ 其实有两个选项啦，一个是『 --newer 』另一个就是『 --newer-mtime 』，这两个选项有何不同呢？ 我们在 第七章的 touch 介绍中谈到过三种不同的时间参数， 当使用 --newer 时，表示后续的日期包含『 mtime 与 ctime 』，而 --newer-mtime 则仅是 mtime 而已！
		grep -v
			--invert-match
			Invert the sense of matching, to select non-matching lines. (-v is specified by POSIX.) 	
		特殊应用：利用管线命令与数据流
			# 1. 将 /etc 整个目录一边打包一边在 /tmp 解开 
			[root@www ~]# cd /tmp 
			[root@www ~]# tar -cvf - /etc | tar -xvf - 
			# 这个动作有点像是 cp -r /etc /tmp 啦～依旧是有其有用途的！ # 要注意的地方在于输出档变成 - 而输入档也变成 - ，又有一个 | 存在～ 
			# 这分别代表 standard output, standard input 与管线命令啦！ # 简单的想法中，你可以将 - 想成是在内存中的一个装置(缓冲区)。 # 更详细的数据流与管线命令，请翻到 bash 章节啰！
			在上面的例子中，我们想要『将 /etc 底下的资料直接 copy 到目前所在的路径，也就是 /tmp 底下』，但是又觉得使用 cp -r 有点麻烦，那么就直接以这个打包的方式来打包，其中，指令里面的 - 就是表示那个被打包的档案啦！ 由于我们不想要让中间档案存在，所以就以这一个方式来进行复制的行为啦！
	完整备份工具：dump
		dump
			其实 dump 的功能颇强，他除了可以备份整个文件系统之外，还可以制定等级喔！什么意思啊！ 假设你的 /home 是独立的一个文件系统，那你第一次进行过 dump 后，再进行第二次 dump 时， 你可以指定不同的备份等级，第一次备份时使用的是 level 0 ，这个等级也是完整的备份啦！ 等到第二次备份时，实时文件系统内的数据已经与 level 0 不一样了，而 level 1 仅只是比较目前的文件系统与 level 0 之间的差异后，备份有变化过的档案而已。至于 level 2 则是与 level 1 进行比较啦,而不是与level 0比较.
			虽然 dump 支持整个文件系统或者是单一各别目录，但是对于目录的支持是比较不足的，这也是 dump 的限制所在。 简单的说，如果想要备份的数据如下时，则有不同的限制情况：
				当待备份的资料为单一文件系统： 如果是单一文件系统 (filesystem) ，那么该文件系统可以使用完整的 dump 功能，包括利用 0~9 的数个 level 来备份， 同时，备份时可以使用挂载点或者是装置文件名 (例如 /dev/sda5 之类的装置文件名) 来进行备份！
				待备份的数据只是目录，并非单一文件系统： 例如你仅想要备份 /home/someone/ ，但是该目录并非独立的文件系统时。此时备份就有限制啦！包括：
					所有的备份数据都必项要在该目录 (本例为：/home/someone/) 底下；
					且仅能使用 level 0 ，亦即仅支持完整备份而已；
					不支持 -u 选项，亦即无法建立 /etc/dumpdates 这个各别 level 备份的时间记录文件；
				[root@www ~]# dump [-Suvj] [-level] [-f 备份档] 待备份资料 
				[root@www ~]# dump -W 
				选项与参数： 
					-S ：仅列出后面的待备份数据需要多少磁盘空间才能够备份完毕； 
					-u ：将这次 dump 的时间记录到 /etc/dumpdates 档案中； 
					-v ：将 dump 的档案过程显示出来；
					-j ：加入 bzip2 的支持！将数据进行压缩，默认 bzip2 压缩等级为 2 -level：就是我们谈到癿等级，从 -0 ~ -9 共十个等级； 
					-f ：有点类似 tar 啦！后面接产生的档案，亦可接例如 /dev/st0 装置文件名等 
					-W ：列出在 /etc/fstab 里面的具有 dump 设定的 partition 是否有备份过？
			# 0. 看一下有没有任何文件系统被 dump 过的资料？ 
			[root@www ~]# dump -W 
			Last dump(s) done (Dump '>' file systems): 
			> /dev/hdc2 ( /) Last dump: never 
			> /dev/hdc3 ( /home) Last dump: never 
			/dev/hdc1 ( /boot) Last dump: Level 0, Date Tue Dec 2 02:53:47 2008 
			# 如上列的结果，该结果会捉出 /etc/fstab 里面第五字段设定有需要 dump 的 partition，然后与/etc/dumpdates 进行比对，可以得到上面的结果啦！ 尤其是第三行，可以显示我们曾经对 /dev/hdc1 进行过 dump 的备份动作喔！ 
			# 1. 先恶搞一下，建立一个大约 10 MB 的档案在 /boot 内： 
			[root@www ~]# dd if=/dev/zero of=/boot/testing.img bs=1M count=10 
			10+0 records in 
			10+0 records out 
			10485760 bytes (10 MB) copied, 0.166128 seconds, 63.1 MB/s
			用 dump 备份非文件系统，亦即单一目录的方法
				因为 /etc 并非单一文件系统，他只是个目录而已。 所以依据限制的说明， -u, level 1~9 都是不适用的。我们只能够使用 level 0 的完整备份将 /etc 给他 dump 下来。
		restore
			dump 的复原使用的是 restore 这个指令
			[root@www ~]# restore -t [-f dumpfile] [-h] <==用来察看 dump 档 
			[root@www ~]# restore -C [-f dumpfile] [-D 挂载点] <==比较dump与实际档案 
			[root@www ~]# restore -i [-f dumpfile] <==进入互动模式
			[root@www ~]# restore -r [-f dumpfile] <==还原整个文件系统 
			选项与参数： 
				相关的各种模式，各种模式无法混用喔！例如不可以写 -tC 啦！ 
				-t ：此模式用在察看 dump 起来的备份文件中含有什么重要数据！类似 tar -t 功能； 
				-C ：此模式可以将 dump 内的数据拿出来跟实际的文件系统做比较， 最终会列出『在 dump 档案内有记录的，且目前文件系统不一样』的档案； 
				-i ：进入互动模式，可以仅还原部分档案，用在 dump 目录时的还原！ 
				-r ：将整个 filesystem 还原的一种模式，用在还原针对文件系统的 dump 备份； 其他较常用到的选项功能： 
				-h ：察看完整备份数据中的 inode 与文件系统 label 等信息 
				-f ：后面就接你要处理的那个 dump 档案啰！ 
				-D ：与 -C 进行搭配，可以查出后面接的挂载点与 dump 内有不同的档案！
			仅还原部分档案癿 restore 互劢模式
				某些时候你只是要将备份档癿某个内容捉出杢而已，并丌想要全部解开，那该如何是好？此时你可以迚入 restore 癿互劢模式 (interactive mode)。在底下我们使用 etc.dump 杢迚行范例说明。假如你要将 etc.dump 内癿 passwd 不 shadow 捉出杢而已，该如何迚行呢？
				[root@www ~]# cd /mnt 
				[root@www mnt]# restore -i -f /root/etc.dump 
				restore > 
				# 此时你就已经进入 restore 的互动模式画面中！要注意的是： 
				# 你目前已经在 etc.dump 这个档案内了！所有的动作都是在 etc.dump 内！ 
				restore > help Available commands are: 
					ls [arg] - list directory <==列出 etc.dump 内的档案或目录 
					cd arg - change directory <==在 etc.dump 内变更目录 
					pwd - print current directory <==列出在 etc.dump 内的路径文件名 
					add [arg] - add `arg' to list of files to be extracted 
					delete [arg] - delete `arg' from list of files to be extracted 
					extract - extract requested files 
					# 上面三个指令是重点！各指令的功能为： 
					# add file ：将 file 加入等一下要解压缩的档案列表中 
					# delete file ：将 file 移除出解压缩的列表，并非删除 etc.dump 内的档案！别误会！^_^ 
					# extract ：开始将刚刚选择的档案列表解压缩了去！ 
					setmodes - set modes of requested directories 
					quit - immediately exit program 
					what - list dump header information 
					verbose - toggle verbose flag (useful with ``ls'') 
					prompt - toggle the prompt display 
					help or `?' - print this list 
					restore > ls 
					.: 
					etc/ <==会显示出在 etc.dump 内主要的目录，因为我们备份 /etc ，所以档名为此！ 
					restore > cd etc <==在 etc.dump 内变换路径到 etc 目录下 
					restore > pwd <==列出本目录的文件名为？ /etc 
					restore > ls passwd shadow group <==看看，真的有这三个档案喔！ 
					passwd shadow group 
					restore > add passwd shadow group <==加入解压缩列表 
					restore > delete group <==加错了！将 group 移除解压缩列表 
					restore > ls passwd shadow group *passwd <==有要被解压缩的，档名之前会出现 * 的符号呢！
					*shadow group 
					restore > extract <==开始进行解压缩去！ 
					You have not read any volumes yet. <==这里会询问你需要的volume 
					Unless you know which volume your file(s) are on you should start with the last volume and work towards the first. 
					Specify next volume # (none if no more volumes): 1 <==只有一个 volume 
					set owner/mode for '.'? [yn] n <==不需要修改权限 
					restore > quit <==离开restore 的功能 
					[root@www ~]# ll -d etc 
					drwxr-xr-x 2 root root 1024 Dec 15 17:49 etc <==解压缩后，所建立出来的目录啦！ 
					[root@www ~]# ll etc 
					total 6 
					-rw-r--r-- 1 root root 1945 Sep 29 02:21 passwd 
					-r-------- 1 root root 1257 Sep 29 02:21 shadow
	光盘写入工具
		那么文本模式的刻录行为要怎么处理呢？通常的作法是这样的：
			先将所需要备份的数据建置成为一个映像档(iso)，利用 mkisofs 指令来处理；
			将该映像文件刻录至光盘或 DVD 当中，利用 cdrecord 指令来处理。
		mkisofs：建立映像档
			[root@www ~]# mkisofs [-o 映像档] [-rv] [-m file] 待备份文件.. [-V vol] \ > -graft-point isodir=systemdir ... 
			选项与参数： 
				-o ：后面接你想要产生的那个映像档档名。 
				-r ：透过 Rock Ridge 产生支持 Unix/Linux 的档案数据，可记录较多的信息； 
				-v ：显示建置 ISO 档案的过程
				-m file ：-m 为排除档案 (exclude) 的意思，后面的档案不备份到映像档中 
				-V vol ：建立 Volume，有点像 Windows 在档案总管内看到的 CD title 的东西 
				-graft-point：graft有转嫁或移植的意思，相关资料在底下文章内说明。
			一般预设的情况下，所有要被加到映像档中的档案都会被放置到映象文件中的根目录， 如此一来可能会造成刻录后的档案分类不易的情况。所以，你可以使用 -graft-point 这个选项，当你使用这个选项之后， 可以利用如下的方法来定义位于映像文件中的目录，例如：映像文件中的目录所在=实际 Linux 文件系统的目录所在
		cdrecord：光盘刻录工具	
	其他常见的压缩与备份工具	
		dd
			dd 可以读取磁盘装置的内容(几乎是直接读取扇区"sector")，然后将整个装置备份成一个档案
			[root@www ~]# dd if="input_file" of="output_file" bs="block_size" \ > count="number" 
			选项与参数： 
				if ：就是 input file 啰～也可以是装置喔！ 
				of ：就是 output file 喔～也可以是装置； 
				bs ：规划的一个 block 的大小，若未指定则预设是 512 bytes(一个 sector 的大小) 
				count：多少个 bs 的意思
			将自己的磁盘之第一个扇区备份下来 
				[root@www ~]# dd if=/dev/hdc of=/tmp/mbr.back bs=512 count=1	
			如果要还原呢？就反向回去！ # dd if=/tmp/boot.whole.disk of=/dev/hdc1 即可！
		cpio
			cpio 有个大问题， 那就是 cpio 不会主动的去找档案来备份！一般来说， cpio 得要配合类似 find 等可以找到文件名的指令来告知 cpio 该被备份的数据在哪里啊！
			[root@www ~]# cpio -ovcB > [file|device] <==备份 
			[root@www ~]# cpio -ivcdu < [file|device] <==还原 
			[root@www ~]# cpio -ivct < [file|device] <==察看 
			备份会使用到的选项与参数： 
				-o ：将数据 copy 输出到档案或装置上 
				-B ：让预设的 Blocks 可以增加至 5120 bytes ，预设是 512 bytes ！ 这样的好处是可以让大档案的储存速度加快(请参考 i-nodes 癿观念) 
			还原会使用到的选项与参数： 
				-i ：将数据自档案或装置 copy 出来系统当中 
				-d ：自动建立目录！使用 cpio 所备份的数据内容不见得会在同一层目录中，因此我们 必项要让 cpio 在还原时可以建立新目录，此时就得要 -d 选顷的帮助！ 
				-u ：自动的将较新的档案覆盖较旧的档案！ 
				-t ：需配合 -i 选项，可用在"察看"以 cpio 建立的档案或装置的内容 
			一些可共享的选项与参数： 
				-v ：让储存的过程中文件名可以在屏幕上显示
				-c ：一种较新的 portable format 方式储存
		重点回顾
			
			

第十章、vim 程序编辑器	
	vi 的使用		
		基本上 vi 共分为三种模式，分别是『一般模式』、『编辑模式』不『指令列命令模式』。
		需要注意的是，如果你的档案权限不对，例如为 -r--r--r-- 时，那么可能会无法写入，此时可以使用『强制写入』的方式吗？可以！使用『 :wq! 』 多加一个惊叹号即可！不过，需要特别注意呦！那个是在『你的权限可以改变』的情况下才能成立的！
		一般模式可用的按钮说明
			如果想要迚行多次移劢癿话，例如向下移劢 30 行，可以使用 "30j" 戒 "30↓" 癿组合按键， 亦即加上想要迚行癿次数(数字)后，按下劢作即可！
			移动光标的方法
				[Ctrl] + [f] 				屏幕『向下』移动一页，相当于 [Page Down]按键 (常用) 
				[Ctrl] + [b] 				屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用) 
				[Ctrl] + [d] 				屏幕『向下』移动半页 
				[Ctrl] + [u] 				屏幕『向上』移动半页 
				+ 							光标移动到非空格符的下一列 
				- 							光标移动到非空格符的上一列 
				n<space> 					那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。 
				0 或功能键[Home] 			这是数字『 0 』：移动到这一行的最前面字符处 (常用) 
				$ 或功能键[End] 			移动到这一行的最后面字符处(常用)
				H 							光标移动到这个屏幕的最上方那一行的第一个字符 
				M 							光标移动到这个屏幕的中央那一行的第一个字符 
				L 							光标移动到这个屏幕的最下方那一行的第一个字符 
				G 							移动到这个档案的最后一行(常用) 
				nG 							n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu) 
				gg 							移动到这个档案的第一行，相当于 1G 啊！ (常用) 
				n<Enter> 					n 为数字。光标向下移动 n 行(常用)
			搜寻与取代
				:n1,n2s/word1/word2/g 		n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s/vbird/VBIRD/g』。(常用) 
				:1,$s/word1/word2/g 		从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用) 
				:1,$s/word1/word2/gc 		从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)
			删除、复制与贴上
				nx 							n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。 
				dd 							删除游标所在的那一整列(常用) 
				ndd 						n 为数字。删除光标所在的向下 n 列，例如 20dd 则是删除 20 列 (常用) 
				d1G 						删除光标所在到第一行的所有数据 
				dG 							删除光标所在到最后一行的所有数据 
				d$ 							删除游标所在处，到该行的最后一个字符 
				d0 							那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符 
				yy 							复制游标所在的那一行(常用) 
				nyy 						n 为数字。复制光标所在的向下 n 列，例如 20yy 则是复制 20 列(常用)
				y1G 						复制光标所在列到第一列的所有数据 
				yG 							复制光标所在列到最后一列的所有数据 
				y0 							复制光标所在的那个字符到该行行首的所有数据 
				y$ 							复制光标所在的那个字符到该行行尾的所有数据 
				p, P 						p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用) 
				J 							将光标所在列与下一列的数据结合成同一列 
				c 							重复删除多个数据，例如向下删除 10 行，[ 10cj ] 
				u 							复原前一个动作。(常用) 
				[Ctrl]+r 					重做上一个动作。(常用)
				. 							不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)
			进入插入或取代的编辑模式
				i, I 						进入插入模式(Insert mode)：i 为『从目前光标所在处插入』， I 为『在目前所在行的第一个非空格符处开始插入』。 (常用) 
				a, A 						进入插入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始插入』， A 为『从光标所在行的最后一个字符处开始插入』。(常用) 
				o, O 						进入插入模式(Insert mode)： 这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处插入新的一行』； O 为在目前光标所在处的上一行插入新的一行！(常用) 
				r, R 						进入取代模式(Replace mode)： r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)
			指令列的储存、离开等指令
				ZZ 							这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！
				:w [filename] 				将编辑的数据储存成另一个档案（类似另存新档） 
				:r [filename] 				在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面 
				:n1,n2 w [filename] 		将 n1 到 n2 的内容储存成 filename 这个档案。 
				:! command 					暂时离开 vi 到指令列模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的癿档案信息！
			vim 环境的变更 
				:set nu 					显示行号，设定之后，会在每一行的前缀显示该行的行号 
				:set nonu 					与 set nu 相反，为取消行号！
		vim 的暂存档、救援回复与开启时的警告讯息		
			当我们在使用 vim 编辑时， vim 会在与被编辑的档案的目录下，再建立一个名为 .filename.swp 的档案。
			这个出现暂存盘警告讯息的画面中，有出现六个可用按钮，各按钮的说明如下：
				[O]pen Read-Only：打开此档案成为只读档， 可以用在你只是想要查阅该档案内容并不想要进行编辑行为时。一般来说，在上课时，如果你是登入到同学的计算机去看他德配置文件， 结果出现其实同学他自己也在编辑时，可以使用这个模式；
				(E)dit anyway：还是用正常的方式打开你要编辑的那个档案， 并不会载入暂存盘的内容。不过很容易出现两个使用者互相改变对方的档案等问题！不好不好！
				(R)ecover：就是加载暂存盘的内容，用在你要救回之前未储存的工作。 不过当你救回来并且储存离开 vim 后，还是要手动自行删除那个暂存档喔！
				(D)elete it：你确定那个暂存档是无用的！那么开启档案前会先将这个暂存盘删除！ 这个动作其实是比较常做的！因为你可能不确定这个暂存档是怎么来的，所以就删除掉他吧！哈哈！
				(Q)uit：按下 q 就离开 vim ，不会进行任何动作回到命令提示字符。
				(A)bort：忽略这个编辑行为，感觉上与 quit 非常类似！ 也会送你回到命令提示字符就是啰！
	vim 的额外功能	
		最右下角的 30% 代表目前这个画面占整体档案的 30% 之意
		区块选择的按键意义 
			v 			字符选择，会将光标经过的地方反白选择！ 
			V 			行选择，会将光标经过的行反白选择！ 
			[Ctrl]+v 	区块选择，可以用长方形的方式选择资料 
			y 			将反白的地方复制起来 
			d 			将反白的地方删除掉
		多档案编辑
			我们可以使用 vim 后面同时接好几个档案来同时开启喔！相关的按键有： 
				多档案编辑的按键 
					:n 				编辑下一个档案 
					:N 				编辑上一个档案 
					:files 			列出目前这个 vim 的开启的所有档案
			在过去，鸟哥想要将 A 档案内的十条消息『移动』到 B 档案去，通常要开两个 vim 窗口来复制， 偏偏每个 vim 都是独立的，因此并没有办法在 A 档案下达『 nyy 』再跑到 B 档案去『 p 』啦！ 在这种情况下最常用的方法就是透过鼠标圈选， 复制后贴上。不过这样一来还是有问题，因为鸟哥超级喜欢使用 [Tab] 按键进行编排对齐动作， 透过鼠标却会将 [Tab] 转成空格键，这样内容就不一样了！此时这个多档案编辑就派上用场了！
		多窗口功能
			在指令列模式输入『:sp {filename}』即可！那个 filename 可有可无， 如果想要在新窗口启动另一个档案，就加入档名，否则仅输入 :sp 时， 出现的则是同一个档案在两个窗口间！
			你还可以利用『[ctrl]+w+↑/k』及『[ctrl]+w+↓/j』 在两个窗口之间移动呢
		vim 环境设定与记录： ~/.vimrc, ~/.viminfo
			这是因为我们的 vim 会主动的将你曾经做过的行为登录下来，好让你下次可以轻松的作业啊！ 那个记录动作的档案就是： ~/.viminfo ！如果你曾经使用过 vim， 那你的家目录应该会存在这个档案才对。这个档案是自动产生的， 你不必自行建立。而你在 vim 里面所做过的动作，就可以在这个档案内部查询到啰
			vim 的环境设定参数有很多，如果你想要知道目前的设定值，可以在一般模式时输入『 :set all 』 来查阅，不过.....设定项目实在太多了
			vim 的环境设定参数 
				:set nu :set nonu 						就是设定不取消行号啊！ 
				:set hlsearch :set nohlsearch 			hlsearch 就是 high light search(高亮度搜寻)。 这个就是设定是否将搜寻的字符串反白的设定值。默认值是 hlsearch 
				:set autoindent :set noautoindent 		是否自动缩排？autoindent 就是自动缩排。 
				:set backup 							是否自动储存备份档？一般是 nobackup 的， 如果设定 backup 的话，那么当你更动任何一个档案时，则源文件会被另存成一个档名为 filename~ 的档案。 举例来说，我们编辑 hosts ，设定 :set backup ，那么当更动 hosts 时，在同目录下，就会产生 hosts~ 文件名的档案，记录原始的 hosts 档案内容 
				:set ruler 								还记得我们提到的右下角的一些状态栏说明吗？ 这个 ruler 就是在显示或不显示该设定值的啦！ :set showmode 这个则是，是否要显示 --INSERT-- 之类的字眼在左下角的状态栏。 
				:set backspace=(012) 					一般来说， 如果我们按下 i 进入编辑模式后，可以利用退格键 (backspace) 来删除任意字符的。 但是，某些 distribution 则不许如此。此时，我们就可以透过 backspace 来设定啰～ 当 backspace 为 2 时，就是可以删除任意值；0 或 1 时，仅可删除刚刚输入的字符， 而无法删除原本就已经存在的文字了！ 
				:set all 								显示目前所有的环境参数设定值。 
				:set 									显示与系统默认值不同的设定参数， 一般来说就是你有自行变动过的设定参数啦！ 
				:syntax on :syntax off 					是否依据程序相关语法显示不同颜色？ 举例来说，在编辑一个纯文本档时，如果开央是以 # 开始，那么该行就会变成蓝色。 如果你懂得写程序，那么这个 :syntax on 还会主动的帮你除错呢！但是， 如果你仅是编写纯文本档案，要避免颜色对你的屏幕产生的干扰，则可以取消这个设定 。
				:set bg=dark :set bg=light 				可用以显示不同癿颜色色调，预设是『 light 』。如果你常常出现批注的字体深蓝色实在很不容易看， 那么这里可以设定为 dark 喔！试看看，会有不同的样式呢！
			整体 vim 的设定值一般是放置在 /etc/vimrc 这个档案，不过，不建议你修改他！ 你可以修改 ~/.vimrc 这个档案 (预设不存在，请你自行手动建立！)，将你所希望的设定值写入！ 
			vimrc中双引号是批注符号！
		vim 常用指令示意图
	其他 vim 使用注意事项
		这时你得要考虑许多东西啦！有这些：
			1. 你的 Linux 系统默认支持的语系数据：这与 /etc/sysconfig/i18n 有关；
			2. 你的终端界面 (bash) 的语系： 这与 LANG 这个变数有关；
			3. 你的档案原本的编码；
			4. 开启终端机的软件，例如在 GNOME 底下的窗口接口。
		DOS 与 Linux 的断行字符
			我们也可以利用 cat -A 来观察以 DOS (Windows 系统) 建立的档案的特殊格式， 也可以出现在 DOS 使用的断行字符为 ^M$ ，我们称为 CR 与 LF 两个符号。 而在 Linux 底下，则是仅有 LF ($) 这个断行符号。这个断行符号对于 Linux 的影响很大喔！ 为什么呢？ 我们说过，在 Linux 底下的指令在开始执行时，他的判断依据是 『Enter』，而 Linux 的 Enter 为 LF 符号， 不过，由于 DOS 的断行符号是 CRLF ，也就是多了一个 ^M 的符号出来， 在这样的情况下，如果是一个 shell script 德程序档案，呵呵～将可能造成『程序无法执行』的状态～ 因为他会误判程序所下达的指令内容啊！这很伤脑筋吧！
			[root@www ~]# dos2unix [-kn] file [newfile] 
			[root@www ~]# unix2dos [-kn] file [newfile] 
			选项与参数： 
				-k ：保留该档案原本的 mtime 时间格式 (不更新档案上次内容经过修订的时间) 
				-n ：保留原本的旧档，将转换后的内容输出到新档案，如： dos2unix -n old new
		语系编码转换
			[root@www ~]# iconv --list 
			[root@www ~]# iconv -f 原本编码 -t 新编码 filename [-o newfile] 
			选项与参数： 
				--list ：列出 iconv 支持的语系数据 
				-f ：from ，亦即来源之意，后接原本的编码格式； 
				-t ：to ，亦即后来的新编码要是什么格式； 
				-o file：如果要保留原本的档案，那么使用 -o 新档名，可以建立新编码档案。
		
		
		
第十一章、认识与学习 BASH		
	认识 BASH 这个 Shell
		硬件、核心与 Shell
			我们必须要透过『 Shell 』将我们输入的指令与 Kernel 沟通，好让 Kernel 可以控制硬件来正确无误的工作
			那么目前我们癿 Linux (以 CentOS 5.x 为例) 有多少我们可以使用的 shells 呢？ 你可以检查一下 /etc/shells 这个档案，至少就有底下这几个可以用的 shells：
				/bin/sh (已经被 /bin/bash 所取代)
				/bin/bash (就是 Linux 预设的 shell)
				/bin/ksh (Kornshell 由 AT&T Bell lab. 发展出来的，兼容于 bash)
				/bin/tcsh (整合 C Shell ，提供更多的功能)
				/bin/csh (已经被 /bin/tcsh 所取代)
				/bin/zsh (基于 ksh 发展出来的，功能更强大的 shell)
			为什么我们系统上合法的 shell 要写入 /etc/shells 这个档案啊？ 这是因为系统某些服务在运作过程中，会去检查使用者能够使用的 shells ，而这些 shell 的查询就是藉由 /etc/shells 这个档案啰！
			当我登入的时候，系统就会给我一个 shell 让我来工作了。 而这个登入叏得癿 shell 就记录在 /etc/passwd 这个档案内！
		Bash shell 的功能
			/bin/bash 是 Linux 预讴癿 shell
			命令编修能力 (history)：
				~/.bash_history 记录的是前一次登入以前所执行过的指令， 而至于这一次登入所执行的指令都被暂存在内存中，当你成功的注销系统后，该指令记忆才会记录到 .bash_history 当中！
			命令与档案补全功能： ([tab] 按键的好处)
				[tab] 这个按键的功能就是在 bash 里头才有的啦！
			命令别名设定功能： (alias)
			工作控制、前景背景控制： (job control, foreground, background)	
			程序化脚本： (shell scripts)
			通配符： (Wildcard)
				除了完整的字符串之外， bash 还支持许多的通配符来帮助用户查询与指令下达。
		Bash shell 的内建命令： type
			为了方便 shell 癿操作，其实 bash 已经『内建』了很多指令了，例如上面提到的 cd ， 还有例如 umask 等等的指令，都是内建在 bash 当中的呢！
			那我怎么知道这个指令是来自于外部指令(指的是其他非 bash 所提供的指令) 或是内建在 bash 当中的呢？ 嘿嘿！利用 type 这个指令来观察即可！举例来说：
			[root@www ~]# type [-tpa] name 
			选项与参数：
				：不加任何选项与参数时，type 会显示出 name 是外部指令还是 bash 内建指令 
				-t ：当加入 -t 参数时，type 会将 name 以底下这些字眼显示出他的意义： 
					file ：表示为外部指令； 
					alias ：表示该指令为命令删名所设定的名称；
					builtin ：表示该指令为 bash 内建的指令功能； 
				-p ：如果后面接的 name 为外部指令时，才会显示完整文件名； 
				-a ：会由 PATH 变量定义的路径中，将所有含 name 的指令都列出来，包含 alias
			由于利用 type 搜寻后面的名称时，如果后面接的名称并不能以执行档的状态被找到， 那么该名称是不会被显示出来的。也就是说， type 主要在找出『执行档』而不是一般档案档名喔！ 呵呵！所以，这个 type 也可以用来作为类似 which 指令的用途啦！找指令用的！		
		指令的下达	
			不过，因为指令太长， 于是鸟哥就利用『 \[Enter] 』来将 [Enter] 这个按键『跳脱！』开来，让 [Enter] 按键不再具有『开始执行』的功能！好让指令可以继续在下一行输入。 需要特别留意， [Enter] 按键是紧接着反斜杠 (\) 的，两者中间没有其他字符。 因为 \ 仅跳脱『紧接着的下一个字符』而已！
	Shell 的变量功能		
		什么是变量
		变量的取用与设定：echo, 变量设定规则, unset	
			变数的取用: echo
				利用 ehco 就能够读出，只是需要在变量名称前面加上 $ ， 或者是以 ${变量} 的方式来取用都可以！
				变量的设定规则
					1. 变量与变量内容以一个等号『=』来连结，如下所示： 『myname=VBird』
					2. 等号两边不能直接接空格符，如下所示为错误： 『myname = VBird』或『myname=VBird Tsai』
					3. 变量名称只能是英文字母与数字，但是开头字符不能是数字，如下为错误： 『2myname=VBird』
					4. 变量内容若有空格符可使用双引号『"』或单引号『'』将发量内容结合起来，但
							双引号内的特殊字符如 $ 等，可以保有原本的特性，如下所示： 『var="lang is $LANG"』则『echo $var』可得『lang is en_US』
							单引号内的特殊字符则仅为一般字符 (纯文本)，如下所示： 『var='lang is $LANG'』则『echo $var』可得『lang is $LANG』
					5. 可用跳脱字符『 \ 』将特殊符号(如 [Enter], $, \, 空格符, '等)变成一般字符；
					6. 在一串指令中，还需要藉由其他的指令提供的信息，可以使用反单引号『`指令`』或 『$(指令)』。特别注意，那个 ` 是键盘上方的数字键 1 左边那个按键，而不是单引号！ 例如想要取得核心版本的设定： 『version=$(uname -r)』再『echo $version』可得『2.6.18-128.el5』
					7. 若该变量为扩增变量内容时，则可用 "$变量名称" 或 ${变量} 累加内容，如下所示： 『PATH="$PATH":/home/bin』
					8. 若该变量需要在其他子程序执行，则需要以 export 来使变量变成环境变量： 『export PATH』
					9. 通常大写字符为系统默认变量，自行设定变量可以使用小写字符，方便判断 (纯粹依照使用者兴趣与嗜好) ；
					10.取消变量的方法为使用 unset ：『unset 变量名称』例如取消 myname 的设定： 『unset myname』
				范例四：呈范例三，我要将 name 的内容多出 "yes" 呢？ 
				[root@www ~]# name=$nameyes 
				# 知道了吧？如果没有双引号，那么变量成了啥？name 的内容是 $nameyes 这个变量！ 
				# 呵呵！我们可没有设定过 nameyes 这个变量吶！所以，应该是底下这样才对！ 
				[root@www ~]# name="$name"yes 
				[root@www ~]# name=${name}yes <==以此例较佳！	
		环境变量的功能
			用 env 观察环境变量与常见环境变量说明
				目前大多数的 distributions 都会有随机数生成器，那就是 /dev/random 这个档案。 我们可以透过这个随机数档案相关的变量 ($RANDOM) 来随机取得随机数值喔。在 BASH 的环境下，这个 RANDOM 变量的内容，介于 0~32767 乊间，所以，你叧要 echo $RANDOM 时，系统就会主劢癿随机叏出一个介于 0~32767 的数值。万一我想要使用 0~9 之间的数值呢？呵呵～利用 declare 宣告数值类型， 然后这样做就可以了： [root@www ~]# declare -i number=$RANDOM*10/32768 ; echo $number 8 <== 此时会随机取出 0~9 之间的数值喔！
			用 set 观察所有变量 (含环境变量与自定义变量)
				bash 可不只有环境变量喔，还有一些与 bash 操作接口有关的变量，以及用户自己定义的变量存在的。 那么这些变量如何观察呢？这个时候就得要使用 set 这个指令了。 set 除了环境发量之外， 还会将其他在 bash 内的变量通通显示出来哩！
				PS1：(提示字符的设定)
					这是 PS1 (数字的 1 不是英文字母)，这个东西就是我们的『命令提示字符』喔！PS1 内显示的是一些特殊符号，这些特殊符号可以显示不同的信息：
						\d ：可显示出『星期 月 日』的日期格式，如："Mon Feb 2"
						\H ：完整的主机名。举例来说，鸟哥的练习机为『www.vbird.tsai』
						\h ：仅取主机名在第一个小数点之前的名字，如鸟哥主机则为『www』后面省略
						\t ：显示时间，为 24 小时格式的『HH:MM:SS』
						\T ：显示时间，为 12 小时格式的『HH:MM:SS』
						\A ：显示时间，为 24 小时格式的『HH:MM』
						\@ ：显示时间，为 12 小时格式的『am/pm』样式
						\u ：目前使用者的账号名称，如『root』；
						\v ：BASH 的版本信息，如鸟哥的测试主板本为 3.2.25(1)，仅取『3.2』显示
						\w ：完整的工作目录名称，由根目录写起的目录名称。但家目录会以 ~ 取代；
						\W ：利用 basename 函数取得工作目录名称，所以仅会列出最后一个目录名。
						\# ：下达的第几个指令。
						\$ ：提示字符，如果是 root 时，提示字符为 # ，否则就是 $ 啰～
				$：(关于本 shell 的 PID)。 想要知道我们的 shell 的 PID ，就可以用：『 echo $$ 』即可！出现的数字就是你的 PID 号码。		
				?：(关亍上个执行指令的回传值) 虾密？问号也是一个特殊的变数？没错！在 bash 里面这个变量可重要的很！ 这个变数是：『上一个执行的指令所回传的值』， 上面这句话的重点是『上一个指令』与『回传值』两个地方。当我们执行某些指令时， 这些指令都会回传一个执行后的代码。一般来说，如果成功的执行该指令， 则会回传一个 0 值，如果执行过程发生错误，就会回传『错误代码』才对！一般就是以非为 0 的数值来取代。
				OSTYPE, HOSTTYPE, MACHTYPE：
					OSTYPE		linux-gnu
					HOSTTYPE	x86_64
					MACHTYPE	x86_64-redhat-linux-gnu
			export： 自定义发量转成环境发量
				所谓的环境变量与自定义变量的差异在于『 该变量是否会被子程序所继续引用』啦！
				当你登入 Linux 并取得一个 bash 之后，你的 bash 就是一个独立的程序，被称为 PID 的就是。 接下来你在这个 bash 底下所下达的任何指令都是由这个 bash 所衍生出来的，那些被下达的指令就被称为子程序了。
				子程序仅会继承父程序的环境变量， 子程序不会继承父程序的自定义变量啦
				export指令将自定义变量转变为环境变量
				如果仅下达 export 而没有接变量时，那么此时将会把所有的『环境发量』秀出来喔！
		影响显示结果的语系变量 (locale)		
			locale -a
				列出linux支持的所有语系
			locale
				列出和语系相关的变量
			基本上，你可以逐一设定每个与语系有关的变量数据，但事实上，如果其他的语系变量都未设定， 且你有设定 LANG 或者是 LC_ALL 时，则其他的语系变量就会被这两个变量所取代！ 这也是为什么我们在 Linux 当中，通常说明仅设定 LANG 这个变量而已，因为他是最主要的设定变量！
			当我们使用 locale 时，系统是列出目前 Linux 主机内保有的语系档案， 这些语系档案都放置在： /usr/lib/locale/ 这个目录中。			
			整体系统默认的语系定义在哪里呢？ 其实就是在 /etc/sysconfig/i18n 啰！
		变量的有效范围
			在学理方面，为什么环境变量的数据可以被子程序所引用呢？这是因为内存配置的关系！理论上是这样的：
				当启动一个 shell，操作系统会分配一记忆区块给 shell 使用，此内存内之变量可让子程序取用
				若在父程序利用 export 功能，可以让自定义变量的内容写到上述的记忆区块当中(环境变量)；
				当加载另一个 shell 时 (亦即启动子程序，而离开原本的父程序了)，子 shell 可以将父 shell 的环境变量所在的记忆区块导入自己的环境变量区块当中。
		变量键盘读取、数组与宣告： read, array, declare
			read
				read [-pt] variable 
				选项与参数： 
					-p ：后面可以接提示字符！ 
					-t ：后面可以接等待的『秒数！』这个比较有趣～不会一直等待使用者啦！
			declare / typeset
				declare 或 typeset 是一样的功能，就是在『宣告变量的类型』。如果使用 declare 后面并没有接任何参数，那么 bash 就会主动的将所有的变量名称与内容通通叨出来，就好像使用 set 一样啦！
				[root@www ~]# declare [-aixr] variable 
				选项与参数： 
					-a ：将后面名为 variable 的发量定义成为数组 (array) 类型 
					-i ：将后面名为 variable 的发量定义成为整数数字 (integer) 类型 
					-x ：用法与 export 一样，就是将后面的 variable 变成环境发量； -r ：将变量设定成为 readonly 类型，该发量不可被更改内容，也不能 unset
				由于在默认的情况底下， bash 对于变量有几个基本的定义：
					变量类型默认为『字符串』，所以若不指定变量类型，则 1+2 为一个『字符串』而不是『计算式』。 所以上述第一个执行的结果才会出现那个情况的；
					bash 环境中的数值运算，预设最多仅能到达整数形态，所以 1/3 结果是 0；
				范例四：让 sum 变成非环境变量的自定义变量吧！ 
				[root@www ~]# declare +x sum <== 将 - 发成 + 可以进行『取消』动作 
				[root@www ~]# declare -p sum <== -p 可以单独列出变量的类型 
				declare -ir sum="450" <== 看吧！只剩下 i, r 的类型，不具有 x 啰！
			数组 (array) 变量类型
				在 bash 里头，数组的设定方式是： var[index]=content
				数组的变量类型比较有趣的地方在于『读取』，一般来说，建议直接以 ${数组} 的方式来读取，比较正确无误的啦！
					[root@www ~]# echo "${var[1]}, ${var[2]}, ${var[3]}" 
					small min, big min, nice min
		与文件系统及程序的限制关系： ulimit
			ulimit [-SHacdfltu] [配额] 
			选项与参数： 
				-H ：hard limit ，严格的设定，必定不能超过这个设定的数值； 
				-S ：soft limit ，警告的设定，可以超过这个设定值，但是若超过则有警告讯息。 在设定上，通常 soft 会比 hard 小，举例来说，soft 可设定为 80 而 hard 设定为 100，那么你可以使用到 90 (因为没有超过 100)，但介于 80~100 之间时， 系统会有警告讯息通知你！ 
				-a ：后面不接任何选项与参数，可列出所有的限制额度； 
				-c ：当某些程序发生错误时，系统可能会将该程序在内存中的信息写成档案(除错用)， 这种档案就被称为核心档案(core file)。此为限制每个核心档案的最大容量。 
				-f ：此 shell 可以建立的最大档案容量(一般可能设定为 2GB)单位为 Kbytes 
				-d ：程序可使用的最大断裂内存(segment)容量； 
				-l ：可用于锁定 (lock) 的内存量 
				-t ：可使用的最大 CPU 时间 (单位为秒) 
				-u ：单一用户可以使用的最大程序(process)数量。
			想要复原 ulimit 的设定最简单的方法就是注销再登入，否则就是得要重新以 ulimit 设定才行！ 不过，要注意的是，一般身份使用者如果以 ulimit 设定了 -f 的档案大小， 那么他『只能继续减小档案容量，不能增加档案容量喔！』
		变量内容的删除、取代与替换
			变量内容的删除与取代
				发量设定方式 						说明 
				${变量#关键词} 
				${变量##关键词} 					若变量内容从头开始的数据符合『关键词』，则将符合的最短数据删除 若变量内容从头开始的数据符合『关键词』，则将符合的最长数据删除 
				${变量%关键词} 
				${变量%%关键词} 					若变量内容从尾向前的数据符合『关键词』，则将符合的最短数据删除 若变量内容从尾向前的数据符合『关键词』，则将符合的最长数据删除 
				${变量/旧字符串/新字符串} 
				${变量//旧字符串/新字符串} 			若变量内容符和『旧字符串』则『第一个旧字符串会被新字符串取代』 若变量内容符合『旧字符串』则『全部的旧字符串会被新字符串取代』
		变量的测试与内容替换
			变量设定方式 			str 没有设定 			str 为空字符串 				str 已设定非为空字符串 
			var=${str-expr} 		var=expr 				var= 						var=$str 
			var=${str:-expr} 		var=expr 				var=expr 					var=$str 
			var=${str+expr} 		var= 					var=expr 					var=expr 
			var=${str:+expr} 		var= 					var= 						var=expr 
			var=${str=expr} 		str=expr 				str 不变					str 不变
									var=expr 				var=	   					var=$str 
			var=${str:=expr} 		str=expr 				str=expr					str 不变
									var=expr 				var=expr  					var=$str 
			var=${str?expr} 		expr 输出至 stderr 		var= 						var=$str 
			var=${str:?expr} 		expr 输出至 stderr 		expr 输出至 stderr 			var=$str
	命令别名与历史命令
		命令别名设定： alias, unalias
			如何知道目前有哪些的命令别名呢？就使用 alias 呀
			举例来说，我们知道 root 可以移除 (rm) 任何数据！所以当你以 root 的身份在进行工作时，需要特别小心， 但是总有失手的时候，那么 rm 提供了一个选项来让我们确认是否要移除该档案，那就是 -i 这个选项！
		历史命令：history
			[root@www ~]# history [n] 
			[root@www ~]# history [-c] 
			[root@www ~]# history [-raw] histfiles 
			选项与参数： 
				n ：数字，意思是『要列出最近的 n 笔命令行表』的意思！ 
				-c ：将目前的 shell 中的所有 history 内容全部消除 
				-a ：将目前新增的 history 指令新增入 histfiles 中，若没有加 histfiles ， 则预设写入 ~/.bash_history 
				-r ：将 histfiles 的内容读到目前这个 shell 的 history 记忆中； 
				-w ：将目前的 history 记忆内容写入 histfiles 中！
			[root@www ~]# !number 
			[root@www ~]# !command 
			[root@www ~]# !! 
			选项与参数： 
				number ：执行第几笔指令的意思； 
				command ：由最近的指令向前搜寻『指令串开头为 command』的那个指令，并执行； 
				!! ：就是执行上一个指令(相当于按向上按键后，按 Enter)
			同一账号同时多次登入的 history 写入问题
				想一想，因为这些 bash 在同时以 root 的身份登入， 因此所有的 bash 都有自己的 1000 笔记录在内存中。因为等到注销时才会更新记录文件，所以啰， 最后注销的那个 bash 才会是最后写入的数据。
	Bash Shell 的操作环境：
		路径与指令搜寻顺序
			基本上，指令运作的顺序可以这样看：
				1. 以相对/绝对路径执行指令，例如『 /bin/ls 』或『 ./ls 』；
				2. 由 alias 找到该指令来执行；
				3. 由 bash 内建的 (builtin) 指令来执行；
				4. 透过 $PATH 这个变量的顺序搜寻到的第一个指令来执行。
			如果想要了解指令搜寻的顺序，其实透过 type -a ls 也可以查询的到啦！
		bash 的进站与欢迎讯息： /etc/issue, /etc/motd
			进站画面在 /etc/issue 里面
			issue 这个档案的内容也是可以使用反斜杠作为变量取用喔！你可以 man issue 配合 man mingetty 得到底下的结果：
				issue 内的各代码意义 
					\d 本地端时间的日期； 
					\l 显示第几个终端机接口； 
					\m 显示硬件的等级 (i386/i486/i586/i686...)； 
					\n 显示主机的网络名称； 
					\o 显示 domain name； 
					\r 操作系统的版本 (相当于 uname -r) 
					\t 显示本地端时间的时间； 
					\s 操作系统的名称； 
					\v 操作系统的版本。
			除了 /etc/issue 之外还有个 /etc/issue.net 呢！这是啥？这个是提供给 telnet 这个进程登录程序用的。 当我们使用 telnet 连接到主机时，主机的登入画面就会显示 /etc/issue.net 而不是 /etc/issue 呢！
			至于如果您想要让使用者登入后取得一些讯息，例如您想要让大家都知道的讯息， 那么可以将讯息加入 /etc/motd 里面去
		bash 的环境配置文件
			login 与 non-login shell
				login shell：取得 bash 时需要完整的登入流程的，就称为 login shell。举例来说，你要由 tty1 ~ tty6 登入，需要输入用户的账号与密码，此时取得的 bash 就称为『 login shell 』啰；
				non-login shell：取得 bash 接口的方法与需要重复登入的举动，举例来说，(1)你以 X window 登入 Linux 后， 再以 X 的图形化接口启动终端机，此时那个终端接口并没有需要再次的输入账号与密码，那个 bash 的环境就称为 non-login shell了。(2)你在原本的 bash 环境下再次下达 bash 这个指令，同样的也没有输入账号密码， 那第二个 bash (子程序) 也是 non-login shell 。
				这两个取得 bash 的情况中，读取的配置文件数据并不一样所致。
				一般来说，login shell 其实只会读取这两个配置文件：
					1. /etc/profile：这是系统整体的设定，你最好不要修改这个档案；
					2. ~/.bash_profile 或 ~/.bash_login 或 ~/.profile：属于使用者个人设定，你要改自己的数据，就写入这里！
			/etc/profile (login shell 才会读)
				你可以使用 vim 去阅读一下这个档案的内容。这个配置文件可以利用使用者的标识符 (UID) 来决定很多重要的变量数据， 这也是每个使用者登入取得 bash 时一定会读取的配置文件！ 所以如果你想要帮所有使用者设定整体环境，那就是改这里啰！不过，没事还是不要随便改这个档案喔 这个档案设定的变量主要有：
					PATH：会依据 UID 决定 PATH 变量要不要含有 sbin 的系统指令目录；
					MAIL：依据账号设定好使用者的 mailbox 到 /var/spool/mail/账号名；
					USER：根据用户的账号设定此一变量内容；
					HOSTNAME：依据主机的 hostname 指令决定此一变量内容；
					HISTSIZE：历史命令记录笔数。CentOS 5.x 设定为 1000 ；
					/etc/profile 可不止会做这些事而已，他还会去呼叫外部的设定数据喔！在 CentOS 5.x 默认的情况下， 底下这些数据会依序的被呼叫进来：
						/etc/inputrc 其实这个档案并没有被执行啦！/etc/profile 会主动的判断使用者有没有自定义输入的按键功能，如果没有的话， /etc/profile 就会决定设定『INPUTRC=/etc/inputrc』这个变量！此一档案内容为 bash 的热键啦、[tab]要不要有声音啦等等的数据！ 因为鸟哥觉得 bash 预设的环境已经很棒了，所以不建议修改这个档案！
						/etc/profile.d/*.sh 其实这是个目录内的众多档案！只要在 /etc/profile.d/ 这个目录内且扩展名为 .sh ，另外，使用者能够具有 r 的权限， 那么该档案就会被 /etc/profile 呼叫进来。在 CentOS 5.x 中，这个目录底下的档案规范了 bash 操作接口的颜色、 语系、ll 与 ls 指令的命令别名、vi 的命令别名、which 的命令别名等等。如果你需要帮所有使用者设定一些共享的命令别名时， 可以在这个目录底下自行建立扩展名为 .sh 的档案，并将所需要的数据写入即可喔！
						/etc/sysconfig/i18n 这个档案是由 /etc/profile.d/lang.sh 呼叫进来的！这也是我们决定 bash 预设使用何种语系的重要配置文件！ 档案里最重要的就是 LANG 这个变量的设定啦！我们在前面的 locale 认识过这个档案啰！
			~/.bash_profile (login shell 才会读)
				bash 在读完了整体环境设定的 /etc/profile 并藉此呼叫其他配置文件后，接下来则是会读取使用者的个人配置文件。 在 login shell 的 bash 环境中，所读取的个人偏好配置文件其实主要有三个，依序分别是：
					1. ~/.bash_profile
					2. ~/.bash_login
					3. ~/.profile
					其实 bash 的 login shell 设定只会读取上面三个档案的其中一个， 而读取的顺序则是依照上面的顺序。
					也就是说，如果 ~/.bash_profile 存在，那么其他两个档案不论有无存在，都不会被读取。
				if [ -f ~/.bashrc ]; then <==底下这三行在判断并读取 ~/.bashrc 
					. ~/.bashrc 
				fi
					该段的内容指的是『判断家目录下的 ~/.bashrc 存在否，若存在则读入 ~/.bashrc 的设定』。 bash 配置文件的读入方式比较有趣，主要是透过一个指令『 source 』来读取的！ 也就是说 ~/.bash_profile 其实会再呼叫 ~/.bashrc 的设定内容喔！
			source ：读入环境配置文件的指令
				利用 source 或小数点 (.) 都可以将配置文件的内容读取道目前的 shell 环境中！
			~/.bashrc (non-login shell 会读)
				当你取得 non-login shell 时，该 bash 配置文件仅会读取 ~/.bashrc 而已啦
				此外，咱们的 CentOS 5.x 还会主动的呼叫 /etc/bashrc 这个档案喔！为什么需要呼叫 /etc/bashrc 呢？ 因为 /etc/bashrc 帮我们的 bash 定义出底下的数据：
					依据不同的 UID 规范出 umask 的值；
					依据不同的 UID 规范出提示字符 (就是 PS1 发量)；
					呼叫 /etc/profile.d/*.sh 的设定
				由于这个 ~/.bashrc 会呼叫 /etc/bashrc 及 /etc/profile.d/*.sh ， 所以，万一你没有 ~/.bashrc (可能自己不小心将他删除了)，那么你会发现你的 bash 提示字符可能会发成这个样子： -bash-3.2$
					不要太担心啦！这是正常的，因为你并没有呼叫 /etc/bashrc 来规范 PS1 变量啦！而且这样的情况也不会影响你的 bash 使用。 如果你想要将命令提示字符捉回来，那么可以复制 /etc/skel/.bashrc 到你的家目录，再修订一下你所想要的内容， 并使用 source 去呼叫 ~/.bashrc ，那你的命令提示字符就会回来啦！
			其他相关配置文件
				/etc/man.config
					这个档案的内容『规范了使用 man 的时候， man page 的路径到哪里去寻找！』
					那么什么时候要来修改这个档案呢？如果你是以 tarball 的方式来安装你的数据，那么你的 man page 可能会放置在 /usr/local/softpackage/man 里头，那个 softpackage 是你的套件名称， 这个时候你就得以手动的方式将该路径加到 /etc/man.config 里头，否则使用 man 的时候就会找不到相关的说明档啰。
					事实上，这个档案内最重要的其实是 MANPATH 这个变量设定啦！ 我们搜寻 man page 时，会依据 MANPATH 的路径去分别搜寻啊！
				~/.bash_logout 
					这个档案则记录了『当我注销 bash 后，系统再帮我做完什么动作后才离开』的意思。 你可以去读取一下这个档案的内容，预设的情况下，注销时， bash 只是帮我们清掉屏幕的讯息而已。 不过，你也可以将一些备份或者是其他你认为重要的工作写在这个档案中 (例如清空暂存盘)， 那么当你离开 Linux 的时候，就可以解决一些烦人的事情啰
			终端机的环境设定： stty, set
				那么如何查阅目前的一些按键内容呢？可以利用 stty (setting tty 终端机的意思) 呢！ stty 也可以帮助设定终端机的输入按键代表意义喔！
				[root@www ~]# stty [-a] 
				选项与参数：
					-a ：将目前所有的 stty 参数列出来； 
				范例一：列出所有的按键与按键内容 
					[root@www ~]# stty -a
				如果你想要用 [ctrl]+h 来进行字符的删除，那么可以下达：
					[root@www ~]# stty erase ^h
				除了 stty 之外，其实我们的 bash 还有自己的一些终端机设定值呢！那就是利用 set 来设定的！ 我们之前提到一些变量时，可以利用 set 来显示，除此之外，其实 set 还可以帮我们设定整个指令输出/输入的环境。 例如记录历史命令、显示错误内容等等。 
				[root@www ~]# set [-uvCHhmBx] 
				选项与参数： 
					-u ：预设不启用。若启用后，当使用未设定变量时，会显示错误讯息； 
					-v ：预设不启用。若启用后，在讯息被输出前，会先显示讯息的原始内容； 
					-x ：预设不启用。若启用后，在指令被执行前，会显示指令内容(前面有 ++ 符号) 
					-h ：预设启用。与历史命令有关； 
					-H ：预设启用。与历史命令有关； 
					-m ：预设启用。与工作管理有关； 
					-B ：预设启用。与刮号 [] 的作用有关； 
					-C ：预设不启用。若使用 > 等，则若档案存在时，该档案不会被覆盖。 
					范例一：显示目前所有的 set 设定值 
					[root@www ~]# echo $- 
					himBH 
					#那个 $- 变量内容就是 set 的所有设定啦！ bash 预设是 himBH 喔！
					范例二：设定 "若使用未定义变量时，则显示错误讯息" 
					[root@www ~]# set -u 
					[root@www ~]# echo $vbirding 
					-bash: vbirding: unbound variable 
					# 预设情况下，未设定/未宣告 的变量都会是『空的』，不过，若设定 -u 参数， 那么当使用未设定的变量时，就会有问题啦！很多的 shell 都预设启用 -u 参数。 # 若要取消这个参数，输入 set +u 即可！ 
					范例三：执行前，显示该指令内容。 
					[root@www ~]# set -x 
					[root@www ~]# echo $HOME 
					+ echo /root 
					/root 
					++ echo -ne '\033]0;root@www:~' 
					# 看见否？要输出的指令都会先被打印到屏幕上喔！前面会多出 + 的符号！
				另外，其实我们还有其他的按键设定功能呢！就是在前一小节提到的 /etc/inputrc 这个档案里面设定。
				还有例如 /etc/DIR_COLORS* 与 /etc/termcap 等，也都是与终端机有关的环境配置文件案呢！
				bash 默认的组合键汇整如下：
					组合按键 				执行结果 
					Ctrl + C 				终止目前的命令 
					Ctrl + D 				输入结束 (EOF)，例如邮件结束的时候； 
					Ctrl + M 				就是 Enter 啦！ 
					Ctrl + S 				暂停屏幕的输出 
					Ctrl + Q 				恢复屏幕的输出 
					Ctrl + U 				在提示字符下，将整列命令删除 
					Ctrl + Z 				『暂停』目前的命令
			通配符与特殊符号
				[^ ]代表反向选择
				bash 环境中的特殊符号：
					符号 		内容 
					# 			批注符号：这个最常被使用在 script 当中，视为说明！在后的数据均不执行 
					\ 			跳脱符号：将『特殊字符或通配符』还原成一般字符 
					| 			管线 (pipe)：分隔两个管线命令的界定(后两节介绍)； 
					; 			连续指令下达分隔符：连续性命令的界定 (注意！与管线命令并不相同) 
					~ 			用户的家目录 
					$ 			取用变数前导符：亦即是变量之前需要加的变量取代值 
					& 			工作控制 (job control)：将指令变成背景下工作 
					! 			逻辑运算意义上的『非』 not 的意思！ 
					/ 			目录符号：路径分隔的符号 
					>, >> 		数据流重导向：输出导向，分别是『取代』与『累加』 
					<, << 		数据流重导向：输入导向 (这两个留待下节介绍) 
					' ' 		单引号，不具有变量置换的功能 
					" " 		具有变量置换的功能！
					` ` 		两个『 ` 』中间为可以先执行的指令，亦可使用 $( ) 
					( ) 		在中间为子 shell 的起始与结束 
					{ } 		在中间为命令区块的组合！
	数据流重导向
		什么是数据流重导向
			数据流重导向可以将 standard output (简称 stdout) 与 standard error output (简称 stderr) 分别传送到其他的档案或装置去，而分别传送所用的特殊字符则如下所示：
				1. 标准输入 (stdin) ：代码为 0 ，使用 < 或 << ；
				2. 标准输出 (stdout)：代码为 1 ，使用 > 或 >> ；
				3. 标准错误输出(stderr)：代码为 2 ，使用 2> 或 2>> ；
			/dev/null 垃圾桶黑洞装置与特殊写法
				这个时候黑洞装置 /dev/null 就很重要了！这个 /dev/null 可以吃掉任何导向这个装置的信息
				范例五：将指令的数据全部写入名为 list 的档案中 
				[dmtsai@www ~]$ find /home -name .bashrc > list 2> list <==错误 
				[dmtsai@www ~]$ find /home -name .bashrc > list 2>&1 <==正确 
				[dmtsai@www ~]$ find /home -name .bashrc &> list <==正确
				上述表格第一行错误的原因是，由亍两股数据同时写入一个档案，又没有使用特殊的语法， 此时两股数据可能会交叉写入该档案内，造成次序的错乱。所以虽然最终 list 档案还是会产生，但是里面的数据排列就会怪怪的，而不是原本屏幕上的输出排序。 至于写入同一个档案的特殊语法如上表所示，你可以使用 2>&1 也可以使用 &> ！ 一般来说，鸟哥比较习惯使用 2>&1 的语法啦！
				理解 < 之后，再来则是怪可怕一把的 << 这个连续两个小于的符号了。 他代表的是『结束的输入字符』的意思！举例来说：『我要用 cat 直接将输入的讯息输出到 catfile 中， 且当由键盘输入 eof 时，该次输入就结束』，那我可以这样做： 
				[root@www ~]# cat > catfile << "eof" 
				> This is a test. 
				> OK now stop 
				> eof <==输入这关键词，立刻就结束而不需要输入 [ctrl]+d 
				[root@www ~]# cat catfile 
				This is a test. 
				OK now stop <==只有这两行，不会存在关键词那一行！
			命令执行的判断依据： ; , &&, ||
				cmd ; cmd (丌考虑挃令相关性癿连续挃令下达)
				$? (挃令回传值) 不 && 戒 ||
					挃令下达情况 说明 cmd1 && cmd2 1. 若 cmd1 执行完毕且正确执行($?=0)，则开始执行 cmd2。 2. 若 cmd1 执行完毕且为错诨 ($?≠0)，则 cmd2 丌执行。 cmd1 || cmd2 1. 若 cmd1 执行完毕且正确执行($?=0)，则 cmd2 丌执行。 2. 若 cmd1 执行完毕且为错诨 ($?≠0)，则开始执行 cmd2。
					Linux 底下癿挃令都是由左往右执行癿
	管线命令 (pipe)
		在每个管线后面接癿第一个数据必定是『挃令』喔！而且这个挃令必须要能够接叐 standard input 癿数据才行，这样癿挃令才可以是为『管线命令』，例如 less, more, head, tail 等都是可以接叐 standard input 癿管线命令啦。至亍例如 ls, cp, mv 等就丌是管线命令了！因为 ls, cp, mv 幵丌会接叐杢自 stdin 癿数据。 也就是说，管线命令主要有两个比较需要注意癿地方：
			管线命令仅会处理 standard output，对亍 standard error output 会予以応略
			管线命令必须要能够接叐杢自前一个挃令癿数据成为 standard input 继续处理才行。
		撷叏命令： cut, grep
			cut
				[root@www ~]# cut -d'分隔字符' -f fields <==用于有特定分隔字符 
				[root@www ~]# cut -c 字符区间 <==用于排列整齐的讯息 
				选项与参数： 
					-d ：后面接分隔字符。与 -f 一起使用； 
					-f ：依据 -d 的分隔字符将一段讯息分割成为数段，用 -f 取出第几段的意思； 
					-c ：以字符 (characters) 的单位取出固定字符区间；
				范例一：将 PATH 变量取出，我要找出第五个路径。
					[root@www ~]# echo $PATH | cut -d ':' -f 5
				范例二：将 export 输出的讯息，取得第 12 字符以后的所有字符串 
				[root@www ~]# export declare -x HISTSIZE="1000"
					如果我们不想要『 declare -x 』时，
						[root@www ~]# export | cut -c 12- HISTSIZE="1000"
				用 last 将显示的登入者的信息中，仅留下用户大名
			grep
				[root@www ~]# grep [-acinv] [--color=auto] '搜寻字符串' filename 
				选项与参数： 
					-a ：将 binary 档案以 text 档案的方式搜寻数据 
					-c ：计算找到 '搜寻字符串' 的次数 
					-i ：忽略大小写的不同，所以大小写视为相同 
					-n ：顺便输出行号 
					-v ：反向选择，亦即显示出没有 '搜寻字符串' 内容的那一行！ 
					--color=auto ：可以将找到的关键词部分加上颜色的显示喔！
		排序命令： sort, wc, uniq	
			sort
				[root@www ~]# sort [-fbMnrtuk] [file or stdin] 
				选项与参数： 
					-f ：忽略大小写的差异，例如 A 与 a 视为编码相同； 
					-b ：忽略最前面的空格符部分； 
					-M ：以月份的名字来排序，例如 JAN, DEC 等等的排序方法； 
					-n ：使用『纯数字』进行排序(默认是以文字型态来排序的)；
					-r ：反向排序； 
					-u ：就是 uniq ，相同的数据中，仅出现一行代表； 
					-t ：分隔符，预设是用 [tab] 键来分隔； 
					-k ：以那个区间 (field) 来进行排序的意思
			uniq
				[root@www ~]# uniq [-ic] 
				选项与参数： 
					-i ：忽略大小写字符的不同； 
					-c ：进行计数
			wc
				[root@www ~]# wc [-lwm] 
				选项与参数： 
					-l ：仅列出行； 
					-w ：仅列出多少字(英文单字)； 
					-m ：多少字符；
		双向重导向： tee
			[root@www ~]# tee [-a] file 
			选项与参数： 
				-a ：以累加 (append) 的方式，将数据加入 file 当中！
			[root@www ~]# last | tee last.list | cut -d " " -f1 
			# 这个范例可以让我们将 last 的输出存一份到 last.list 档案中；
			tee 可以让 standard output 转存一份到档案内并将同样的数据继续送到屏幕去处理！ 这样除了可以让我们同时分析一份数据并记录下来之外，还可以作为处理一份数据的中间暂存盘记录之用！
		字符转换命令： tr, col, join, paste, expand
			tr
				tr 可以用来删除一段讯息当中的文字，或者是进行文字讯息的替换！ 
				[root@www ~]# tr [-ds] SET1 ... 
				选项与参数： 
					-d ：删除讯息当中的 SET1 这个字符串； 
					-s ：取代掉重复的字符！ 
				范例一：将 last 输出的讯息中，所有的小写发成大写字符： [
				root@www ~]# last | tr '[a-z]' '[A-Z]' 
				# 事实上，没有加上单引号也是可以执行的，如：『 last | tr [a-z] [A-Z] 』 
				范例二：将 /etc/passwd 输出的讯息中，将冒号 (:) 删除 
				[root@www ~]# cat /etc/passwd | tr -d ':'
			col
				col [root@www ~]# col [-xb] 
				选项与参数： 
					-x ：将 tab 键转换成对等的空格键 
					-b ：在文字内有反斜杠 (/) 时，仅保留反斜杠最后接的那个字符 
				范例一：利用 cat -A 显示出所有特殊按键，最后以 col 将 [tab] 转成空白 
				[root@www ~]# cat -A /etc/man.config <==此时会看到很多 ^I 的符号，那就是 tab 
				[root@www ~]# cat /etc/man.config | col -x | cat -A | more 
				# 嘿嘿！如此一来， [tab] 按键会被取代成为空格键，输出就美观多了！
			join
				[root@www ~]# join [-ti12] file1 file2 
				选项与参数： 
					-t ：join 默认以空格符分隔数据，并且比对『第一个字段』的数据， 如果两个档案相同，则将两笔数据联成一行，且第一个字段放在第一个！ 
					-i ：忽略大小写的差异； 
					-1 ：这个是数字的 1 ，代表『第一个档案要用哪个字段来分析』的意思； 
					-2 ：代表『第二个档案要用哪个字段来 分析』的意思。
				[root@www ~]# join -t ':' -1 4 /etc/passwd -2 3 /etc/group
			paste
				这个 paste 就要比 join 简单多了！相对于 join 必须要比对两个档案的数据相关性， paste 就直接『将两行贴在一起，且中间以 [tab] 键隔开』而已！简单的使用方法：
				[root@www ~]# paste [-d] file1 file2 
				选项与参数： 
					-d ：后面可以接分隔字符。预设是以 [tab] 来分隔的！ 
					- ：如果 file 部分写成 - ，表示来自 standard input 的资料的意思。
			expand
				这玩意儿就是在将 [tab] 按键转成空格键啦～
				[root@www ~]# expand [-t] file 
				选项与参数： 
					-t ：后面可以接数字。一般来说，一个 tab 按键可以用 8 个空格键取代。 我们也可以自行定义一个 [tab] 按键代表多少个字符呢！
		分割命令： split
			他可以帮你将一个大档案，依据档案大小或行数来分割，就可以将大档案分割成为小档案了！
			[root@www ~]# split [-bl] file PREFIX 
			选项与参数： 
				-b ：后面可接欲分割成的档案大小，可加单位，例如 b, k, m 等； 
				-l ：以行数来进行分割。 
				PREFIX ：代表前导符的意思，可作为分割档案的前导文字。
		参数代换： xargs
			这个玩意儿就是在产生某个指令的参数的意思！ xargs 可以读入 stdin 的数据，并且以空格符或断行字符作为分辨，将 stdin 的资料分隔成为 arguments 。 因为是以空格符作为分隔，所以，如果有一些档名或者是其他意义的名词内含有空格符的时候， xargs 可能就会误判了
			[root@www ~]# xargs [-0epn] command 
			选项与参数： 
				-0 ：如果输入的 stdin 含有特殊字符，例如 `, \, 空格键等等字符时，这个 -0 参数 可以将他还原成一般字符。这个参数可以用于特殊状态喔！ 
				-e ：这个是 EOF (end of file) 的意思。后面可以接一个字符串，当 xargs 分析到 这个字符串时，就会停止继续工作！ 
				-p ：在执行每个指令的 argument 时，都会询问使用者的意思； 
				-n ：后面接次数，每次 command 指令执行时，要使用几个参数的意思。看范例三。 当 xargs 后面没有接任何的指令时，默认是以 echo 来进行输出喔！
			范例四：同上，但是当分析到 lp 就结束这串指令？ 
			[root@www ~]# cut -d':' -f1 /etc/passwd | xargs -p -e'lp' finger
			注意，那个 -e'lp' 是连在一起的，中间没有空格键。
			很多指令其实并不支持管线命令，因此我们可以透过 xargs 来提供该指令引用 standard input 之用
		关于减号 - 的用途
			在管线命令当中，常常会使用到前一个指令的 stdout 作为这次的 stdin ， 某些指令需要用到文件名 (例如 tar) 来进行处理时，该 stdin 与 stdout 可以利用减号 "-" 来替代
			举例来说： [root@www ~]# tar -cvf - /home | tar -xvf -
	重点回顾
		系统合法的 shell 均写在 /etc/shells 档案中；
		用户默认登入取得的 shell 记录于 /etc/passwd 的最后一个字段；
		使用 env 与 export 可观察环境变量，其中 export 可以将自定义变量转成环境变量；
		set 可以观察目前 bash 环境下的所有变量；
		可用 read 让用户由键盘输入变量的值
		bash 的配置文件主要分为 login shell 与 non-login shell。login shell 主要读取 /etc/profile 与 ~/.bash_profile， non-login shell 则仅读取 ~/.bashrc
		在这样的练习中『A=B』且『B=C』，若我下达『unset $A』，则取消的变数是 A 还是 B？被取消的是 B 喔，因为 unset $A 相当于 unset B 所以取消的是 B ，A 会继续存在！
		我想要让终端机接口的登入提示字符修改成我自己喜好的模样，应该要改哪里？(filename)
			/etc/issue
		如果我是想要让使用者登入后，才显示欢迎讯息，又应该要改哪里？
			/etc/motd
		
		
第十二章、正规表示法与文件格式化处理
	正规表示法并不是一个工具程序， 而是一个字符串处理的标准依据，如果您想要以正规表示法的方式处理字符串，就得要使用支持正规表示法的工具程序才行， 这类的工具程序很多，例如 vi, sed, awk 等等。
	前言：什么是正规表示法
		什么是正规表示法
			正规表示法就是处理字符串的方法，他是以行为单位来进行字符串的处理行为
	基础正规表示法
		既然正规表示法是处理字符串的一种表示方式，那么对字符排序有影响的语系数据就会对正规表示法的结果有影响！
		语系对正规表示法的影响
			由于不同语系的编码数据并不相同，所以就会造成数据撷取结果的差异了
			为了要避免这样编码所造成的英文与数字的撷取问题，因此有些特殊的符号我们得要了解一下的！ 这些符号主要有底下这些意义：
			特殊符号 		代表意义 
			[:alnum:] 		代表英文大小写字符及数字，亦即 0-9, A-Z, a-z 
			[:alpha:]   	代表任何英文大小写字符，亦即 A-Z, a-z 
			[:blank:] 		代表空格键与 [Tab] 按键两者 
			[:cntrl:] 		代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del.. 等等 
			[:digit:] 		代表数字而已，亦即 0-9 
			[:graph:] 		除了空格符 (空格键与 [Tab] 按键) 外的其他所有按键 
			[:lower:] 		代表小写字符，亦即 a-z 
			[:print:] 		代表任何可以被打印出来的字符 
			[:punct:] 		代表标点符号 (punctuation symbol)，亦即：" ' ? ! ; : # $... 
			[:upper:] 		代表大写字符，亦即 A-Z 
			[:space:] 		任何会产生空白的字符，包括空格键, [Tab], CR 等等 
			[:xdigit:] 		代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字符
		grep 的一些进阶选项
			[root@www ~]# grep [-A] [-B] [--color=auto] '搜寻字符串' filename 
			选项与参数： 
				-A ：后面可加数字，为 after 的意思，除了列出该行（关键字所在的行）外，后续的 n 行也列出来； 
				-B ：后面可加数字，为 befer 癿意思，除了列出该行（关键字所在的行）外，前面的 n 行也列出来； 
				--color=auto 可将正确的那个撷取数据列出颜色
			需要说明的是『grep 在数据中查寻一个字符串时，是以 "整行" 为单位来进行数据的撷取的！』也就是说，假如一个档案内有 10 行，其中有两行具有你所搜寻的字符串，则将那两行显示在屏幕上，其他的就丢弃了！
		基础正规表示法练习
			考虑到语系对于编码顺序的影响，因此除了连续编码使用减号『 - 』之外， 你也可以使用如下的方法来取得前面两个测试的结果： 
				[root@www ~]# grep -n '[^[:lower:]]oo' regular_express.txt 
				# 那个 [:lower:] 代表的就是 a-z 的意思！请参考前两小节的说明表格 
				[root@www ~]# grep -n '[[:digit:]]' regular_express.txt
			如果我想要找出来，哪一行是『空白行』， 也就是说，该行并没有输入任何数据，该如何搜寻？
				[root@www ~]# grep -n '^$' regular_express.txt
			我们知道通配符 * 可以用来代表任意(0或多个)字符， 但是正规表示法并不是通配符，两者之间是不相同的！ 至于正规表示法当中的『 . 』则代表『绝对有一个任意字符』的意思！这两个符号在正规表示法的意义如下：
				. (小数点)：代表『一定有一个任意字符』的意思；
				* (星星号)：代表『重复前一个 0 到无穷多次』的意思，为组合形态
			通配符与正则表达式是不同的：
				举例来说，不支持正规表示法的 ls 这个工具中，若我们使用 『ls -l * 』 代表的是任意档名的档案，而 『ls -l a* 』代表的是以 a 为开头的任何档名的档案， 但在正规表示法中，我们要找到含有以 a 为开头的档案，则必须要这样：(需搭配支持正规表示法的工具) ls | grep -n '^a.*'
		sed 工具
			sed 本身也是一个管线命令，可以分析 standard input 的啦！ 而且 sed 还可以将数据进行取代、删除、新增、撷取特定行等等的功能呢
			[root@www ~]# sed [-nefr] [动作] 
			选项与参数： 
				-n ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到屏幕上。但如果加上 -n 参数后，则只有经过 sed 特殊处理的那一行(或者动作)才会被列出来。 
				-e ：直接在指令列模式上进行 sed 的动作编辑； 
				-f ：直接将 sed 的动作写在一个档案内， 
				-f filename 则可以执行 filename 内的 sed 动作； 
				-r ：sed 的动作支持的是延伸型正规表示法的语法。(预设是基础正规表示法语法) 
				-i ：直接修改读取得档案内容，而不是由屏幕输出。 
				动作说明： [n1[,n2]]function n1, n2 ：不见得会存在，一般代表『选择进行动作的行数』，举例来说，如果我的动作 是需要在 10 到 20 行之间进行的，则『 10,20[动作行为] 』 
					function 有底下这些咚咚： 
						a ：新增， a 的后面可以接字符串，而这些字符串会在新的一行出现(目前的下一行)～ 
						c ：取代， c 的后面可以接字符串，这些字符串可以取代 n1,n2 之间的行！ 
						d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚； 
						i ：插入， i 的后面可以接字符串，而这些字符串会在新的一行出现(目前的上一行)； 
						p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运作～ 
						s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配 正规表示法！例如 1,20s/old/new/g 就是啦！
				以行为单位的新增/删除功能
					范例一：将 /etc/passwd 的内容列出并且打印行号，同时，请将第 2~5 行删除！ [root@www ~]# nl /etc/passwd | sed '2,5d'
					范例二：承上题，在第二行后(亦即是加在第三行)加上『drink tea?』字样！ [root@www ~]# nl /etc/passwd | sed '2a drink tea'
				以行为单位的取代与显示功能
					范例四：我想将第2-5行的内容取代成为『No 2-5 number』呢？ [root@www ~]# nl /etc/passwd | sed '2,5c No 2-5 number'
					范例五：仅列出 /etc/passwd 档案内的第 5-7 行 [root@www ~]# nl /etc/passwd | sed -n '5,7p'
				部分数据的搜寻并取代的功能
					sed 's/要被取代的字符串/新的字符串/g'
				直接修改档案内容(危险动作)
					[root@www ~]# sed -i 's/\.$/\!/g' regular_express.txt # 上头的 -i 选项可以让你的 sed 直接去修改后面接的档案内容而不是由屏幕输出喔！
				范例三：在第二行后面加入两行字，例如『Drink tea or .....』与『drink beer?』 
					[root@www ~]# nl /etc/passwd | sed '2a Drink tea or ......
					\ > drink beer ?' 
					1 root:x:0:0:root:/root:/bin/bash 
					2 bin:x:1:1:bin:/bin:/sbin/nologin Drink tea or ...... 
					drink beer ? 
					3 daemon:x:2:2:daemon:/sbin:/sbin/nologin .....
					(后面省略).....
	延伸正规表示法
		grep 预设仅支持基础正规表示法，如果要使用延伸型正规表示法，你可以使用 grep -E ， 不过更建议直接使用 egrep ！直接区分指令比较好记忆！其实 egrep 与 grep -E 是类似命令别名的关系啦！
		延伸型的正规表示法，你应该也会想到，不就是多几个重要的特殊符号
			RE 字符			意义与范例
			+				意义：重复『一个或一个以上』地前一个 RE 字符
			?				意义：『零个或一个』的前一个 RE 字符
			|				意义：用或( or )的方式找出数个字符串
			()				意义：找出『群组』字符串
			()+				意义：多个重复群组的判别
	文件的格式化与相关处理
		格式化打印： printf
			[root@www ~]# printf '打印格式' 实际内容 
			选项与参数： 
				关于格式方面的几个特殊样式： 
					\a 警告声音输出 
					\b 退格键(backspace) 
					\f 清除屏幕 (form feed) 
					\n 输出新的一行 
					\r 亦即 Enter 按键 
					\t 水平的 [tab] 按键 
					\v 垂直的 [tab] 按键 
					\xNN NN 为两位数的数字，可以转换数字成为字符。 
					关于 C 程序语言内，常见的变数格式 
						%ns 那个 n 是数字， s 代表 string ，亦即多少个字符； 
						%ni 那个 n 是数字， i 代表 integer ，亦即多少整数字数； 
						%N.nf 那个 n 与 N 都是数字， f 代表 floating (浮点)，如果有小数字数， 假设我共要十个位数，但小数点有两位，即为 %10.2f 啰！
		awk：好用的数据处理工具
			awk 也是一个非常棒的数据处理工具！相较于 sed 常常作用于一整个行的处理， awk 则比较倾向于一行当中分成数个『字段』来处理。因此，awk 相当的适合处理小型的数据数据处理呢！
			awk 通常运作的模式是这样的： 
				[root@www ~]# awk '条件类型1{动作1} 条件类型2{动作2} ...' filename
			awk 后面接两个单引号并加上大括号 {} 来设定想要对数据进行的处理动作。 awk 可以处理后续接的档案，也可以读取来自前个指令的 standard output 。 但如前面说的， awk 主要是处理『每一行的字段内的数据』，而默认的『字段的分隔符为 "空格键" 或 "[tab]键" 』！
			整个 awk 的处理流程是：
			1. 读入第一行，并将第一行的资料填入 $0, $1, $2.... 等变数当中；
			2. 依据 "条件类型" 的限制，判断是否需要进行后面的 "动作"；
			3. 做完所有的动作与条件类型；
			4. 若还有后续的『行』的数据，则重复上面 1~3 的步骤，直到所有的数据都读完为止。
			经过这样的步骤，你会晓得， awk 是『以行为一次处理的单位』， 而『以字段为最小的处理单位』。好了，那么 awk 怎么知道我到底这个数据有几行？有几栏呢？这就需要 awk 的内建变量的帮忙啦～ 
				变量名称 		代表意义 
				NF 				每一行 ($0) 拥有的字段总数 
				NR 				目前 awk 所处理的是『第几行』数据 
				FS 				目前的分隔字符，默认是空格键
			要注意喔，awk 后续的所有动作是以单引号『 ' 』括住的，由于单引号与双引号都必须是成对的， 所以， awk 的格式内容如果想要以 print 打印时，记得非变量的文字部分，包含上一小节 printf 提到的格式中，都需要使用双引号来定义出来喔！因为单引号已经是 awk 的指令固定用法了！ 
				[root@www ~]# last -n 5| awk '{print $1 "\t lines: " NR "\t columes: " NF}' 
					root lines: 1 columes: 10
			举例来说，在 /etc/passwd 当中是以冒号 ":" 来作为字段的分隔， 该档案中第一字段为账号，第三字段则是 UID。那假设我要查阅，第三栏小于 10 以下的数据，并且仅列出账号与第三栏， 那么可以这样做： 
				[root@www ~]# cat /etc/passwd | \ > awk '{FS=":"} $3 < 10 {print $1 "\t " $3}' 
					root:x:0:0:root:/root:/bin/bash bin 1 daemon 2 ....
					(以下省略)....
			有趣吧！不过，怎么第一行没有正确的显示出来呢？这是因为我们读入第一行的时候，那些变数 $1, $2... 默认还是以空格键为分隔的，所以虽然我们定义了 FS=":" 了， 但是即仅能在第二行后才开始生效。那么怎么办呢？我们可以预先设定 awk 的变量啊！ 利用 BEGIN 这个关键词喔！这样做： 
				[root@www ~]# cat /etc/passwd | \ > awk 'BEGIN {FS=":"} $3 < 10 {print $1 "\t " $3}' 
					root 0 bin 1 daemon 2 ......
					(以下省略)......
			很有趣吧！而除了 BEGIN 之外，我们还有 END 呢！
		档案比对工具
			那么比对档案的指令有哪些？最常见的就是 diff 啰！ 另外，除了 diff 比对之外，我们还可以藉由 cmp 来比对非纯文本档！同时，也能够藉由 diff 建立的分析檔， 以处理补丁 (patch) 功能的档案呢！
			diff
				diff 就是用在比对两个档案之间的差异的，并且是以行为单位来比对的！一般是用在 ASCII 纯文本档的比对上。 由于是以行为比对的单位，因此 diff 通常是用在同一的档案(或软件)的新旧版本差异上！
					[root@www ~]# diff [-bBi] from-file to-file 
					选项与参数： 
						from-file ：一个档名，作为原始比对档案的档名； 
						to-file ：一个档名，作为目的比对档案的档名； 注意，from-file 或 to-file 可以 - 取代，那个 - 代表『Standard input』之意。 
						-b ：忽略一行当中，仅有多个空白的差异(例如 "about me" 与 "about me" 视为相同 
						-B ：忽略空白行的差异。 
						-i ：忽略大小写的不同。
				另外， diff 也可以比对整个目录下的差异喔！
			cmp
				cmp 主要也是在比对两个档案，他主要利用『字节』单位去比对， 因此，当然也可以比对 binary file 啰～(还是要再提醒喔， diff 主要是以『行』为单位比对， cmp 则是以『字节』为单位去比对，这并不相同！)
				[root@www ~]# cmp [-s] file1 file2 
				选项与参数： 
					-s ：将所有的不同点的字节处都列出来。因为 cmp 预设仅会输出第一个出现的不同点。
			patch
				[root@www ~]# patch -pN < patch_file <==更新 
				[root@www ~]# patch -R -pN < patch_file <==还原 
				选项与参数： 
					-p ：后面可以接『取消几层目录』的意思。 
					-R ：代表还原，将新的文件还原成原来旧的版本。
				一般来说，使用 diff 制作出来的比较档案通常使用扩展名为 .patch 啰。至于内容就如同上面介绍的样子。 基本上就是以行为单位，看看哪边有一样与不一样的，找到一样的地方，然后将不一样的地方取代掉！ 以上面表格为例，新档案看到 - 会删除，看到 + 会加入！
			档案打印准备： pr
				[root@www ~]# pr /etc/man.config 
				2007-01-06 18:24 /etc/man.config Page 1
				上面特殊字体那一行呢，其实就是使用 pr 处理后所造成的标题啦！标题中会有『档案时间』、『档案档名』及『页码』三大项目。
	重点回顾
		正规表示法与通配符是完全不一样的东西！通配符 (wildcard) 代表的是 bash 操作接口的一个功能， 但正规表示法则是一种字符串处理的表示方式！
		由于编码系统的不同，不同的语系 (LANG) 会造成正规表示法撷取资料的差异。因此可利用特殊符号如 [:upper:] 来替代编码范围较佳；
		
		
第十三章、学习 Shell Scripts		
	什么是 Shell scripts
		shell script 更提供数组、循环、条件与逻辑判断等重要功能，让用户也可以直接以 shell 来撰写程序，而不必使用类似 C 程序语言等传统程序撰写的语法呢！
		干嘛学习 shell scripts
			shell script 处理数据的速度上是不太够的。因为 shell script 用的是外部的指令与 bash shell 的一些默认工具，所以，他常常会去呼叫外部的函式库，因此，指令周期上面当然比不上传统的程序语言。 所以啰， shell script 用在系统管理上面是很好的一项工具，但是用在处理大量数值运算上， 就不够好了
		第一支 script 的撰写与执行
			在 shell script 的撰写中还需要用到底下的注意事项：
				1. 指令的执行是从上而下、从左而右的分析与执行；
				2. 指令的下达就如同第五章内提到的： 指令、选项与参数间的多个空白都会被忽略掉；
				3. 空白行也将被忽略掉，并且 [tab] 按键所推开的空白同样规为空格键；
				4. 如果读取到一个 Enter 符号 (CR) ，就尝试开始执行该行 (或该串) 命令；
				5. 至于如果一行的内容太多，则可以使用『 \[Enter] 』来延伸至下一行；
				6. 『 # 』可做为批注！任何加在 # 后面的资料将全部被视为批注文字而被忽略！
			现在我们假设你写的这个程序文件名是 /home/dmtsai/shell.sh 好了，那如何执行这个档案？很简单，可以有底下几个方法：
				直接指令下达： shell.sh 档案必须要具备可读与可执行 (rx) 的权限，然后：
					绝对路径：使用 /home/dmtsai/shell.sh 来下达指令；
					相对路径：假设工作目录在 /home/dmtsai/ ，则使用 ./shell.sh 来执行
					变量『PATH』功能：将 shell.sh 放在 PATH 指定的目录内，例如： ~/bin/
				以 bash 程序来执行：透过『 bash shell.sh 』或『 sh shell.sh 』来执行
			那为何『 sh shell.sh 』也可以执行呢？这是因为 /bin/sh 其实就是 /bin/bash (连结档)，使用 sh shell.sh 亦即告诉系统，我想要直接以 bash 的功能来执行 shell.sh 这个档案内的相关指令的意思，所以此时你的 shell.sh 只要有 r 的权限即可被执行喔！而我们也可以利用 sh 的参数，如 -n 及 -x 来检查与追踪 shell.sh 的语法是否正确呢
			撰写第一支 script
				第一行 #!/bin/bash 在宣告这个 script 使用的 shell 名称： 因为我们使用的是 bash ，所以，必须要以『 #!/bin/bash 』来宣告这个档案内的语法使用 bash 的语法！那么当这个程序被执行时，他就能够加载 bash 的相关环境配置文件 (一般来说就是 non-login shell 的 ~/.bashrc)， 并且执行 bash 来使我们底下的指令能够执行
	简单的 shell script 练习		
		对谈式脚本：变量内容由用户决定
			read -p "Please input your first name: " firstname 
			# 提示使用者输入 
			read -p "Please input your last name: " lastname 
			# 提示使用者输入 
			echo -e "\nYour full name is: $firstname $lastname" 
			# 结果由屏幕输出
		数值运算：简单的加减乘除
			当变量定义成为整数后才能够进行加减运算啊！此外，我们也可以利用『 $((计算式)) 』来进行数值运算的。
				declare -i total=$firstnu*$secnu相当于total=$(($firstnu*$secnu))
		script 的执行方式差异 (source, sh script, ./script)
			利用直接执行的方式来执行 script
				直接指令下达 (不论是绝对路径/相对路径还是 $PATH 内)，或者是利用 bash (或 sh) 来下达脚本时， 该 script 都会使用一个新的 bash 环境来执行脚本内的指令！也就是说，使用这种执行方式时， 其实 script 是在子程序的 bash 内执行的！重点在于：『当子程序完成后，在子程序内的各项变量或动作将会结束而不会传回到父程序中』
			利用 source 来执行脚本：在父程序中执行
				在父程序中执行, 这也是为啥你不注销系统而要让某些写入 ~/.bashrc 的设定生效时，需要使用『 source ~/.bashrc 』而不能使用『 bash ~/.bashrc 』是一样的啊！
	善用判断式
		利用 test 指令的测试功能
			测试的标志 			代表意义 
			1. 关于某个档名的『文件类型』判断，如 test -e filename 表示存在否 
			-e 					该『档名』是否存在？(常用) 
			-f 					该『档名』是否存在且为档案(file)？(常用) 
			-d 					该『文件名』是否存在且为目录(directory)？(常用)
			-b	 				该『档名』是否存在且为一个 block device 装置？ 
			-c 					该『档名』是否存在且为一个 character device 装置？ 
			-S 					该『档名』是否存在且为一个 Socket 档案？ 
			-p 					该『档名』是否存在且为一个 FIFO (pipe) 档案？ 
			-L 					该『档名』是否存在且为一个连结档？ 
			2. 关于档案的权限侦测，如 test -r filename 表示可读否 (但 root 权限常有例外) 
			-r 					侦测该档名是否存在且具有『可读』的权限？ 
			-w 					侦测该档名是否存在且具有『可写』的权限？ 
			-x 					侦测该档名是否存在且具有『可执行』的权限？ 
			-u 					侦测该文件名是否存在且具有『SUID』的属性？ 
			-g 					侦测该文件名是否存在且具有『SGID』的属性？ 
			-k 					侦测该文件名是否存在且具有『Sticky bit』的属性？ 
			-s 					侦测该档名是否存在且为『非空白档案』？ 
			3. 两个档案之间的比较，如： test file1 -nt file2 
			-nt (newer than)	判断 file1 是否比 file2 新 
			-ot (older than)	判断 file1 是否比 file2 旧 
			-ef 				判断 file1 与 file2 是否为同一档案，可用在判断 hard link 的判定上。 主要意义在判定，两个档案是否均指向同一个 inode 哩！ 
			4. 关于两个整数之间的判定，例如 test n1 -eq n2 
			-eq 				两数值相等 (equal) 
			-ne 				两数值不等 (not equal) 
			-gt 				n1 大于 n2 (greater than) 
			-lt 				n1 小于 n2 (less than) 
			-ge 				n1 大于等亍 n2 (greater than or equal) 
			-le 				n1 小于等亍 n2 (less than or equal) 
			5. 判定字符串的数据 
			test -z string 		判定字符串是否为 0 ？若 string 为空字符串，则为 true 
			test -n string 		判定字符串是否非为 0 ？若 string 为空字符串，则为 false。 注： -n 亦可省略 
			test str1 = str2 	判定 str1 是否等于 str2 ，若相等，则回传 true 
			test str1 != str2 	判定 str1 是否不等亍 str2 ，若相等，则回传 false 
			6. 多重条件判定，例如： test -r filename -a -x filename 
			-a (and)			两状况同时成立！例如 test -r file -a -x file，则 file 同时具有 r 与 x 权限时，才回传 true。 
			-o (or)				两状况任何一个成立！例如 test -r file -o -x file，则 file 具有 r 或 x 权限时，就可回传 true。 
			! 					反相状态，如 test ! -x file ，当 file 不具有 x 时，回传 true
		利用判断符号 [ ]
			除了我们很喜欢使用的 test 之外，其实，我们还可以利用判断符号『 [ ] 』(就是中括号啦) 来进行数据的判断呢！ 举例来说，如果我想要知道 $HOME 这个变量是否为空的，可以这样做： [root@www ~]# [ -z "$HOME" ] ; echo $?
			使用中括号必须要特别注意，因为中括号用在很多地方，包括通配符与正规表示法等等，所以如果要在 bash 的语法当中使用中括号作为 shell 的判断式时，必须要注意中括号的两端需要有空格符来分隔喔！ 假设我空格键使用『□』符号来表示，那么，在这些地方你都需要有空格键： 
				[ "$HOME" == "$MAIL" ]
				[□"$HOME"□==□"$MAIL"□]
			上面的例子在说明，两个字符串 $HOME 与 $MAIL 是否相同的意思，相当于 test $HOME = $MAIL 的意思啦！ 而如果没有空白分隔，例如 [$HOME==$MAIL] 时，我们的 bash 就会显示错误讯息了！这可要很注意啊！ 所以说，你最好要注意：
				在中括号 [] 内的每个组件都需要有空格键来分隔；
				在中括号内的变数，最好都以双引号括号起来；
				在中括号内的常数，最好都以单或双引号括号起来。
			为什么要这么麻烦啊？直接举例来说，假如我设定了 name="VBird Tsai" ，然后这样判定： 
				[root@www ~]# name="VBird Tsai" 
				[root@www ~]# [ $name == "VBird" ] 
				bash: [: too many arguments
			见鬼了！怎举会发生错误啊？bash 还跟我说错误是由于『太多参数 (arguments)』所致！ 为什么呢？因为 $name 如果没有使用双引号括起来，那么上面的判定式会变成： [ VBird Tsai == "VBird" ]
		Shell script 的默认变数($0, $1...)
			执行的脚本档名为 $0 这个发量，第一个接的参数就是 $1 啊～ 所以，只要我们在 script 里面善用 $1 的话，就可以很简单的立即下达某些指令功能了！除了这些数字的变量之外， 我们还有一些较为特殊的变量可以在 script 内使用来呼叫这些参数喔！
				$# ：代表后接的参数『个数』，以上表为例这里显示为『 4 』；
				$@ ：代表『 "$1" "$2" "$3" "$4" 』之意，每个变量是独立的(用双引号括起来)；
				$* ：代表『 "$1c$2c$3c$4" 』，其中 c 为分隔字符，默认为空格键， 所以本例中代表『 "$1 $2 $3 $4" 』之意。
				那个 $@ 与 $* 基本上还是有所不同啦！
			shift：造成参数变量号码偏移
				那个 shift 会移动变量，而且 shift 后面可以接数字，代表拿掉最前面的几个参数的意思。
	条件判断式
		利用 if .... then
			单层、简单条件判断式
				如果你只有一个判断式要进行，那么我们可以简单的这样看： 
					if [ 条件判断式 ]; then 
						当条件判断式成立时，可以进行的指令工作内容； 
					fi <==将 if 反过来写，就成为 fi 啦！结束 if 之意！
				至于条件判断式的判断方法，与前一小节的介绍相同啊！较特别的是，如果我有多个条件要判别时， 除了 sh06.sh 那个案例所写的，也就是『将多个条件写入一个中括号内的情况』之外， 我还可以有多个中括号来隔开喔！而括号与括号之间，则以 && 或 || 来隔开
			多重、复杂条件判断式
				# 多个条件判断 (if ... elif ... elif ... else) 分多种不同情况执行 
					if [ 条件判断式一 ]; then 
						当条件判断式一成立时，可以进行的指令工作内容； 
					elif [ 条件判断式二 ]; then 
						当条件判断式二成立时，可以进行的指令工作内容；
					else 当条件判断式一与二均不成立时，可以进行的指令工作内容； 
					fi
		刟用case ..... esac 判断
				case $变量名称 in <==关键词为 case ，还有变数前有钱字号 
					"第一个变量内容") <==每个变量内容建议用双引号括起来，关键词则为小括号 ) 
						程序段 ;; <==每个类别结尾使用两个连续的分号来处理！ 
					"第二个变量内容") 
						程序段 ;; 
					*) <==最后一个变量内容都会用 * 来代表所有其他值 
						不包含第一个变量内容与第二个变量内容的其他程序执行段 
						exit 1 ;; 
				esac <==最终的 case 结尾！『反过来写』思考一下！
				一般来说，使用『 case $变量 in 』这个语法中，当中的那个『 $变量 』大致有两种取得的方式：
					直接下达式：例如上面提到的，利用『 script.sh variable 』 的方式来直接给予 $1 这个变量的内容，这也是在 /etc/init.d 目录下大多数程序的设计方式。
					交互式：透过 read 这个指令来让用户输入变量的内容。
		利用 function 功能
			function 的语法是这样的： function fname() { 程序段 }
			因为 shell script 的执行方式是由上而下，由左而右， 因此在 shell script 当中的 function 的设定一定要在程序的最前面， 这样才能够在执行时被找到可用的程序段喔
			function 也是拥有内建变量的～他的内建变量与 shell script 很类似， 函数名称代表示 $0 ，而后续接的变量也是以 $1, $2... 来取代的～ 这里很容易搞错喔～因为『 function fname() { 程序段 } 』内的 $0, $1... 等等与 shell script 的 $0 是不同的。
	循环 (loop)
		while do done, until do done (不定循环)
			一般来说，不定循环最常见的就是底下这两种状态了： 
				while [ condition ] <==中括号内的状态就是判断式 
				do <==do 是循环的开始！ 
					程序段落 
				done <==done 是循环的结束
			until [ condition ] 
			do 
				程序段落 
			done
		for...do...done (固定循环)
			for var in con1 con2 con3 ... 
			do 
				程序段 
			done
			seq 是连续 (sequence) 的缩写之意！代表后面接的两个数值是一直连续的！ 如此一来，就能够轻松的将连续数字带入程序中啰!如:for sitenu in $(seq 1 100)
		for...do...done 的数值处理
			for (( 初始值; 限制值; 执行步阶 )) 
			do 
				程序段 
			done
	shell script 的追踪与 debug
		[root@www ~]# sh [-nvx] scripts.sh 
		选项与参数： 
			-n ：不要执行 script，仅查询语法的问题； 
			-v ：再执行 sccript 前，先将 scripts 的内容输出到屏幕上； 
			-x ：将使用到的 script 内容显示到屏幕上，这是很有用的参数！
	重点回顾
		shell script 是利用 shell 的功能所写的一个『程序 (program)』，这个程序是使用纯文本文件，将一些 shell 的语法与指令(含外部指令)写在里面， 搭配正规表示法、管线命令与数据流重导向等功能，以达到我们所想要的处理目的
		shell script 用在系统管理上面是很好的一项工具，但是用在处理大量数值运算上， 就不够好了，因为 Shell scripts 的速度较慢，且使用的 CPU 资源较多，造成主机资源的分配不良。
		在 Shell script 的档案中，指令的执行是从上而下、从左而右的分析与执行；
		shell script 的执行，至少需要有 r 的权限，若需要直接指令下达，则需要拥有 r 与 x 的权限；
		良好的程序撰写习惯中，第一行要宣告 shell (#!/bin/bash) ，第二行以后则宣告程序用途、版本、作者等
		对谈式脚本可用 read 指令达成；
		要建立每次执行脚本都有不同结果的数据，可使用 date 指令利用日期达成；
		script 的执行若以 source 来执行时，代表在父程序的 bash 内执行之意！
		若需要进行判断式，可使用 test 或中括号 ( [] ) 来处理；
		在 script 内，$0, $1, $2..., $@ 是有特殊意义的！
		条件判断式可使用 if...then 来判断，若是固定发量内容的情况下，可使用 case $var in ... esac 来处理
		循环主要分为不定循环 (while, until) 以及固定循环 (for) ，配合 do, done 来达成所需任务！
		我们可使用 sh -x script.sh 来进行程序的 debug



第十四章、Linux 账号管理与 ACL 权限设定
	Linux 的账号与群组
		使用者标识符： UID 与 GID
			ID 与账号的对应就在 /etc/passwd 中
			每个登入的使用者至少都会取得两个 ID ，一个是使用者 ID (User ID ，简称 UID)、一个是群组 ID (Group ID ，简称 GID)。
			系统会依据 /etc/passwd 与 /etc/group 的内容， 找到 UID / GID 对应的账号与组名再显示出来
		使用者账号
			那么你输入账号密码后，系统帮你处理了什么呢？
				1. 先找寻 /etc/passwd 里面是否有你输入的账号？如果没有则跳出，如果有的话则将该账号对应的 UID 与 GID (在 /etc/group 中) 读出来，另外，该账号的家目录与 shell 设定也一并读出；
				2. 再来则是核对密码表啦！这时 Linux 会进入 /etc/shadow 里面找出对应的账号与 UID，然后核对一下你刚刚输入的密码与里头的密码是否相符？
				3. 如果一切都 OK 的话，就进入 Shell 控管的阶段啰！
			/etc/passwd 档案结构
				1. 账号名称：
				2. 密码： 早期 Unix 系统的密码就是放在这字段上！但是因为这个档案的特性是所有的程序都能够读取，这样一来很容易造成密码数据被窃取， 因此后来就将这个字段的密码数据给他改放到 /etc/shadow 中了
				3. UID： 这个就是使用者标识符啰！通常 Linux 对于 UID 有几个限制需要说给您了解一下： 
					id 		范围 			该 ID 使用者特性 
					0 		(系统管理员) 	当 UID 是 0 时，代表这个账号是『系统管理员』！ 所以当你要让其他的账号名称也具有 root 的权限时，将该账号的 UID 改为 0 即可。 这也就是说，一部系统上面的系统管理员不见得只有 root 喔！ 不过，很不建议有多个账号的 UID 是 0 啦～ 
					1~499 	(系统账号) 		保留给系统使用的 ID，其实除了 0 之外，其他的 UID 权限与特性并没有不一样。默认 500 以下的数字让给系统作为保留账号只是一个习惯。 由于系统上面启动的服务希望使用较小的权限去运作，因此不希望使用 root 的身份去执行这些服务， 所以我们就得要提供这些运作中程序的拥有者账号才行。这些系统账号通常是不可登入的， 所以才会有我们在第十一章提到的 /sbin/nologin 这个特殊的 shell 存在。 根据系统账号的由来，通常系统账号又约略被区分为两种： 1~99：由 distributions 自行建立的系统账号； 100~499：若用户有系统账号需求时，可以使用的账号 UID。 
					500~65535 (可登入账号) 	给一般使用者用的。事实上，目前的 linux 核心 (2.6.x 版)已经可以支持到 4294967295 (2^32-1) 这么大的 UID 号码喔！
				4. GID：
				5. 用户信息说明栏：
					这个字段基本上并没有什么重要用途，只是用来解释这个账号的意义而已！不过，如果您提供使用 finger 的功能时， 这个字段可以提供很多的迅息呢！
				6. 家目录：
				7. Shell：
			/etc/shadow 档案结构
				我们知道很多程序的运作都与权限有关，而权限与 UID/GID 有关！因此各程序当然需要读取 /etc/passwd 来了解不同账号的权限。 因此 /etc/passwd 的权限需设定为 -rw-r--r-- 这样的情况， 虽然早期的密码也有加密过，但即放置到 /etc/passwd 的第二个字段上！这样一来很容易被有心人士所窃取的， 加密过的密码也能够透过暴力破解法去 try and error (试诨) 找出来！ 因为这样的关系，所以后来发展出将密码移动到 /etc/shadow 这个档案分隔开来的技术， 而且还加入很多的密码限制参数在 /etc/shadow 里头
				基本上， shadow 同样以『:』作为分隔符，如果数一数，会发现共有九个字段啊，这九个字段的用途是这样的：
					1. 账号名称：
					2. 密码：
					3. 最近更动密码的日期：
					4. 密码不可被更动的天数：(与第 3 字段相比)
					5. 密码需要重新变更的天数：(与第 3 字段相比)
					6. 密码需要变更期限前的警告天数：(与第 5 字段相比)
					7. 密码过期后的账号宽限时间(密码失效日)：(与第 5 字段相比)
						虽然密码过期但是该账号还是可以用来进行其他工作的，包括登入系统取得 bash 。不过如果密码过期了， 那当你登入系统时，系统会强制要求你必须要重新设定密码才能登入继续使用喔，这就是密码过期特性。
						在密码过期几天后，如果使用者还是没有登入更改密码，那么这个账号的密码将会『失效』， 亦即该账号再也无法使用该密码登入了。要注意密码过期与密码失效并不相同。
					8. 账号失效日期：
						这个账号在此字段规定的日期之后，将无法再使用。 就是所谓的『账号失效』，此时不论你的密码是否有过期，这个『账号』都不能再被使用！
					9. 保留：
				root 密码忘让了：这就麻烦了！因为你无法使用 root 的身份登入了嘛！ 但我们知道 root 的密码在 /etc/shadow 当中，因此你可以使用各种可行的方法开机进入 Linux 再去修改。 例如重新启动进入单人维护模式(第二十章)后，系统会主动的给予 root 权限的 bash 接口， 此时再以 passwd 修改密码即可；或以 Live CD 开机后挂载根目录 去修改 /etc/shadow，将里面的 root 的密码字段清空， 再重新启动后 root 将不用密码即可登入！登入后再赶快以 passwd 指令去设定 root 密码即可。
		关于群组： 有效与初始群组、groups, newgrp
			/etc/group 档案结构
				这个档案每一行代表一个群组，也是以冒号『:』作为字段的分隔符，共分为四栏，每一字段的意义是：
					1. 组名：
					2. 群组密码：
					3. GID：
					4. 此群组支持的账号名称：
			有效群组(effective group)与初始群组(initial group)
				还让得每个使用者在他的 /etc/passwd 里面的第四栏有所谓的 GID 吧？那个 GID 就是所谓的『初始群组 (initial group) 』！也就是说，当用户一登入系统，立刻就拥有这个群组的相关权限
			groups: 有效与支持群组的观察
				如果我以 dmtsai 这个使用者的身份登入后，该如何知道我所有支持的群组呢？ 很简单啊，直接输入 groups 就可以了！
				在这个输出的迅息中，可知道 dmtsai 这个用户同时属亍 dmtsai 及 users 这个两个群组，而且， 第一个输出的群组即为有效群组 (effective group) 了
			newgrp: 有效群组的切换
				我们额外的来认识一下 newgrp 这个指令，这个指令可以变更目前用户的有效群组， 而且是另外以一个 shell 来提供这个功能的喔，所以，以上面的例子来说， dmtsai 这个使用者目前是以另一个 shell 登入的，而且新的 shell 给予 dmtsai 有效 GID 为 users 就是了。
				虽然用户的环境设定(例如环境变量等等其他数据)不会有影响，但是使用者的『群组权限』将会重新被计算。 但是需要注意，由于是新取得一个 shell ，因此如果你想要回到原本的环境中，请输入 exit 回到原本的 shell 喔！
			/etc/gshadow
				这个档案内同样还是使用冒号『:』来作为字段的分隔字符
				不过，要注意的大概就是第二个字段吧～第二个字段是密码栏， 如果密码栏上面是『!』时，表示该群组不具有群组管理员！至于第四个字段也就是支持的账号名称啰～ 这四个字段的意义为：
					1. 组名
					2. 密码栏，同样的，开头为 ! 表示无合法密码，所以无群组管理员
					3. 群组管理员的账号 (相关信息在 gpasswd 中介绍)
					4. 该群组的所属账号 (与 /etc/group 内容相同！)
				那么什么是群组管理员呢？由于系统上面的账号可能会很多，但是我们 root 可能平时太忙碌，所以当有使用者想要加入某些群组时， root 或许会没有空管理。此时如果能够建立群组管理员的话，那么该群组管理员就能够将那个账号加入自己管理的群组中！ 可以免去 root 癿忙碌啦！不过，由于目前有类似 sudo 之类的工具， 所以这个群组管理员的功能已经很少使用了。
	账号管理	
		新增与移除使用者： useradd, 相关配置文件, passwd, usermod, userdel
			账号可以使用 useradd 来新建用户，密码的给予则使用 passwd 这个指令
			useradd
				[root@www ~]# useradd [-u UID] [-g 初始群组] [-G 次要群组] [-mM]\ 
				> [-c 说明栏] [-d 家目录绝对路径] [-s shell] 使用者账号名 
				选项与参数： 
					-u ：后面接的是 UID ，是一组数字。直接之定一个特定的 UID 给这个账号； 
					-g ：后面接的那个组名就是我们上面提到的 initial group 啦～ 该群组的 GID 会被放置到 /etc/passwd 的第四个字段内。 
					-G ：后面接的组名则是这个账号还可以加入的群组。 这个选项与参数会修改 /etc/group 内的相关资料喔！ 
					-M ：强制！不要建立用户家目录！(系统账号默认值) 
					-m ：强制！要建立用户家目录！(一般账号默认值) 
					-c ：这个就是 /etc/passwd 的第五栏的说明内容啦～可以随便我们设定的啦～ 
					-d ：指定某个目录成为家目录，而不要使用默认值。务必使用绝对路径！ 
					-r ：建立一个系统的账号，这个账号的 UID 会有限制 (参考 /etc/login.defs) 
					-s ：后面接一个 shell ，若没有指定则预设是 /bin/bash 的啦～ 
					-e ：后面接一个日期，格式为『YYYY-MM-DD』此项目可写入 shadow 第八字段， 亦即账号失效日的设定项目啰； 
					-f ：后面接 shadow 的第七字段项目，指定密码是否会失效。0为立刻失效， -1 为永久不失效(密码只会过期而强制于登入时重新设定而已。)
				使用『 useradd 账号 』来建立使用者,CentOS 这些默认值主要会帮我们处理几个项目：
					在 /etc/passwd 里面建立一行与账号相关的数据，包括建立 UID/GID/家目录等；
					在 /etc/shadow 里面将此账号的密码相关参数填入，但是尚未有密码；
					在 /etc/group 里面加入一个与账号名称一模一样的组名；
					在 /home 底下建立一个与账号同名的目录作为用户家目录，且权限为 700
				由于在 /etc/shadow 内仅会有密码参数而不会有加密过的密码数据，因此我们在建立使用者账号时， 还需要使用『 passwd 账号 』来给予密码才算是完成了用户建立的流程。
				添加系统账号 (system account)：
					useradd -r vbird3
					我们在谈到 UID 的时候曾经说过一般账号应该是 500 号以后，那用户自己建立的系统账号则一般是由 100 号以后起算的。 所以在这里我们加上 -r 这个选项以后，系统就会主动将账号与账号同名群组的 UID/GID 都指定小于 500 以下
			useradd 参考档
				其实 useradd 的默认值可以使用底下的方法呼叫出来：
					[root@www ~]# useradd -D
						GROUP=100：新建账号的初始群组使用 GID 为 100 者 系统上面 GID 为 100 者即是 users 这个群组，此训定项目指的就是让新设使用者账号的初始群组为 users 这一个的意思。 但是我们知道 CentOS 上面并不是这样的，在 CentOS 上面预设的群组为与账号名相同的群组。 举例来说， vbird1 癿初始群组为 vbird1 。怎么会这样啊？这是因为针对群组的角度有两种不同的机制所致， 这两种机制分别是：
							私有群组机制：系统会建立一个与账号一样的群组给使用者作为初始群组。 这种群组的设定机制会比较有保密性，这是因为使用者都有自己的群组，而且家目录权限将会设定为 700 (仅有自己可进入自己的家目录) 之故。使用这种机制将不会参考 GROUP=100 这个设定值。代表性的 distributions 有 RHEL, Fedora, CentOS 等；
							公共群组机刢：就是以 GROUP=100 这个训定值作为新建账号癿刜始群组，因此每个账号都属亍 users 这个群组， 丏默讣家目弽通常癿权限会是『 drwxr-xr-x ... username users ... 』，由亍每个账号都属亍 users 群组，因此大家都可以互相分享家目弽内癿数据乀故。代表 distributions 如 SuSE等。由亍我们癿 CentOS 使用私有群组机刢，因此这个训定项目是丌会生效癿
						INACTIVE=-1：密码过期后是否会失效的设定值 我们在 shadow 档案结构当中谈过，第七个字段的设定值将会影响到密码过期后， 在多长时间内还可使用旧密码登入。这个项目就是在指定该日数啦！如果是 0 代表密码过期立刻失效， 如果是 -1 则是代表密码永远不会失效，如果是数字，如 30 ，则代表过期 30 天后才失效。
						EXPIRE=：账号失效的日期 就是 shadow 内的第八字段，你可以直接设定账号在哪个日期后就直接失效，而不理会密码的问题。 通常不会设定此项目。
						SKEL=/etc/skel：用户家目录参考基准目录 这个咚咚就是指定用户家目录的参考基准目录啰～
							举我们的范例一为例， vbird1 家目录 /home/vbird1 内的各项数据，都是由 /etc/skel 所复制过去的～所以呢，未来如果我想要让新增使用者时，该用户的环境变量 ~/.bashrc 就设定妥当的话，您可以到 /etc/skel/.bashrc 去编辑一下，也可以建立 /etc/skel/www 这个目录，那么未来新增使用者后，在他的家目录下就会有 www 那个目录了！这样瞭呼？
						CREATE_MAIL_SPOOL=yes：建立使用者的 mailbox 你可以使用『 ll /var/spool/mail/vbird1 』看一下，会发现有这个档案的存在喔！这就是使用者的邮件信箱！
				除了这些基本的账号设定值之外， UID/GID 还有密码参数又是在哪里参考的呢？那就得要看一下 /etc/login.defs 啦！
				使用 useradd 这支程序在建立 Linux 上的账号时，至少会参考：
					/etc/default/useradd
					/etc/login.defs
					/etc/skel/*
				这些档案，不过，最重要的其实是建立 /etc/passwd, /etc/shadow, /etc/group, /etc/gshadow 还有用户家目录就是了～所以，如果你了解整个系统运作的状态，也是可以手动直接修改这几个档案就是了。
			passwd
				使用 useradd 建立了账号之后，在预设的情况下，该账号是暂时被封锁的， 也就是说，该账号是无法登入的，直接给他设定新密码就好了嘛
				[root@www ~]# passwd [--sdtin] <==所有人均可使用来改自己的密码 
				[root@www ~]# passwd [-l] [-u] [--sdtin] [-S] \ 
				> [-n 日数] [-x 日数] [-w 日数] [-i 日期] 账号 <==root 功能 
				选项与参数： 
					--stdin ：可以透过来自前一个管线的数据，作为密码输入，对 shell script 有帮助！ 
					-l ：是 Lock 的意思，会将 /etc/shadow 第二栏最前面加上 ! 使密码失效； 
					-u ：与 -l 相对，是 Unlock 的意思！ 
					-S ：列出密码相关参数，亦即 shadow 档案内的大部分信息。
					-n ：后面接天数，shadow 的第 4 字段，多久不可修改密码天数 
					-x ：后面接天数，shadow 的第 5 字段，多久内必须要更动密码 
					-w ：后面接天数，shadow 的第 6 字段，密码过期前的警告天数 
					-i ：后面接『日期』，shadow 的第 7 字段，密码失效日期
				新的 distributions 是使用较严格的 PAM 模块来管理密码，这个管理的机制写在 /etc/pam.d/passwd 当中。而该档案与密码有关的测试模块就是使用：pam_cracklib.so，这个模块会检验密码相关的信息， 并且取代 /etc/login.defs 内的 PASS_MIN_LEN 的设定啦！
			chage
				[root@www ~]# chage [-ldEImMW] 账号名 
				选项与参数： 
					-l ：列出该账号的详细密码参数； 
					-d ：后面接日期，修改 shadow 第三字段(最近一次更改密码癿日期)，格式 YYYY-MM-DD 
					-E ：后面接日期，修改 shadow 第八字段(账号失效日)，格式 YYYY-MM-DD 
					-I ：后面接天数，修改 shadow 第七字段(密码失效日期) 
					-m ：后面接天数，修改 shadow 第四字段(密码最短保留天数) 
					-M ：后面接天数，修改 shadow 第五字段(密码多久需要进行变更) 
					-W ：后面接天数，修改 shadow 第六字段(密码过期前警告日期)
				chage 有一个功能很不错喔！如果你想要让『使用者在第一次登入时， 强制她们一定要更改密码后才能够使用系统资源』，可以利用如下的方法来处理的！ 
					范例二：建立一个名为 agetest 的账号，该账号第一次登入后使用默认密码， 但必须要更改过密码后，使用新密码才能够登入系统使用 bash 环境 
					[root@www ~]# useradd agetest 
					[root@www ~]# echo "agetest" | passwd --stdin agetest 
					[root@www ~]# chage -d 0 agetest # 此时此账号癿密码建立时间会被改为 1970/1/1 ，所以会有问题！
			usermod
				[root@www ~]# usermod [-cdegGlsuLU] username 
				选项与参数： 
					-c ：后面接账号的说明，即 /etc/passwd 第五栏的说明栏，可以加入一些账号的说明。 
					-d ：后面接账号的家目录，即修改 /etc/passwd 的第六栏； 
					-e ：后面接日期，格式是 YYYY-MM-DD 也就是在 /etc/shadow 内的第八个字段数据啦！ 
					-f ：后面接天数，为 shadow 的第七字段。 
					-g ：后面接初始群组，修改 /etc/passwd 的第四个字段，亦即是 GID 的字段！ 
					-G ：后面接次要群组，修改这个使用者能够支持的群组，修改的是 /etc/group 啰～ 
					-a ：与 -G 合用，可『增加次要群组的支持』而非『设定』喔！ 
					-l ：后面接账号名称。亦即是修改账号名称， /etc/passwd 的第一栏！ 
					-s ：后面接 Shell 的实际档案，例如 /bin/bash 或 /bin/csh 等等。 
					-u ：后面接 UID 数字啦！即 /etc/passwd 第三栏的资料； 
					-L ：暂时将用户的密码冻结，让他无法登入。其实仅改 /etc/shadow 的密码栏。 
					-U ：将 /etc/shadow 密码栏的 ! 拿掉，解冻啦！
			userdel
				这个功能就太简单了，目的在删除用户的相关数据，而用户的数据有：
					用户账号/密码相关参数：/etc/passwd, /etc/shadow
					使用者群组相关参数：/etc/group, /etc/gshadow
					用户个人档案数据： /home/username, /var/spool/mail/username..
				整个指令的语法非常简单： 
					[root@www ~]# userdel [-r] username 
					选项与参数： 
						-r ：连同用户的家目录也一起删除
				如果想要完整的将某个账号完整的移除，最好可以在下达 userdel -r username 之前， 先以『 find / -user username 』查出整个系统内属于 username 的档案，然后再加以删除吧！
		用户功能
			不论是 useradd/usermod/userdel ，那都是系统管理员所能够使用的指令， 如果我是一般身份使用者，那么我是否除了密码之外，就无法更改其他的数据呢？ 当然不是啦！这里我们介绍几个一般身份用户常用的账号数据变更与查询指令啰！
			finger
				finger 可以查阅很多用户相关的信息喔！
					[root@www ~]# finger [-s] username 
					选项与参数： 
						-s ：仅列出用户的账号、全名、终端机代号与登入时间等等； 
						-m ：列出与后面接的账号相同者，而不是利用部分比对 (包括全名部分)
					范例三：找出目前在系统上面登入的用户与登入时间 
						[vbird1@www ~]$ finger
			chfn
				chfn 有点像是： change finger 的意思！这玩意的使用方法如下： 
					[root@www ~]# chfn [-foph] [账号名] 
					选项与参数： 
						-f ：后面接完整的大名； 
						-o ：您办公室的房间号码； 
						-p ：办公室的电话号码； 
						-h ：家里的电话号码！
			chsh
				这就是 change shell 的简写！使用方法就更简单了！ 
					[vbird1@www ~]$ chsh [-ls] 选项与参数： 
						-l ：列出目前系统上面可用的 shell ，其实就是 /etc/shells 的内容！ 
						-s ：设定修改自己的 Shell 啰
				不论是 chfn 与 chsh ，都是能够让一般用户修改 /etc/passwd 这个系统文件的！所以你猜猜，这两个档案的权限是什么？ 一定是 SUID 的功能啦！
			id
				id 这个指令则可以查询某人或自己的相关 UID/GID 等等的信息，他的参数也不少，不过， 都不需要～反正使用 id 就全部都列出啰～ ^_^ 
					[root@www ~]# id [username]
		新增与移除群组
			groupadd
				[root@www ~]# groupadd [-g gid] [-r] 组名 
				选项与参数： 
					-g ：后面接某个特定的 GID ，用来直接给予某个 GID ～ 
					-r ：建立系统群组啦！与 /etc/login.defs 内的 GID_MIN 有关。
			groupmod
				[root@www ~]# groupmod [-g gid] [-n group_name] 群组名 
				选项与参数： 
					-g ：修改既有的 GID 数字； 
					-n ：修改既有的组名
			groupdel
				[root@www ~]# groupdel [groupname]
				为什么 mygroup 可以删除，但是 vbird1 就不能删除呢？原因很简单，『有某个账号 (/etc/passwd) 的 initial group 使用该群组！』 如果查阅一下，你会发现在 /etc/passwd 内的 vbird1 第四栏的 GID 就是 /etc/group 内的 vbird1 那个群组的 GID ，所以啰，当然无法删除～否则 vbird1 这个用户登入系统后， 就会找不到 GID ，那可是会造成很大的困扰的！那么如果硬要要删除 vbird1 这个群组呢？ 你『必须要确认 /etc/passwd 内的账号没有任何人使用该群组作为 initial group 』才行喔！
			gpasswd：群组管理员功能
				# 关于系统管理员(root)做的动作： 
					[root@www ~]# gpasswd groupname 
					[root@www ~]# gpasswd [-A user1,...] [-M user3,...] groupname 
					[root@www ~]# gpasswd [-rR] groupname 
					选项与参数： 
							：若没有任何参数时，表示给予 groupname 一个密码(/etc/gshadow) 
						-A ：将 groupname 的主控权交由后面的使用者管理(该群组的管理员) 
						-M ：将某些账号加入这个群组当中！ 
						-r ：将 groupname 的密码移除 
						-R ：让 groupname 的密码栏失效 
				# 关于群组管理员(Group administrator)做的动作： 
					[someone@www ~]$ gpasswd [-ad] user groupname 
					选项与参数： 
						-a ：将某位使用者加入到 groupname 这个群组当中！
						-d ：将某位使用者移除出 groupname 这个群组当中。
	主机的细部权限规划：ACL 的使用
		什么是 ACL
			ACL 是 Access Control List 的缩写，主要的目的是在提供传统的 owner,group,others 的 read,write,execute 权限之外的细部权限设定。ACL 可以针对单一使用者，单一档案或目录来进行 r,w,x 的权限规范，对于需要特殊权限的使用状况非常有帮助。 那 ACL 主要可以针对哪些方面来控制权限呢？他主要可以针对几个项目：
				使用者 (user)：可以针对使用者来设定权限；
				群组 (group)：针对群组为对象来设定其权限；
				默认属性 (mask)：还可以针对在该目录下在建立新档案/目录时，规范新数据的默认权限；
		如何启动 ACL
			由于 ACL 是传统的 Unix-like 操作系统权限的额外支持项目，因此要使用 ACL 必须要有文件系统的支持才行。目前绝大部分的文件系统都有支持 ACL 的功能，包括 ReiserFS, EXT2/EXT3, JFS, XFS 等等。在我们的 CentOS 5.x 当中，预设使用 Ext3 是启动 ACL 支持的！
			至于察看你的文件系统是否支持 ACL 可以这样看： 
				[root@www ~]# mount <==直接查阅挂载参数的功能 
				/dev/hda2 on / type ext3 (rw) 
				/dev/hda3 on /home type ext3 (rw) # 其他项目鸟哥都将他省略了！假设我们只要看这两个装置。但没有看到 acl 喔！ 
				[root@www ~]# dumpe2fs -h /dev/hda2 <==由 superblock 内容去查询 
				....(前面省略).... 
				Default mount options: user_xattr acl 
				....(后面省略)....
				由 mount 单纯去查阅不见得可以看到实际的项目，由于目前新的 distributions 常常会主动加入某些默认功能， 如上表所示，其实 CentOS 5.x 在预设的情况下 (Default mount options:) 就帮你加入 acl 的支持了！ 
				那如果你的系统默认不会帮你加上 acl 的支持呢？那你可以这样做： 
					[root@www ~]# mount -o remount,acl / 
					[root@www ~]# mount /dev/hda2 on / type ext3 (rw,acl) # 这样就加入了！
				但是如果想要每次开机都生效，那就这样做： 
					[root@www ~]# vi /etc/fstab LABEL=/1 / ext3 defaults,acl 1 1
				如果你不确定或者是不会使用 dumpe2fs 观察你的文件系统，那么建议直接将上述的 /etc/fstab 里面的内容修改一下即可！
		ACL 癿设定技巧： getfacl, setfacl
			setfacl 指令用法
				[root@www ~]# setfacl [-bkRd] [{-m|-x} acl参数] 目标文件名 
				选项与参数： 
					-m ：设定后续的 acl 参数给档案使用，不可与 -x 合用； 
					-x ：删除后续的 acl 参数，不可与 -m 合用； 
					-b ：移除所有的 ACL 设定参数； 
					-k ：移除预设的 ACL 参数，关于所谓的『预设』参数于后续范例中介绍； 
					-R ：递规设定 acl ，亦即包括次目录都会被设定起来； 
					-d ：设定『预设 acl 参数』的意思！只对目录有效，在该目录新建的数据会引用此默认值
				上面谈到的是 acl 的选项功能，那么如何设定 ACL 的特殊权限呢？特殊权限的设定方法有很多， 我们先来谈谈最常见的，就是针对单一使用者的设定方式： 
					# 1. 针对特定使用者的方式： 
						# 设定规范：『 u:[使用者账号列表]:[rwx] 』，
							例如针对 vbird1 癿权限规范 rx ： 
								[root@www ~]# touch acl_test1 
								[root@www ~]# ll acl_test1 
								-rw-r--r-- 1 root root 0 Feb 27 13:28 acl_test1 
								[root@www ~]# setfacl -m u:vbird1:rx acl_test1 
								[root@www ~]# ll acl_test1 
								-rw-r-xr--+ 1 root root 0 Feb 27 13:28 acl_test1 # 权限部分多了个 + ，且与原本的权限 (644) 看起来差异很大！
							但要如何查阅呢？ 
								[root@www ~]# setfacl -m u::rwx acl_test1 
								[root@www ~]# ll acl_test1 
								-rwxr-xr--+ 1 root root 0 Feb 27 13:28 acl_test1 # 无使用者列表，代表设定该档案拥有者，所以上面显示 root 的权限成为 rwx 了！
			getfacl 指令用法
				[root@www ~]# getfacl filename
				选项与参数： 
					getfacl 的选项几乎与 setfacl 相同
				显示的数据前面加上 # 的，代表这个档案的默认属性，包括文件名、档案拥有者与档案所属群组。 底下出现的 user, group, mask, other 则是属于不同使用者、群组与有效权限(mask)的设定值。
				# 2. 针对特定群组的方式： 
					# 设定规范：『 g:[群组列表]:[rwx] 』，
					例如针对 mygroup1 的权限规范 rx ： 
						[root@www ~]# setfacl -m g:mygroup1:rx acl_test1
					不过，你应该会觉得奇怪的是， 那个 mask 是什么东西啊？其实他有点像是『有效权限』的意思！他的意义是： 使用者或群组所设定的权限必须要存在于 mask 的权限设定范围内才会生效，此即『有效权限 (effective permission)』
					如果你想要让 acl 在目录底下的数据都有继承的功能，那就得如下这样做了！
					# 4. 针对预设权限的设定方式： 
						# 设定规范：『 d:[ug]:使用者列表:[rwx] 』
	使用者身份切换
		那如何让一般使用者转变身份成为 root 呢？主要有两种方式喔：
			以『 su - 』直接将身份变成 root 即可，但是这个指令即需要 root 的密码，也就是说，如果你要以 su 变成 root 的话，你的一般使用者就必须要有 root 的密码才行；
			以『 sudo 指令 』执行 root 的指令串，由于 sudo 需要事先设定妥当，丏 sudo 需要输入用户自己的密码， 因此多人共管同一部主机时， sudo 要比 su 来的好喔！至少 root 密码不会流出去！
		su
			su 是最简单的身份切换指令了，他可以进行任何身份的切换唷！方法如下： 
				[root@www ~]# su [-lm] [-c 指令] [username] 
				选项与参数： 
					- ：单纯使用 - 如『 su - 』代表使用 login-shell 的变量档案读取方式来登入系统；
						若使用者名称没有加上去，则代表切换为 root 的身份。 
					-l ：与 - 类似，但后面需要加欲切换的使用者账号！也是 login-shell 的方式。 
					-m ：-m 与 -p 是一样的，表示『使用目前的环境设定，而不读取新使用者的配置文件』 
					-c ：仅进行一次指令，所以 -c 后面可以加上指令喔！
			这个 su 的用法当中，有没有加上那个减号『 - 』差很多喔！ 因为涉及 login-shell 与 non-login shell 的变量读取方法。这里让我们以一个小例子来说明吧！ 
				范例一：假设你原本是 vbird1 的身份，想要使用 non-login shell 的方式变成 root 
					[vbird1@www ~]$ su <==注意提示字符，是 vbird1 的身份喔！ 
					Password: <==这里输入 root 的密码喔！ 
					[root@www vbird1]# id <==提示字符的目录是 vbird1 喔！ 
					uid=0(root) gid=0(root) groups=0(root),1(bin),... <==确实是 root 的身份！
					[root@www vbird1]# env | grep 'vbird1' 
					USER=vbird1 
					PATH=/usr/local/bin:/bin:/usr/bin:/home/vbird1/bin <==这个影响最大！ 
					MAIL=/var/spool/mail/vbird1 <==收到的 mailbox 是 vbird1 
					PWD=/home/vbird1 <==并非 root 的家目录 
					LOGNAME=vbird1 # 虽然你的 UID 已经是具有 root 的身份，但是看到上面的输出讯息吗？ 
					# 还是有一堆变量为原本 vbird1 的身份，所以很多数据还是无法直接利用。 
					[root@www vbird1]# exit <==这样可以离开 su 的环境！
			su 就这样简单的介绍完毕，总结一下他的用法是这样的：
				若要完整的切换到新使用者的环境，必须要使用『 su - username 』或『 su -l username 』， 才会连同 PATH/USER/MAIL 等变量都转成新用户的环境；
				如果仅想要执行一次 root 的指令，可以利用『 su - -c "指令串" 』的方式来处理；
				使用 root 切换成为任何使用者时，并不需要输入新用户的密码；
			sudo
				并非所有人都能够执行 sudo ， 而是仅有规范到 /etc/sudoers 内的用户才能够执行 sudo 这个指令
				sudo 的指令用法
					[root@www ~]# sudo [-b] [-u 新使用者账号] 
					选项与参数： 
						-b ：将后续的指令放到背景中让系统自行执行，而不与目前的 shell 产生影响 
						-u ：后面可以接欲切换的使用者，若无此项则代表切换身份为 root 。
					范例一：你想要以 sshd 的身份在 /tmp 底下建立一个名为 mysshd 的档案 
						[root@www ~]# sudo -u sshd touch /tmp/mysshd
					范例二：你想要以 vbird1 的身份建立 ~vbird/www 并于其中建立 index.html档案 
						[root@www ~]# sudo -u vbird1 sh -c "mkdir ~vbird1/www; cd ~vbird1/www; \ 
						> echo 'This is index.html file' 
						> index.html"
						范例一中，我们的 root 使用 sshd 的权限去进行某项任务！ 要注意，因为我们无法使用『 su - sshd 』去切换系统账号 (因为系统账号的 shell 是 /sbin/nologin)， 这个时候 sudo 真是他 X 的好用了！立刻以 sshd 的权限在 /tmp 底下建立档案！查阅一下档案权限你就了解意义啦！ 至于范例二则更使用多重指令串 (透过分号 ; 来延续指令进行)，使用 sh -c 的方法来执行一连串的指令
					但是 sudo 预设仅有 root 能使用啊！为什么呢？因为 sudo 的执行是这样的流程：
						1. 当用户执行 sudo 时，系统于 /etc/sudoers 档案中搜寻该使用者是否有执行 sudo 的权限；
						2. 若使用者具有可执行 sudo 的权限后，便让使用者『输入用户自己的密码』来确认；
						3. 若密码输入成功，便开始进行 sudo 后续接的指令(但 root 执行 sudo 时，不需要输入密码)；
						4. 若欲切换的身份与执行者身份相同，那也不需要输入密码。
				visudo 与 /etc/sudoers
					除了 root 之外的其他账号，若想要使用 sudo 执行属于 root 的权限指令，则 root 需要先使用 visudo 去修改 /etc/sudoers ，让该账号能够使用全部或部分的 root 指令功能。为什么要使用 visudo 呢？这是因为 /etc/sudoers 是有设定语法的，如果设定错误那会造成无法使用 sudo 指令的不良后果。因此才会使用 visudo 去修改， 并在结束离开修改画面时，系统会去检验 /etc/sudoers 的语法就是了。 一般来说，visudo 的设定方式有几种简单的方法喔，底下我们以几个简单的例子来分别说明：
					I. 单一用户可进行 root 所有指令，与 sudoers 档案语法： 
						假如我们要让 vbird1 这个账号可以使用 root 的任何指令，那么可以简单的这样进行修改即可： 
						[root@www ~]# visudo 
						....(前面省略).... 
						root ALL=(ALL) ALL <==找到这一行，大约在 76 行左右 
						vbird1 ALL=(ALL) ALL <==这一行是你要新增的！ 
						....(前面省略)....
						使用者账号 登入者的来源主机名=(可切换的身份) 可下达的指令 
						root ALL=(ALL) ALL <==这是默认值
						上面这一行的四个组件意义是：
							1. 系统的哪个账号可以使用 sudo 这个指令的意思，默认为 root 这个账号；
							2. 当这个账号由哪部主机联机到本 Linux 主机，意思是这个账号可能是由哪一部网络主机联机过来的， 这个设定值可以指定客户端计算机(信任用户的意思)。默认值 root 可来自任何一部网络主机
							3. 这个账号可以切换成什么身份来下达后续的指令，默认 root 可以切换成任何人；
							4. 可用该身份下达什么指令？这个指令请务必使用绝对路径撰写。 预设 root 可以切换任何身份且进行任何指令之意。
					II. 利用群组以及免密码的功能处理 visudo
						%wheel ALL=(ALL) ALL <==大约在 84 行左右，请将这行的 # 拿掉！ # 在最左边加上 % ，代表后面接的是一个『群组』之意！改完请储存后离开
						不过，既然我们都信任这些 sudo 的用户了，能否提供『不需要密码即可使用 sudo 』呢？ 就透过如下的方式： 
							[root@www ~]# visudo <==同样的，请使用 root 先设定 
							....(前面省略).... 
							%wheel ALL=(ALL) NOPASSWD: ALL <==大约在 87 行左右，请将 # 拿掉！ # 在最左边加上 % ，代表后面接的是一个『群组』之意！改完请储存后离开
							重点是那个 NOPASSWD 啦！该关键词是免除密码输入的意思喔！
					III. 有限制的指令操作：
						比方说，系统上面的 myuser1 仅能够帮 root 修改其他用户的密码时，亦即『当使用者仅能使用 passwd 这个指令帮忙 root 修改其他用户的密码』时，你该如何撰写呢？可以这样做：
							[root@www ~]# visudo <==注意是 root 身份 
							myuser1 ALL=(root) !/usr/bin/passwd, /usr/bin/passwd [A-Za-z]*, \ 
							!/usr/bin/passwd root
							加上惊叹号『 ! 』代表『不可执行』的意思。 因此上面这一行会变成：可以执行『 passwd 任意字符』，但是『 passwd 』与『 passwd root 』这两个指令例外！ 如此一来 myuser1 就无法改变 root 的密码了！这样这位使用者可以具有 root 的能力帮助你修改其他用户的密码， 而且也不能随意改变 root 的密码
					IV. 透过别名建置 visudo：
						如上述第三点，如果我有 15 个用户需要加入刚刚的管理员行列，那么我是否要将上述那长长的设定写入 15 行啊？ 而且如果想要修改命令或者是新增命令时，那我每行都需要重新设定，很麻烦！有没有更简单的方式？ 是有的！透过别名即可！我们 visudo 的别名可以是『指令别名、帐户别名、主机别名』等。
						[root@www ~]# visudo <==注意是 root 身份 
						User_Alias ADMPW = pro1, pro2, pro3, myuser1, myuser2 
						Cmnd_Alias ADMPWCOM = !/usr/bin/passwd, /usr/bin/passwd [A-Za-z]*, \ 
						!/usr/bin/passwd root 
						ADMPW ALL=(root) ADMPWCOM
					V. sudo 的时间间隔问题：
						两次执行 sudo 的间隔在五分钟内，那么再次执行 sudo 时就不需要再次输入密码了， 这是因为系统相信你在五分钟内不会离开你的作业，所以执行 sudo 的是同一个人
						另外要注意的是，因为使用一般账号时，理论上不会使用到 /sbin, /usr/sbin 等目录内的指令，所以 $PATH 变量不会含有这些目录，因此很多管理指令需要使用绝对路径来下达比较妥当喔！
					VI. sudo 搭配 su 的使用方式：
						[root@www ~]# visudo 
						User_Alias ADMINS = pro1, pro2, pro3, myuser1 
						ADMINS ALL=(root) /bin/su -
						接下来，上述的 pro1, pro2, pro3, myuser1 这四个人，只要输入『 sudo su - 』并且输入『自己的密码』后， 立刻变成 root 的身份！不但 root 密码不会外流，用户的管理也变的非常方便
	用户的特殊 shell 与 PAM 模块
		特殊的 shell, /sbin/nologin
			在本章一开头的 passwd 档案结构里面我们就谈过系统账号这玩意儿，这玩意儿的 shell 就是使用 /sbin/nologin ，重点在于系统账号是不需要登入的！所以我们就给他这个无法登入的合法 shell。 使用了这个 shell 的用户即使有了密码，你想要登入时他也无法登入
			我们所谓的『无法登入』指的仅是：『这个使用者无法使用 bash 或其他 shell 来登入系统』而已， 并不是说这个账号就无法使用其他的系统资源喔！ 举例来说，各个系统账号，打印作业由 lp 这个账号在管理， WWW 朋务由 apache 这个账号在管理， 他们都可以进行系统程序的工作，但是『就是无法登入主机』而已啦
			另外，如果我想要让某个具有 /sbin/nologin 的使用者知道，他们不能登入主机时， 其实我可以建立『 /etc/nologin.txt 』这个档案， 并且在这个档案内说明不能登入的原因，那么下次当这个用户想要登入系统时， 屏幕上出现的就会是 /etc/nologin.txt 这个档案的内容，而不是预设的内容了！
		PAM 模块简介
			PAM 可以说是一套应用程序编程接口 (Application Programming Interface, API)，他提供了一连串的验证机制，叧要使用者将验证阶段的需求告知 PAM 后， PAM 就能够回报使用者验证的结果 (成功或失败)。由于 PAM 仅是一套验证的机制，又可以提供给其他程序所呼叫引用，因此不论你使用什么程序，都可以使用 PAM 来进行验证，如此一来，就能够让账号密码或者是其他方式的验证具有一致的结果！也让程序设计师方便处理验证的问题喔！
			PAM 用来进行验证的数据称为模块 (Modules)，每个 PAM 模块的功能都不太相同。举例来说， 还让得我们在本章使用 passwd 指令时，如果随便输入字典上面找的到的字符串， passwd 就会回报错误信息了！这是为什么呢？这就是 PAM 的 pam_cracklib.so 模块的功能！他能够判断该密码是否在字典里面！ 并回报给密码修改程序，此时就能够了解你的密码强度了。
		PAM 模块设定语法
			PAM 藉由一个与程序相同文件名的配置文件来进行一连串的认证分析需求。我们同样以 passwd 这个指令的呼叫 PAM 来说明好了。 当你执行 passwd 后，这支程序呼叫 PAM 的流程是：
				1. 用户开始执行 /usr/bin/passwd 这支程序，并输入密码；
				2. passwd 呼叫 PAM 模块进行验证；
				3. PAM 模块会到 /etc/pam.d/ 找寻与程序 (passwd) 同名的配置文件；
				4. 依据 /etc/pam.d/passwd 内的设定，引用相关的 PAM 模块逐步进行验证分析；
				5. 将验证结果 (成功、失败以及其他讯息) 回传给 passwd 这支程序；
				6. passwd 这支程序会根据 PAM 回传的结果决定下一个动作 (重新输入新密码或者通过验证！)
			从上头的说明，我们会知道重点其实是 /etc/pam.d/ 里面的配置文件，以及配置文件所呼叫的 PAM 模块进行的验证工作！ 
			既然一直谈到 passwd 这个密码修改指令，那我们就来看看 /etc/pam.d/passwd 这个配置文件的内容是怎样吧！ 
				[root@www ~]# cat /etc/pam.d/passwd #%PAM-1.0 <==PAM版本癿说明而已！ 
				auth include system-auth <==每一行都是一个验证的过程 
				account include system-auth 
				password include system-auth 验证类别 控制标准 PAM 模块与该模块的参数
				在这个配置文件当中，除了第一行宣告 PAM 版本之外，其他任何『 # 』开头的都是批注，而每一行都是一个独立的验证流程， 每一行可以区分为三个字段，分别是验证类别(type)、控制标准(flag)、PAM的模块与该模块的参数。 
				底下我们先来谈谈验证类别与控制标准这两项数据吧！
					第一个字段：验证类别 (Type)
						验证类删主要分为四种，分删说明如下：
							auth 是 authentication (认证) 的缩写，所以这种类别主要用来检验使用者的身份验证，这种类别通常是需要密码来检验的， 所以后续接的模块是用来检验用户的身份。
							account account (账号) 则大部分是在进行 authorization (授权)，这种类别则主要在检验使用者是否具有正确的权限， 举例来说，当你使用一个过期的密码来登入时，当然就无法正确的登入了。
							session session 是会话期间的意思，所以 session 管理的就是使用者在这次登入 (或使用这个指令) 期间，PAM 所给予的环境设定。 这个类别通常用在记录用户登入与注销时的信息！例如，如果你常常使用 su 或者是 sudo 指令的话， 那么应该可以在 /var/log/secure 里面发现很多关于 pam 的说明，而且记载的数据是『session open, session close』的信息！
							password password 就是密码嘛！所以这种类别主要在提供验证的修订工作，举例来说，就是修改/变更密码啦！
						这四个验证的类型通常是有顺序的，不过也有例外就是了。 会有顺序的原因是，
							(1)我们总是得要先验证身份 (auth) 后， 
							(2)系统才能够藉由用户的身份给予适当的授权与权限设定 (account)，而且
							(3)登入与注销期间的环境才需要设定， 也才需要记录登入与注销的信息 (session)。如果在运作期间需要密码修订时，
							(4)才给予 password 的类别。这样说起来， 自然是需要有点顺序吧！
					第二个字段：验证的控制旗标 (control flag)
						那么『验证的控制旗标(control flag)』又是什么？简单的说，他就是『验证通过的标准』啦！ 这个字段在管控该验证的放行方式，主要也分为四种控制方式：
							required 此验证若成功则带有 success (成功) 的标志，若失败则带有 failure 的标志，但不论成功或失败都会继续后续的验证流程。 由于后续的验证流程可以继续进行，因此相当有利于资料的登录 (log) ，这也是 PAM 最常使用 required 的原因。
							requisite 若验证失败则立刻回报原程序 failure 的标志，并终止后续的验证流程。若验证成功则带有 success 的标志并继续后续的验证流程。 这个项目与 required 最大癿差异，就在于失败的时候还要不要继续验证下去？由于 requisite 是失败就终止， 因此失败时所产生的 PAM 信息就无法透过后续的模块来记录了。
							sufficient 若验证成功则立刻回传 success 给原程序，并终止后续的验证流程；若验证失败则带有 failure 标志并继续后续的验证流程。 这玩意儿与 requisits 刚好相反！
							optional 这个模块控件目大多是在显示讯息而已，并不是用在验证方面的。
		常用模块简介	
			上面这个表格当中使用到非常多的 PAM 模块，每个模块的功能都不太相同，详细的模块情报可以在你的系统中找到：
				/etc/pam.d/*：每个程序个别的 PAM 配置文件；
				/lib/security/*：PAM 模块档案的实际放置目录；
				/etc/security/*：其他 PAM 环境的配置文件；
				/usr/share/doc/pam-*/：详细的 PAM 说明文件。
			例如鸟哥使用未 update 过的 CentOS 5.2 ，pam_nologin 说明文件档在： /usr/share/doc/pam-0.99.6.2/txts/README.pam_nologin。
			pam_securetty.so： 限制系统管理员 (root) 只能够从安全的 (secure) 终端机登入；那什么是终端机？例如 tty1, tty2 等就是传统的终端机装置名称。那举安全癿终端机训定呢？ 就写在 /etc/securetty 这个档案中。你可以查阅一下该档案， 就知道为什么 root 可以从 tty1~tty7 登入，但即无法透过 telnet 登入 Linux 主机了！
			pam_nologin.so： 这个模块可以限制一般用户是否能够登入主机之用。当 /etc/nologin 这个档案存在时，则所有一般使用者均无法再登入系统了！若 /etc/nologin 存在，则一般使用者在登入时， 在他们的终端机上会将该档案的内容显示出来！所以，正常的情况下，这个档案应该是不能存在系统中的。 但这个模块对 root 以及已经登入系统中的一般账号并没有影响。
			pam_selinux.so： SELinux 是个针对程序来进行细部管理权限的功能，SELinux 这玩意儿我们会在第十七章的时候再来详细谈论。由于 SELinux 会影响到用户执行程序的权限，因此我们利用 PAM 模块，将 SELinux 暂时关闭，等到验证通过后， 再予以启动！
			pam_console.so： 当系统出现某些问题，或者是某些时刻你需要使用特殊的终端接口 (例如 RS232 之类的终端联机设备) 登入主机时， 这个模块可以帮助处理一些档案权限的问题，让使用者可以透过特殊终端接口 (console) 顺利的登入系统。
			pam_loginuid.so： 我们知道系统账号与一般账号的 UID 是不同的！一般账号 UID 均大于 500 才合理。 因此，为了验证使用者的 UID 真的是我们所需要的数值，可以使用这个模块来进行规范！
			pam_env.so： 用来设定环境变量的一个模块，如果你有需要额外的环境变量设定，可以参考 /etc/security/pam_env.conf 这个档案的详细说明。
			pam_unix.so： 这是个很复杂且重要的模块，这个模块可以用在验证阶段的认证功能，可以用在授权阶段的账号许可证管理， 可以用在会话阶段的登录文件记录等，甚至也可以用在密码更新阶段的检验！非常丰富的功能！ 这个模块在早期使用得相当频繁喔！
			pam_cracklib.so： 可以用来检验密码的强度！包括密码是否在字典中，密码输入几次都失败就断掉此次联机等功能，都是这模块提供的！ 这玩意儿很重要！
			pam_limits.so： 还让得我们在十一章谈到的 ulimit 吗？ 其实那就是这个模块提供的能力！还有更多细部的设定可以参考： /etc/security/limits.conf 内的说明。
			总之，就是依据验证类别 (type) 来看，然后先由 login 的设定值去查阅，如果出现『 include system-auth 』 就转到 system-auth 档案中的相同类别，去取得额外的验证流程就是了。然后再到下一个验证类别，最终将所有的验证跑完！ 就结束这次的 PAM 验证啦！
		其他相关档案
			除了前一小节谈到的 /etc/securetty 会影响刡 root 可登入的安全终端机， /etc/nologin 会影响到一般使用者是否能够登入的功能之外，我们也知道 PAM 相关的配置文件在 /etc/pam.d ， 说明文件在 /usr/share/doc/pam-(版本) ，模块实际在 /lib/security/ 。那么还有没有相关的 PAM 档案呢？ 是有的，主要都在 /etc/security 这个目录内！我们底下介绍几个可能会用到的配置文件喔！
			limits.conf
				我们在第十一章谈到的 ulimit 功能中， 除了修改使用者的 ~/.bashrc 配置文件之外，其实系统管理员可以统一藉由 PAM 来管理的！ 那就是 /etc/security/limits.conf 这个档案的设定了。这个档案的设定很简单，你可以自行参考一下该档案内容。 我们这里仅作个简单的介绍： 
					范例一：vbird1 这个用户只能建立 100MB 的档案，且大于 90MB 会警告 
						[root@www ~]# vi /etc/security/limits.conf 
						vbird1 soft fsize 90000 
						vbird1 hard fsize 100000 
						#账号 限制依据 限制项目 限制值 
						# 第一字段为账号，或者是群组！若为群组则前面需要加上 @ ，例如 @projecta
						# 第二字段为限制的依据，是严格(hard)，还是仅为警告(soft)； 
						# 第三字段为相关限制，此例中限制档案容量， 
						# 第四字段为限制的值，在此例中单位为 KB。 
						# 若以 vbird1 登入后，进行如下的操作则会有相关的限制出现！
					这个档案挺有趣的，而且是设定完成就生效了，你不用重新启动任何服务的！ 但是 PAM 有个特殊的地方，由于他是在程序呼叫时才予以设定的，因此你修改完成的数据， 对于已登入系统中的用户是没有效果的，要等他再次登入时才会生效喔！另外， 上述的设定请在测试完成后立刻批注掉，否则下次这两个使用者登入就会发生分歧问题啦！ ^_^
			/var/log/secure, /var/log/messages
				如果发生任何无法登入或者是产生一些你无法预期的错误时，由于 PAM 模块都会将数据记载在 /var/log/secure 弼中，所以发生了问题请务必到该档案内去查询一下问题点！
	Linux 主机上的用户讯息传逑递
		查询使用者： w, who, last, lastlog
			lastlog 会去读取 /var/log/lastlog 档案
		使用者对谈： write, mesg, wall
			[root@www ~]# write 使用者账号 [用户所在终端接口]
			[root@www ~]# write vbird1 pts/2 
			Hello, there: 
			Please don't do anything wrong... <==这两行是 root 写的信息！ # 结束时，请按下 [crtl]-d 来结束输入。
			此时在 vbird1 的画面中，会出现：
				Message from root@www.vbird.tsai on pts/1 at 13:23 ... 
				Hello, there: 
				Please don't do anything wrong... 
				EOF
			如果 vbird1 这个人不想要接受任何讯息，直接下达这个东作： 
				[vbird1@www ~]$ mesg n 
				[vbird1@www ~]$ mesg is n
			如果想要解开的话，再次下达『 mesg y 』就好啦！想要知道目前的 mesg 状态，直接下达『 mesg 』即可
			对所有系统上面的用户传送简讨 (广播)』哩～ 如何下达？用 wall 即可啊！他的语法也是很简单的喔！ 
				[root@www ~]# wall "I will shutdown my linux server..."
		使用者邮件信箱： mail
			一般来说， mailbox 都会放置在 /var/spool/mail 里面，一个账号一个 mailbox (档案)。 举例来说，我的 vbird1 就具有 /var/spool/mail/vbird1 这个 mailbox 喔！
			那么我该如何寄出信件呢？就直接使用 mail 这个指令即可！这个指令的用法很简单的，直接这样下达：『 mail username@localhost -s "邮件标题" 』即可！ 一般来说，如果是寄给本机上的使用者，基本上，连『 @localhost 』都不用写啦！ 
				举例来说，我以 root 寄信给 vbird1 ，信件标题是『 nice to meet you 』，则： 
					[root@www ~]# mail vbird1 -s "nice to meet you" 
					Hello, D.M. Tsai 
					Nice to meet you in the network. 
					You are so nice. byebye! 
					. <==这里很重要喔，结束时，最后一行输入小数点 . 即可！ 
					Cc: <==这里是所谓的『副本』，不需要寄给其他人，所以直接 [Enter] 
					[root@www ~]# <==出现提示字符，表示输入完毕了！
			因为在信件编写的过程中，如果写错字而按下 Enter 进入次行，前一行的数据很难删除的！ 那怎么办？没关系啦！我们使用数据流重导向啊！呵呵！利用那个小于的符号 ( < ) 就可以达到取代键盘输入的要求了。也就是说，你可以先用 vi 将信件内容编好， 然后再以 mail vbird1 -s "nice to meet you" < filename 来将档案内容传输即可。
			那么如果是要收信呢？呵呵！同样的使用 mail 啊！ 假设我以 vbird1 的身份登入主机，然后输入 mail 后，会得到什么？ 
				[vbird1@www ~]$ mail 
				Mail version 8.1 6/6/93. Type ? for help. 
				"/var/spool/mail/vbird1": 1 message 1 new 
				>N 1 root@www.vbird.tsai Wed Mar 4 13:36 18/663 "nice to meet you" 
				& <==这里可以输入很多的指令，如果要查阅，输入 ? 即可！
			在 mail 当中的提示字符是 & 符号喔，别搞错了～输入 mail 之后，我可以看到我有一封信件， 这封信件的前面那个 > 代表目前处理的信件，而在大于符号的左边那个 N 代表该封信件尚未读过， 如果我想要知道这个 mail 内部的指令有哪些，可以在 & 之后输入『 ? 』，就可以看到如下的画面： 
				& ? 
				Mail Commands 
				t <message list> type messages n goto and type next message 
				e <message list> edit messages 
				f <message list> give head lines of messages 
				d <message list> delete messages 
				s <message list> file append messages to file 
				u <message list> undelete messages 
				R <message list> reply to message senders 
				r <message list> reply to message senders and all recipients 
				pre <message list> make messages go back to /usr/spool/mail 
				m <user list> mail to specific users 
				q quit, saving unresolved messages in mbox 
				x quit, do not remove system mailbox 
				h print out active message headers 
				! shell escape 
				cd [directory] chdir to directory or home if none given
			<message list> 指的是每封邮件的左边那个数字啦！而几个比较常见的指令是： 
				指令 	意义 
				h 		列出信件标头；如果要查阅 40 封信件左右的信件标头，可以输入『 h 40 』 
				d 		删除后续接的信件号码，删除单封是『 d10 』，删除 20~40 封则为『 d20-40 』。 不过，这个动作要生效的话，必须要配合 q 这个指令才行(参考底下说明)！ 
				s 		将信件储存成档案。例如我要将第 5 封信件的内容存成 ~/mail.file:『s 5 ~/mail.file』 
				x 		或者输入 exit 都可以。这个是『不作任何动作离开 mail 程序』的意思。 不论你刚刚删除了什么信件，或者读过什么，使用 exit 都会直接离开 mail，所以刚刚进行的删除与阅读工作都会无效。 如果您只是查阅一下邮件而已的话，一般来说，建议使用这个离开啦！除非你真的要删除某些信件。 
				q 		相对于 exit 是不动作离开， q 则会进行两项动作： 1. 将刚刚删除的信件移出 mailbox 之外； 2. 将刚刚有阅读过的信件存入 ~/mbox ，且移出 mailbox 之外。鸟哥通常不很喜欢使用 q 离开， 因为，很容易忘让读过什么咚咚～导致信件给他移出 mailbox 说～
				由于读过的信件若使用『 q 』来离开 mail 时，会将该信件移动到 ~/mbox 中，所以你可以这样想象： 
					/var/spool/mail/vbird1 为 vbird1 的『新件匣』，而 /home/vbird1/mbox 则为『收件匣』的意思。 
				那如何读取 /home/vbird1/mbox 呢？就使用『mail -f /home/vbird1/mbox』即可。
	手动新增使用者		
		一些检查工具
			pwck
				pwck 这个指令在检查 /etc/passwd 这个账号配置文件内的信息，与实际的家目录是否存在等信息， 还可以比对 /etc/passwd /etc/shadow的信息是否一致，另外，如果 /etc/passwd 内的数据字段错误时，会提示使用者修订。 一般来说，我只是利用这个玩意儿来检查我的输入是否正确就是了。
			pwconv
				这个指令主要的目的是在『将 /etc/passwd 内的账号与密码，移动到 /etc/shadow 当中！』 早期的 Unix 系统当中并没有 /etc/shadow 呢，所以，用户的登入密码早期是在 /etc/passwd 的第二栏，后来为了系统安全，才将密码数据移动到 /etc/shadow 内的。使用 pwconv 后，可以：
					比对 /etc/passwd 及 /etc/shadow ，若 /etc/passwd 内存在的账号并没有对应的/etc/shadow 密码时，则 pwconv 会去 /etc/login.defs 取用相关的密码数据，并建立该账号的 /etc/shadow 数据；
					若 /etc/passwd 内存在加密后的密码数据时，则 pwconv 会将该密码栏移动到 /etc/shadow 内，并将原本的 /etc/passwd 内相对应的密码栏变成 x ！
			pwunconv
				相对于 pwconv ， pwunconv 则是『将 /etc/shadow 内的密码栏数据写回 /etc/passwd 当中， 并且初除 /etc/shadow 档案。』
			chpasswd
				chpasswd 是个挺有趣的指令，他可以『读入未加密前的密码，并且经过加密后， 将加密后的密码写入 /etc/shadow 当中。』这个指令很常被使用在大量建置账号的情况中喔！ 他可以由 Standard input 读入数据，每笔数据的格式是『 username:password 』。 举例来说，我的系统当中有个用户账号为 dmtsai ，我想要更新他的密码 (update) ， 假如他的密码是 abcdefg 的话，那么我可以这样做： [root@www ~]# echo "dmtsai:abcdefg" | chpasswd -m
				神奇吧！这样就可以更新了呢！在预设的情况中， chpasswd 使用的是 DES 加密方法来加密， 我们可以使用 chpasswd -m 来使用 CentOS 5.x 预设的 MD5 加密方法。这个指令虽然已经很好用了，不过 CentOS 5.x 其实已经提供了『 passwd --stdin 』的选项，老实说，这个 chpasswd 可以不必使用了。
		特殊账号，如纯数字账号的手工建立
			为啥我们不建议使用纯数字的账号了！因为很多时候，系统会搞不清楚那组数字是『账号』还是『 UID 』
			整个动作是这样的：
			1. 先建立所需要的群组 ( vi /etc/group )；
			2. 将 /etc/group 与 /etc/gshadow 同步化 ( grpconv )；
			3. 建立账号的各个属性 ( vi /etc/passwd )；
			4. 将 /etc/passwd 与 /etc/shadow 同步化 ( pwconv )；
			5. 建立该账号的密码 ( passwd accountname )；
			6. 建立用户家目录 ( cp -a /etc/skel /home/accountname )；
			7. 更改用户家目录的属性 ( chown -R accountname.group /home/accountname )。
		大量建置账号模板(适用 passwd --stdin 选项)
		大量建置账号的范例(适用于连续数字，如学号)	
	重点回顾
		/etc/passwd 档案结构以冒号隔开，共分为七个字段，分别是『账号名称、密码、UID、GID、全名、家目录、shell』
		账号的密码已经移动到 /etc/shadow 档案中，该档案权限为仅有 root 可以更动。该档案分为九个字段，内容为『 账号名称、加密密码、密码更动日期、密码最小可变动日期、密码最大需变动日期、密码过期前警告日数、密码失效天数、 账号失效日、保留未使用』
		root 的 UID 与 GID 均为 0 ，所以要让 test 变成 root 的权限，那么就将 /etc/passwd 里面， test 的UID 与 GID 字段变成 0 即可！
		我在使用 useradd 的时候，新增的账号里面的 UID, GID 还有其他相关的密码控制，都是在哪几个档案里面设定的？
			在 /etc/login.defs 还有 /etc/default/useradd 里面规定好的！
			
			
第十五章、磁盘配额(Quota)与进阶文件系统管理			
	磁盘配额 (Quota) 的应用与实作	
		什么是 Quota
			Quota 的一般用途
				限制某一群组所能使用的最大磁盘配额 (使用群组限制)
				限制某一用户的最大磁盘配额 (使用用户限制)
				以 Link 的方式，来使邮件可以作为限制的配额 (更改 /var/spool/mail 这个路径)： 如果是分为付费与不付费会员的『邮件主机系统』，是否需要重新再规划一个硬盘呢？ 也不需要啦！直接使用 Link 的方式指向 /home (或者其他已经做好的 quota 磁盘) 就可以啦！ 这通常是用在原本磁盘分区的规划不好，但是却又不想要更动原有主机架构的情况中啊！
			Quota 的使用限制
				仅能针对整个 filesystem：
				核心必须支持 quota
					如果你是使用 CentOS 5.x 的预设核心，你的系统已经默认有支持 quota 这个功能啰！如果你是自行编译核心的， 那么请特别留意你是否已经『真的』开启了 quota 这个功能
				Quota 的记录文件
					目前新版的 Linux distributions 使用的是 Kernel 2.6.xx 的核心版本，这个核心版本支持新的 quota 模块，使用的默认档案 (aquota.user, aquota.group )将不同于旧版本的 quota.user, quota.group ！ (多了一个 a 呦！) 而由旧版本的 quota 可以藉由 convertquota 这个程序来转换呢！
				只对一般身份使用者有效
			Quota 的规范设定顷目
				容量限制或档案数量限制 (block 或 inode)：
				柔性劝导与硬性规定 (soft/hard)：
					既然是规范，当然就有限制值。不管是 inode/block ，限制值都有两个，分别是 soft 与  hard。 通常 hard 限制值要比 soft 还要高。
						hard：表示使用者的用量绝对不会超过这个限制值，若超过这个值则系统会锁住该用户的磁盘使用权；
						soft：表示使用者在低于 soft 限值时 (此例中为 400Mbytes)，可以正常使用磁盘，但若超过 soft 且低于 hard 的限值 (介于 400~500Mbytes 之间时)，每次用户登入系统时，系统会主动发出磁盘即将爆满的警告讯息， 且会给予一个宽限时间 (grace time)。不过，若使用者在宽限时间倒数期间就将容量再次降低于 soft 限值之下， 则宽限时间会停止。
				会倒数计时的宽限时间 (grace time)：
					刚刚上面就谈到宽限时间了！这个宽限时间只有在用户的磁盘用量介于 soft 到 hard 之间时，才会出现且会倒数的一个咚咚！ 由于达到 hard 限值时，用户的磁盘使用权可能会被锁住。为了担心用户没有注意到这个磁盘配额的问题， 因此设计了 soft 。当你的磁盘用量即将到达 hard 且超过 soft 时，系统会给予警告，但也会给一段时间让用户自行管理磁盘。 一般预设的宽限时间为七天，如果七天内你都不进行任何磁盘管理，那么 soft 限制值会即刻取代 hard 限值来作为 quota 的限制。
		实作 Quota 流程-1：文件系统支援
			如果只是想要在这次开机中实验 Quota ，那么可以使用如下的方式来手动加入 quota 的支持： 
				[root@www ~]# mount -o remount,usrquota,grpquota /home 
				[root@www ~]# mount | grep home 
				/dev/hda3 on /home type ext3 (rw,usrquota,grpquota) # 重点就在于 usrquota, grpquota ！注意写法！
			事实上，当你重新挂载时，系统会同步更新 /etc/mtab 这个档案， 所以你必须要确定 /etc/mtab 已经加入 usrquota, grpquota 的支持到你所想要设定的文件系统中。			
			不过手动挂载的数据在下次重新挂载就会消失，因此最好写入配置文件中啊！在鸟哥这部主机的案例中， 我可以直接修改 /etc/fstab 成为底下这个样子： 
				[root@www ~]# vi /etc/fstab 
				LABEL=/home /home ext3 defaults,usrquota,grpquota 1 2 # 其他项目鸟哥并没有列出来！重点在于第四字段！于 default 后面加上两个参数！ 
				[root@www ~]# umount /home 
				[root@www ~]# mount -a 
				[root@www ~]# mount | grep home 
				/dev/hda3 on /home type ext3 (rw,usrquota,grpquota)
			还是要再次的强调，修改完 /etc/fstab 后，务必要测试一下！若有发生错误得要赶紧处理！ 因为这个档案如果修改错误，是会造成无法开机完全的情况啊！切记切记！最好使用 vim 来修改啦！ 因为会有语法的检验，就不会让你写错字了
		实作 Quota 流程-2：建立 quota 记录文件
			其实 Quota 是透过分析整个文件系统中，每个使用者(群组)拥有的档案总数与总容量， 再将这些数据记录在该文件系统的最顶层目录，然后在该记录文件中再使用每个账号(或群组)的限制值去规范磁盘使用量的。 所以啦，建置这个 Quota 记录文件就显的非常的重要。
			扫瞄有支持 Quota 参数 (usrquota, grpquota) 的文件系统， 就使用 quotacheck 这个指令！这个指令的语法如下：
				[root@www ~]# quotacheck [-avugfM] [/mount_point] 
				选顷与参数： 
					-a ：扫瞄所有在 /etc/mtab 内，含有 quota 支持的 filesystem，加上此参数后， /mount_point 可不必写，因为扫瞄所有的 filesystem 了嘛！ 
					-u ：针对用户扫瞄档案与目录的使用情况，会建立 aquota.user -g ：针对群组扫瞄档案与目录的使用情况，会建立 aquota.group 
					-v ：显示扫瞄过程的信息； 
					-f ：强制扫瞄文件系统，并写入新的 quota 配置文件 (危险) 
					-M ：强制以读写的方式扫瞄文件系统，只有在特殊情况下才会使用。
		实作 Quota 流程-3：Quota 启动、 关闭与限制值设定
			制作好 Quota 配置文件之后，接下来就是要启动 quota 了！启动的方式很简单！使用 quotaon ，至于关闭就用 quotaoff 即可
				[root@www ~]# quotaon [-avug] 
				[root@www ~]# quotaon [-vug] [/mount_point] 
				选项与参数： 
					-u ：针对使用者启动 quota (aquota.user) 
					-g ：针对群组启动 quota (aquota.group) 
					-v ：显示启动过程的相关讯息； 
					-a ：根据 /etc/mtab 内的 filesystem 设定启动有关的 quota ，若不加 -a 的话， 则后面就需要加上特定的那个 filesystem 喔！
				[root@www ~]# quotaoff [-a] 
				[root@www ~]# quotaoff [-ug] [/mount_point] 
				选项与参数： 
					-a ：全部的 filesystem 的 quota 都关闭 (根据 /etc/mtab) 
					-u ：仅针对后面接的那个 /mount_point 关闭 user quota 
					-g ：仅针对后面接的那个 /mount_point 关闭 group quota
				[root@www ~]# edquota [-u username] [-g groupname] 
				[root@www ~]# edquota -t <==修改宽限时间 
				[root@www ~]# edquota -p 范本账号 -u 新账号 
				选项与参数： 
					-u ：后面接账号名称。可以进入 quota 的编辑画面 (vi) 去设定 username 的限制值； 
					-g ：后面接组名。可以进入 quota 的编辑画面 (vi) 去设定 groupname 的限制值； 
					-t ：可以修改宽限时间。 
					-p ：复制范本。那个 模板账号 为已经存在并且已设定好 quota 的使用者， 意义为『将 范本账号 这个人的 quota 限制值复制给 新账号 』！
					上头第一行在说明针对哪个账号 (myquota1) 进行 quota 的限额设定，第二行则是标头行，里面共分为七个字段， 七个字段分别的意义为：
						1. 文件系统 (filesystem)：说明该限制值是针对哪个文件系统 (或 partition)；
						2. 磁盘容量 (blocks)：这个数值是 quota 自己算出来的，单位为 Kbytes，请不要更动他；
						3. soft：磁盘容量 (block) 的 soft 限制值，单位亦为 KB
						4. hard：block 的 hard 限制值，单位 KB；
						5. 档案数量 (inodes)：这是 quota 自己算出来的，单位为个数，请不要更动他；
						6. soft：inode 的 soft 限制值；
						7. hard：inode 的 hard 限制值；
					当 soft/hard 为 0 时，表示没有限制的意思。
		实作 Quota 流程-4：Quota 限制值的报表
			quota ：单一用户的 quota 报表
				[root@www ~]# quota [-uvs] [username] 
				[root@www ~]# quota [-gvs] [groupname] 
				选项与参数： 
					-u ：后面可以接 username ，表示显示出该用户的 quota 限制值。若不接 username ，表示显示出执行者的 quota 限制值。 
					-g ：后面可接 groupname ，表示显示出该群组的 quota 限制值。 
					-v ：显示每个用户在 filesystem 的 quota 值； 
					-s ：使用 1024 为倍数来指定单位，会显示如 M 之类的单位！
			repquota ：针对文件系统的限额做报表 
				[root@www ~]# repquota -a [-vugs] 
				选项与参数： 
					-a ：直接到 /etc/mtab 搜寻具有 quota 标志的 filesystem ，并报告 quota 的结果； 
					-v ：输出的数据将含有 filesystem 相关的细部信息； 
					-u ：显示出用户的 quota 限值 (这是默认值)； 
					-g ：显示出个别群组的 quota 限值。 
					-s ：使用 M, G 为单位显示结果
		实作 Quota 流程-5：测试与管理
			warnquota字面上的意义就是 quota 的警告 (warn) 嘛！那么这东西有什么用呢？他可以依据 /etc/warnquota.conf 的设定，然后找出目前系统上面 quota 用量超过 soft (就是有 grace time 出现的那些家伙) 的账号，透过 email 的功能将警告信件发送到用户的电子邮件信箱。 warnquota 并不会自动执行，所以我们需要手动去执行他。
			setquota ：直接于指令中设定 quota 限额
				[root@www ~]# setquota [-u|-g] 名称 block(soft) block(hard) \ 
				> inode(soft) inode(hard) 文件系统
					[root@www ~]# setquota -u myquota5 100000 200000 0 0 /home
		不更动既有系统的 quota 实例
			既然 quota 是针对整个 filesystem 来进行限制，假设你又已经有 /home 这个独立的分割槽了， 那么你只要：
				1. 将 /var/spool/mail 这个目录完整的移动到 /home 底下；
				2. 利用 ln -s /home/mail /var/spool/mail 来建立链接数据；
				3. 将 /home 进行 quota 限额设定
			只要这样的一个小步骤，嘿嘿！您家主机的邮件就有一定的限额啰！当然啰！您也可以依据不同的使用者与群组来设定 quota 然后同样的以上面的方式来进行 link 的动作
	软件磁盘阵列 (Software RAID)
		磁盘阵列全名是『 Redundant Arrays of Inexpensive Disks, RAID 』，英翻中的意思是：容错式廉价磁盘阵列。 RAID 可以透过一个技术(软件或硬件)，将多个较小的磁盘整合成为一个较大的磁盘装置； 而这个较大的磁盘功能可不止是储存而已，他还具有数据保护的功能呢。整个 RAID 由于选择的等级 (level) 不同，而使得整合后的磁盘具有不同的功能， 基本常见的 level 有这几种
			RAID-0 (等量模式, stripe)：效能最佳
				这种模式如果使用相同型号与容量的磁盘来组成时，效果较佳。这种模式的 RAID 会将磁盘先切出等量的区块 (举例来说， 4KB)， 然后当一个档案要写入 RAID 时，该档案会依据区块的大小切割好，之后再依序放到各个磁盘里面去。由于每个磁盘会交错的存放数据， 因此当你的数据要写入 RAID 时，数据会被等量的放置在各个磁盘上面。
				只是使用此等级你必须要自行负担数据损毁的风险，由上图我们知道档案是被切割成为适合每颗磁盘分区区块的大小， 然后再依序放置到各个磁盘中。想一想，如果某一颗磁盘损毁了，那么档案数据将缺一块，此时这个档案就损毁了。 由于每个档案都是这样存放的，因此 RAID-0 只要有任何一颗磁盘损毁，在 RAID 上面的所有数据都会遗失而无法读取。
				如果使用不同容量的磁盘来组成 RAID-0 时，由于数据是一直等量的依序放置到不同磁盘中，当小容量磁盘的区块被用完了， 那么所有的数据都将被写入到最大的那颗磁盘去。
			RAID-1 (映像模式, mirror)：完整备份
				这种模式也是需要相同的磁盘容量的，最好是一模一样的磁盘啦！如果是不同容量的磁盘组成 RAID-1 时，那么总容量将以最小的那一颗磁盘为主！这种模式主要是『让同一仹数据，完整的保存在两颗磁盘上头』
			RAID 0+1，RAID 1+0
				。所谓的 RAID 0+1 就是： (1)先让两颗磁盘组成 RAID 0，并且这样的设定共有两组； (2)将这两组 RAID 0 再组成一组 RAID 1。这就是 RAID 0+1 啰！反过来说，RAID 1+0 就是先组成 RAID-1 再组成 RAID-0 的意思。
			RAID 5：效能与数据备份的均衡考虑
				RAID-5 至少需要三颗以上的磁盘才能够组成这种类型的磁盘阵列。这种磁盘阵列的数据写入有点类似 RAID-0 ， 不过每个循环的写入过程中，在每颗磁盘还加入一个同位检查数据 (Parity) ，这个数据会记录其他磁盘的备份数据， 用于当有磁盘损毁时的救援
				每个循环写入时，都会有部分的同位检查码 (parity) 被记录起来，并且记录的同位检查码每次都记录在不同的磁盘， 因此，任何一个磁盘损毁时都能够藉由其他磁盘的检查码来重建原本磁盘内的数据喔！不过需要注意的是， 由于有同位检查码，因此 RAID 5 的总容量会是整体磁盘数量减一颗。以上图为例， 原本的 3 颗磁盘只会剩下 (3-1)=2 颗磁盘的容量。而且当损毁的磁盘数量大于等亍两颗时，这整组 RAID 5 的资料就损毁了。 因为 RAID 5 预设仅能支持一颗磁盘的损毁情况。
				当磁盘阵列的磁盘损毁时，就得要将坏掉的磁盘拔除，然后换一颗新的磁盘。换成新磁盘并且顸利启动磁盘阵列后， 磁盘阵列就会开始主动的重建 (rebuild) 原本坏掉的那颗磁盘数据到新的磁盘上！然后你磁盘阵列上面的数据就复原了！ 这就是磁盘阵列的优点。
			磁盘阵列的优点
				数据安全与可靠性：指的并非信息安全，而是当硬件 (指磁盘) 损毁时，数据是否还能够安全的救援或使用之意；
				读写效能：例如 RAID 0 可以加强读写效能，让你的系统 I/O 部分得以改善；
				容量：可以让多颗磁盘组合起来，故单一文件系统可以有相当大的容量。
		software, hardware RAID
			所谓的硬件磁盘阵列 (hardware RAID) 是透过磁盘阵列卡来达成数组的目的。 磁盘阵列卡上面有一块专门的芯片在处理 RAID 的任务，因此在效能方面会比较好。在很多任务 (例如 RAID 5 的同位检查码计算) 磁盘阵列并不会重复消耗原本系统的 I/O 总线，理论上效能会较佳。此外目前一般的中高阶磁盘阵列卡都支持热拔插， 亦即在不关机的情况下抽换损坏的磁盘，对于系统的复原与数据的可靠性方面非常的好用。
			软件磁盘阵列主要是透过软件来仿真数组的任务， 因此会损耗较多的系统资源，比如说 CPU 的运算与 I/O 总线的资源等。
			我们的 CentOS 提供的软件磁盘阵列为 mdadm 这套软件，这套软件会以 partition 或 disk 为磁盘的单位，也就是说，你不需要两颗以上的磁盘，只要有两个以上的分割槽 (partition) 就能够设计你的磁盘阵列了。此外， mdadm 支持刚刚我们前面提到的 RAID0/RAID1/RAID5/spare disk 等！ 而且提供的管理机制还可以达到类似热拔插的功能，可以在线 (文件系统正常使用) 进行分割槽的抽换！ 使用上也非常的方便呢！ 另外你必项要知道的是，硬件磁盘阵列在 Linux 底下看起来就是一颗实际的大磁盘，因此硬件磁盘阵列的装置文件名为 /dev/sd[a-p] ，因为使用到 SCSI 的模块之故。至于软件磁盘阵列则是系统仿真的，因此使用的装置文件名是系统的装置文件， 文件名为 /dev/md0, /dev/md1...，两者的装置文件名并不相同！不要搞混了喔！
		软件磁盘阵列的设定
			[root@www ~]# mdadm --detail /dev/md0 
			[root@www ~]# mdadm --create --auto=yes /dev/md[0-9] --raid-devices=N \ 
			> --level=[015] --spare-devices=N /dev/sdx /dev/hdx... 
			选项与参数： 
				--create ：为建立 RAID 的选项； 
				--auto=yes ：决定建立后面接的软件磁盘阵列装置，亦即 /dev/md0,/dev/md1... 
				--raid-devices=N ：使用几个磁盘 (partition) 作为磁盘阵列的装置 
				--spare-devices=N ：使用几个磁盘作为备用 (spare) 装置 
				--level=[015] ：设定这组磁盘阵列的等级。支持很多，不过建议只要用 0, 1, 5 即可 
				--detail ：后面所接的那个磁盘阵列装置的详细信息
			上面的语法中，最后面会接很多的装置文件名，这些装置文件名可以是整颗磁盘，例如 /dev/sdb ， 也可以是分割槽，例如 /dev/sdb1 之类。不过，这些装置文件名的总数必项要等于 --raid-devices 与 --spare-devices 的个数总和才行
			除了指令之外，你也可以查阅如下的档案来看看系统软件磁盘阵列的情况： 
				[root@www ~]# cat /proc/mdstat 
				Personalities : [raid6] [raid5] [raid4] 
				md0 : active raid5 hda9[3] hda10[4](S) hda8[2] hda7[1] hda6[0] <==第一行 
				2963520 blocks level 5, 64k chunk, algorithm 2 [4/4] [UUUU] <==第二行 unused devices: <none>
				上述的资料比较重要的在特别指出的第一行与第二行部分(注2)：
					第一行部分：指出 md0 为 raid5 ，并使用了 hda9, hda8, hda7, hda6 等四颗磁盘装置。每个装置后面的中括号 [] 内的数字为此磁盘在 RAID 中的顺序 (RaidDevice)；至于 hda10 后面的 [S] 则代表 hda10 为 spare 之意。
					第二行：此磁盘阵列拥有 2963520 个block(每个 block 单位为 1K)，所以总容量约为 3GB， 使用 RAID 5 等级，写入磁盘的小区块 (chunk) 大小为 64K，使用 algorithm 2 磁盘阵列算法。 [m/n] 代表此数组需要 m 个装置，且 n 个装置正常运作。因此本 md0 需要 4 个装置且这 4 个装置均正常运作。 后面的 [UUUU] 代表的是四个所需的装置 (就是 [m/n] 里面的 m) 的启动情况，U 代表正常运作，若为 _ 则代表不正常。
		仿真 RAID 错误的救援模式
			[root@www ~]# mdadm --manage /dev/md[0-9] [--add 装置] [--remove 装置] \ 
			> [--fail 装置] 
			选项与参数： 
				--add ：会将后面的装置加入到这个 md 中！ 
				--remove ：会将后面的装置由这个 md 中移除 
				--fail ：会将后面的装置设定成为出错的状态
		开机自动启动 RAID 并自动挂载
			新的 distribution 大多会自己搜寻 /dev/md[0-9] 然后在开机的时候给予设定好所需要的功能。不过鸟哥还是建议你， 修改一下配置文件吧！ ^_^。software RAID 也是有配置文件的，这个配置文件在 /etc/mdadm.conf ！这个配置文件内容很简单， 你只要知道 /dev/md0 的 UUID 就能够设定这个档案啦！
		关闭软件 RAID(重要！)
			为什么要关掉他呢？因为这个 /dev/md0 其实还是使用到我们系统的磁盘分区槽， 在鸟哥的例子里面就是 /dev/hda{6,7,8,9,10,11}，如果你只是将 /dev/md0 卸除，然后忘记将 RAID 关闭， 结果就是....未来你在重新分割 /dev/hdaX 时可能会出现一些莫名的错误状况啦！所以才需要关闭 software RAID 的步骤！ 
			那如何关闭呢？也是简单到爆炸！(请注意，确认你的 /dev/md0 确实不要用且要关闭了才进行底下的玩意儿) # 
				1. 先卸除且删除配置文件内与这个 /dev/md0 有关的设定： 
					[root@www ~]# umount /dev/md0 
					[root@www ~]# vi /etc/fstab 
					/dev/md0 /mnt/raid ext3 defaults 1 2 # 将这一行删除掉！或者是批注掉也可以！ # 
				2. 直接关闭 /dev/md0 的方法！ 
					[root@www ~]# mdadm --stop /dev/md0 
					mdadm: stopped /dev/md0 <==不啰唆！这样就关闭了！ 
					[root@www ~]# cat /proc/mdstat 
					Personalities : [raid6] [raid5] [raid4] 
					unused devices: <none> <==看吧！确实不存在任何数组装置！ 
					[root@www ~]# vi /etc/mdadm.conf 
					ARRAY /dev/md0 UUID=7c60c049:57d60814:bd9a77f1:57e49c5b # 一样啦！删除他或是批注他！
	逡辑滚动条管理员 (Logical Volume Manager)
		LVM 的重点在于『可以弹性的调整 filesystem 的容量！』而并非在于效能与数据保全上面。 需要档案的读写效能或者是数据的可靠性，请参考前面的 RAID 小节。 LVM 可以整合多个实体 partition 在一起， 让这些 partitions 看起来就像是一个磁盘一样！而且，还可以在未来新增或移除其他的实体 partition 到这个 LVM 管理的磁盘当中。 如此一来，整个磁盘空间的使用上，实在是相当的具有弹性啊！
		什么是 LVM： PV, PE, VG, LV 的意义
			LVM 的全名是 Logical Volume Manager，中文可以翻译作逻辑滚动条管理员。之所以称为『滚动条』可能是因为可以将 filesystem 像滚动条一样伸长或缩短之故吧！LVM 的作法是将几个实体的 partitions (或 disk) 透过软件组合成为一块看起来是独立的大磁盘 (VG) ，然后将这块大磁盘再经过分割成为可使用分割槽 (LV)， 最终就能够挂载使用了。但是为什么这样的系统可以进行 filesystem 的扩充或缩小呢？其实与一个称为 PE 的项目有关！
			Physical Volume, PV, 实体滚动条
				我们实际的 partition 需要调整系统标识符 (system ID) 成为 8e (LVM 的标识符)，然后再经过pvcreate 的指令将他转成 LVM 最底层的实体滚动条 (PV) ，之后才能够将这些 PV 加以利用！ 调整 system ID 的方是就是透过 fdisk 啦！
			Volume Group, VG, 滚动条群组
				所谓的 LVM 大磁盘就是将讲多 PV 整合成这个 VG 的东西就是啦！所以 VG 就是 LVM 组合起来的大磁盘！这么想就好了。 那么这个大磁盘最大可以到多少容量呢？这与底下要说明的 PE 有关喔～因为每个 VG 最多仅能包含 65534 个 PE 而已。 如果使用 LVM 预设的参数，则一个 VG 最大可达 256GB 的容量啊！(参考底下的 PE 说明)
			Physical Extend, PE, 实体延伸区块
				LVM 预设使用 4MB 的 PE 区块，而 LVM 的 VG 最多仅能含有 65534 个 PE ，因此预设的 LVM VG 会有 4M*65534/(1024M/G)=256G。 这个 PE 很有趣喔！他是整个 LVM 最小的储存区块，也就是说，其实我们的档案资料都是藉由写入 PE 来处理的。 简单的说，这个 PE 就有点像文件系统里面的 block 大小啦。 这样说应该就比较好理解了吧？所以调整 PE 会影响到 VG 的最大容量喔！
			Logical Volume, LV, 逡辑滚动条
				最终的 VG 还会被切成 LV，这个 LV 就是最后可以被格式化使用的类似分割槽的咚咚了！那么 LV 是否可以随意指定大小呢？ 当然不可以！既然 PE 是整个 LVM 的最小储存单位，那么 LV 的大小就不在此 LV 内的 PE 总数有关。 为了方便用户利用 LVM 来管理其系统，因此 LV 的装置文件名通常指定为『 /dev/vgname/lvname 』的样式！ 此外，我们刚刚有谈到 LVM 可弹性的变更 filesystem 的容量，那是如何办到的？其实他就是透过『交换 PE 』来进行数据转换， 将原本 LV 内的 PE 移转到其他装置中以降低 LV 容量，或将其他装置的 PE 加到此 LV 中以加大容量！
			透过 PV, VG, LV 的规划之后，再利用 mkfs 就可以将你的 LV 格式化成为可以利用的文件系统了！而且这个文件系统的容量在未来还能够进行扩充或减少， 而且里面的数据还不会被影响！
			那么我的数据写入这个 LV 时，到底他是怎么写入硬盘当中的？ 呵呵！好问题～其实，依据写入机制的不同，而有两种方式：
				线性模式 (linear)：假如我将 /dev/hda1, /dev/hdb1 这两个 partition 加入到 VG 当中，并且整个 VG 只有一个 LV 时，那么所谓的线性模式就是：当 /dev/hda1 的容量用完之后，/dev/hdb1 的硬盘才会被使用到， 这也是我们所建议的模式。
				交错模式 (triped)：那什么是交错模式？很简单啊，就是我将一笔数据拆成两部分，分别写入 /dev/hda1 与 /dev/hdb1 的意思，感觉上有点像 RAID 0 啦！如此一来，一份数据用两颗硬盘来写入，理论上，读写的效能会比较好。
			基本上，LVM 最主要的用处是在实现一个可以弹性调整容量的文件系统上， 而不是在建立一个效能为主的磁盘上，所以，我们应该利用的是 LVM 可以弹性管理整个 partition 大小的用途上，而不是着眼在效能上的。因此， LVM 默认的读写模式是线性模式啦！
		LVM 实作流程
			PV 阶段
				要建立 PV 其实很简单，只要直接使用 pvcreate 即可！我们来谈一谈与 PV 有关的指令吧！
					pvcreate ：将实体 partition 建立成为 PV ；
					pvscan ：搜寻目前系统里面任何具有 PV 的磁盘；
					pvdisplay ：显示出目前系统上面的 PV 状态；
					pvremove ：将 PV 属性移除，让该 partition 不具有 PV 属性。
			VG 阶段
				建立 VG 及 VG 相关的指令也不少，我们来看看：
					vgcreate ：就是主要建立 VG 的指令啦！他的参数比较多，等一下介绍。
					vgscan ：搜寻系统上面是否有 VG 存在？
					vgdisplay ：显示目前系统上面的 VG 状态；
					vgextend ：在 VG 内增加额外的 PV ；
					vgreduce ：在 VG 内移除 PV；
					vgchange ：讴定 VG 是否启动 (active)；
					vgremove ：删除一个 VG 啊！
				与 PV 不同的是， VG 的名称是自定义的！我们知道 PV 的名称其实就是 partition 的装置文件名， 但是这个 VG 名称则可以随便你自己取啊！
					[root@www ~]# vgcreate [-s N[mgt]] VG名称 PV名称 
					选项与参数： 
						-s ：后面接 PE 的大小 (size) ，单位可以是 m, g, t (大小写均可)
					[root@www ~]# vgextend vbirdvg /dev/hda9
			LV 阶段
				lvcreate ：建立 LV 啦！
				lvscan ：查询系统上面的 LV ；
				lvdisplay ：显示系统上面的 LV 状态啊！
				lvextend ：在 LV 里面增加容量！
				lvreduce ：在 LV 里面减少容量；
				lvremove ：删除一个 LV ！
				lvresize ：对 LV 进行容量大小的调整！ 
				[root@www ~]# lvcreate [-L N[mgt]] [-n LV名称] VG名称
				[root@www ~]# lvcreate [-l N] [-n LV名称] VG名称 
				选项与参数： 
					-L ：后面接容量，容量的单位可以是 M,G,T 等，要注意的是，最小单位为 PE， 因此这个数量必须要是 PE 的倍数，若不相符，系统会自行计算最相近的容量。 
					-l ：后面可以接 PE 的『个数』，而不是数量。若要这么做，得要自行计算 PE 数。 
					-n ：后面接的就是 LV 的名称啦！
		放大 LV 容量
			如果要放大 LV 的容量时， 该如何进行完整的步骤呢:
				1. 用 fdisk 设定新的具有 8e system ID 的 partition
				2. 利用 pvcreate 建置 PV
				3. 利用 vgextend 将 PV 加入我们的 vbirdvg
				4. 利用 lvresize 将新加入的 PV 内的 PE 加入 vbirdlv 中
				5. 透过 resize2fs 将文件系统的容量确实增加！
				其中最后一个步骤最重要！我们在第八章当中知道， 整个文件系统在最初格式化的时候就建立了 inode/block/superblock 等信息，要改变这些信息是很难的！ 不过因为文件系统格式化的时候建置的是多个 block group ，因此我们可以透过在文件系统当中增加 block group 的方式来增减文件系统的量！而增减 block group 就是利用 resize2fs 啦！所以最后一步是针对文件系统来处理的， 前面几步则是针对 LVM 的实际容量大小！
			[root@www ~]# resize2fs [-f] [device] [size] 
			选项与参数： 
				-f ：强制进行 resize 的动作！ [device]：装置的文件名； [size] ：可以加也可以不加。如果加上 size 的话，那么就必项要给予一个单位， 譬如 M, G 等等。如果没有 size 的话，那么预设使用『整个 partition』 的容量来处理！
		缩小 LV 容量
			放大可以在线直接进行，缩小文件系统似乎无法支持，所以要unmount
		LVM 的系统快照
			其实他还有一个重要的能力，那就是系统快照 (snapshot)。 什么是系统快照啊？快照就是将当时的系统信息记录下来，就好像照相记录一般！ 未来若有任何资料更动了，则原始资料会被搬移到快照区，没有被更动的区域则由快照区与文件系统共享。
			LVM 会预留一个区域 (左图的左侧三个 PE 区块) 作为数据存放处。 此时快照区内并没有任何数据，而快照区与系统区共享所有的 PE 数据， 因此你会看到快照区的内容与文件系统是一模一样的。 等到系统运作一阵子后，假设 A 区域的数据被更动了 (上面右图所示)，则更动前系统会将该区域的数据移动到快照区， 所以在右图的快照区被占用了一块 PE 成为 A，而其他 B 到 I 的区块则还是与文件系统共享！
			照这样的情况来看，LVM 的系统快照是非常棒的『备份工具』，因为他只有备份有被更动到的数据， 文件系统内没有被变更的数据依旧保持在原本的区块内，但是 LVM 快照功能会知道那些数据放置在哪里， 因此『快照』当时的文件系统就得以『备份』下来，且快照所占用的容量又非常小！
			由于快照区与原本的 LV 共享很多 PE 区块，因此快照区与被忚照的 LV 必须要在同一个 VG 上头
			# 3. 利用 lvcreate 建立系统快照区，我们取名为 vbirdss，且给予 60 个 PE [root@www ~]# 
				lvcreate -l 60 -s -n vbirdss /dev/vbirdvg/vbirdlv 
				Logical volume "vbirdss" created # 上述的指令中最重要的是那个 -s 的选项！代表是 snapshot 快照功能之意！ # -n 后面接快照区的装置名称， /dev/.... 则是要被快照的 LV 完整档名。 # -l 后面则是接使用多少个 PE 来作为这个快照区使用。
		LVM 相关指令汇整与 LVM 的关闭
			我们将上述用过的一些指令给他汇整一下，提供给您参考参考： 
			任务 			PV 阶段 	VG 阶段 	LV 阶段 	
			搜寻(scan) 		pvscan 		vgscan 		lvscan 
			建立(create) 	pvcreate 	vgcreate 	lvcreate 
			列出(display) 	pvdisplay 	vgdisplay 	lvdisplay 
			增加(extend) 				vgextend 	lvextend (lvresize) 
			减少(reduce) 				vgreduce 	lvreduce (lvresize) 
			删除(remove) 	pvremove 	vgremove 	lvremove 
			改变容量(resize) 						lvresize 
			改变属性(attribute) pvchange vgchange 	lvchange
			你必须要会移除系统内的 LVM 喔！因为你的实体 partition 已经被使用到 LVM 去， 如果你还没有将 LVM 关闭就直接将那些 partition 删除或转为其他用途的话，系统是会发生很大的问题的！ 所以啰，你必须要知道如何将 LVM 的装置关闭并移除才行！会不会很难呢？其实不会啦！ 依据以下的流程来处理即可：
				1. 先卸除系统上面的 LVM 文件系统 (包括快照不所有 LV)；
				2. 使用 lvremove 移除 LV ；
				3. 使用 vgchange -a n VGname 让 VGname 这个 VG 不具有 Active 的标志；
				4. 使用 vgremove 移除 VG：
				5. 使用 pvremove 移除 PV；
				6. 最后，使用 fdisk 修改 ID 回来啊！	
	
		
		
第十六章、例行性工作排程 (crontab)
	什么是例行性工作排程
		Linux 工作排程的种类： at, cron
			at ：at 是个可以处理仅执行一次就结束排程的指令，不过要执行 at 时， 必须要有 atd 这个服务 (第十八章) 的支援才行
			crontab ：crontab 这个指令所设定的工作将会循环的一直进行下去！ 可循环的时间为分钟、小时、每周、每月或每年等。crontab 除了可以使用指令执行外，亦可编辑 /etc/crontab 来支持。 至于让 crontab 可以生效的服务则是 crond 这个服务喔！
		Linux 上常见的例行性工作
			基本上 Linux 系统常见的例行性任务有：
				进行登录档的轮替 (log rotate)：
				登录文件分析 logwatch 的任务： 
					如果系统发生了软件问题、硬件错误、资安问题等，绝大部分的错误信息都会被记录到登录文件中， 因此系统管理员的重要任务之一就是分析登录档。但你不可能手动透过 vim 等软件去检视登录文件，因为数据太复杂了！ 我们的 CentOS 提供了一只程序『 logwatch 』来主动分析登录信息，所以你会发现，你的 root 老是会收到标题为 logwatch 的信件，那是正常的！你最好也能够看看该信件的内容喔！
				建立 locate的数据库：
				whatis 数据库的建立：
				RPM 软件登录文件的建立：
				移除暂存档
					系统透过例行性工作排程执行名为 tmpwatch 的指令来删除这些暂存档呢！
				与网络服务有关的分析行为
	仅执行一次的工作排程
		atd 的启动与 at 运作的方式
			启用的方法很简单，就是这样：
				[root@www ~]# /etc/init.d/atd restart 
				正在停止 atd: [ 确定 ] 
				正在激活 atd: [ 确定 ] # 再设定一下开机时就启动这个服务，免得每次重新启动都得再来一次！ 
				[root@www ~]# chkconfig atd on
			at 的运作方式
				事实上，我们使用 at 这个指令来产生所要运作的工作，并将这个工作以文本文件的方式写入 /var/spool/at/ 目录内，该工作便能等待 atd 这个服务的取用与执行了。
				并不是所有的人都可以进行 at 工作排程喔！为什么？因为安全的理由啊～所以啰，除非是你认可的账号，否则先不要让他们使用 at 吧！那怎么达到使用 at 的列管呢？
				我们可以利用 /etc/at.allow 与 /etc/at.deny 这两个档案来进行 at 的使用限制呢！ 加上这两个档案后， at 的工作情况其实是这样的：
					1. 先找寻 /etc/at.allow 这个档案，写在这个档案中的使用者才能使用 at ，没有在这个档案中的使用者则不能使用 at (即使没有写在 at.deny 当中)；
					2. 如果 /etc/at.allow 不存在，就寻找 /etc/at.deny 这个档案，若写在这个 at.deny 的使用者则不能使用 at ，而没有在这个 at.deny 档案中的使用者，就可以使用 at 咯；
					3. 如果两个档案都不存在，那么只有 root 可以使用 at 这个指令。
		实际运作单一工作排程
			[root@www ~]# at [-mldv] TIME [root@www ~]# at -c 工作号码 
			选项与参数： 
				-m ：当 at 的工作完成后，即使没有输出讯息，亦以 email 通知使用者该工作已完成。 
				-l ：at -l 相当亍 atq，列出目前系统上面的所有该用户的 at 排程； 
				-d ：at -d 相当于 atrm ，可以取消一个在 at 排程中的工作； 
				-v ：可以使用较明显的时间格式栏出 at 排程中的任务栏表； 
				-c ：可以列出后面接的该项工作的实际指令内容。 
				TIME：时间格式，这里可以定义出『什么时候要进行 at 这项工作』的时间，格式有：
					HH:MM ex> 04:00 在今日的 HH:MM 时刻进行，若该时刻已超过，则明天的 HH:MM 进行此工作。 
					HH:MM YYYY-MM-DD ex> 04:00 2009-03-17 强制规定在某年某月的某一天的特殊时刻进行该工作！ 
					HH:MM[am|pm] [Month] [Date] ex> 04pm March 17 也是一样，强制在某年某月某日的某时刻进行！ 
					HH:MM[am|pm] + number [minutes|hours|days|weeks] ex> now + 5 minutes ex> 04pm + 3 days 就是说，在某个时间点『再加几个时间后』才进行。
			范例一：再过五分钟后，将 /root/.bashrc 寄给 root 自己 
			[root@www ~]# at now + 5 minutes <==记得单位要加 s 喔！ 
			at> /bin/mail root -s "testing at job" < /root/.bashrc 
			at> <EOT> <==这里输入 [ctrl] + d 就会出现 <EOF> 的字样！代表结束！ 
			job 4 at 2009-03-14 15:38 # 上面这行信息在说明，第 4 个 at 工作将在 2009/03/14 的 15:38 进行！ # 而执行 at 会进入所谓的 at shell 环境，让你下达多重指令等待运作！
			事实上，当我们使用 at 时会进入一个 at shell 的环境来让用户下达工作指令，此时，建议你最好使用绝对路径来下达你的指令，比较不会有问题喔！由于指令的下达与 PATH 变量有关， 同时与当时的工作目录也有关连 (如果有牵涉到档案的话)，因此使用绝对路径来下达指令，会是比较一劳永逸的方法。 为什么呢？举例来说，你在 /tmp 下达『 at now 』然后输入『 mail root -s "test" < .bashrc 』， 问一下，那个 .bashrc 的档案会是在哪里？答案是『 /tmp/.bashrc 』！因为 at 在运作时，会跑到当时下达 at 指令的那个工作目录的缘故啊！ 有些朋友会希望『我要在某某时刻，在我的终端机显示出 Hello 的字样』，然后就在 at 里面下达这样的信息『 echo "Hello" 』。等到时间到了，却发现没有任何讯息在屏幕上显示，这是啥原因啊？这是因为 at 的执行与终端机环境无关，而所有 standard output/standard error output 都会传送到执行者的 mailbox 去啦！所以在终端机当然看不到任何信息。那怎办？没关系， 可以透过终端机的装置来处理！假如你在 tty1 登入，则可以使用『 echo "Hello" > /dev/tty1 』来取代。
			at 有另外一个很棒的优点，那就是『背景执行』的功能了！由于 at 工作排程的使用上，系统会将该项 at 工作独立出你的 bash 环境中， 直接交给系统的 atd 程序来接管，因此，当你下达了 at 的工作之后就可以立刻脱机了， 剩下的工作就完全交给 Linux 管理即可！所以啰，如果有长时间的网络工作时，嘿嘿！ 使用 at 可以让你免除网络断线后的困扰喔！ ^_^
			你可以利用 atq 来查询，利用 atrm 来删除错误的指令，利用 at 来直接下达单一工作排程
				[root@www ~]# atq 
				[root@www ~]# atrm [jobnumber]
			batch：系统有空时才进行背景任务
				其实 batch 是利用 at 来进行指令的下达啦！只是加入一些控制参数而已。这个 batch 神奇的地方在于：他会在 CPU 工作负载小于 0.8 的时候，才进行你所下达的工作任务啦！ 那什么是负载 0.8 呢？这个负载的意思是： CPU 在单一时间点所负责的工作数量
				范例一：同样是机房停电在 2009/3/17 23:00 关机，但若当时系统负载太高，则暂缓执行 
				[root@www ~]# batch 23:00 2009-3-17 
				at> sync 
				at> sync 
				at> shutdown -h now 
				at> <EOT> 
				job 6 at 2009-03-17 23:00
	循环执行的例行性工作排程
		循环执行的例行性工作排程则是由 cron (crond) 这个系统服务来控制的，Linux 也提供使用者控制例行性工作排程的指令 (crontab)
		使用者的设定
			为了安全性的问题， 与 at 同样的，我们可以限制使用 crontab 的使用者账号喔！使用的限制数据有：
				/etc/cron.allow： 将可以使用 crontab 的账号写入其中，若不在这个档案内的使用者则不可使用 crontab；
				/etc/cron.deny： 将不可以使用 crontab 的账号写入其中，若未记录到这个档案当中的使用者，就可以使用 crontab 。
			与 at 很像吧！同样的，以优先级来说， /etc/cron.allow 比 /etc/cron.deny 要优先， 而判断上面，这两个档案只选择一个来限制而已，因此，建议你只要保留一个即可， 免得影响自己在设定上面的判断！一般来说，系统默认是保留 /etc/cron.deny ， 你可以将不想让他执行 crontab 的那个使用者写入 /etc/cron.deny 当中，一个账号一行！ 当用户使用 crontab 这个指令来建立工作排程之后，该项工作就会被记录到 /var/spool/cron/ 里面去了，而且是以账号来作为判别的喔！举例来说， dmtsai 使用 crontab 后， 他的工作会被记录到 /var/spool/cron/dmtsai 里头去！但请注意，不要使用 vi 直接编辑该档案， 因为可能由于输入语法错误，会导致无法执行 cron 喔！另外， cron 执行的每一项工作都会被记录到 /var/log/cron 这个登录档中，所以啰，如果你的 Linux 不知道有否被植入木马时，也可以搜寻一下 /var/log/cron 这个登录档呢！
			[root@www ~]# crontab [-u username] [-l|-e|-r] 
			选项与参数： 
				-u ：只有 root 才能进行这个任务，亦即帮其他使用者建立/移除 crontab 工作排程； 
				-e ：编辑 crontab 的工作内容 
				-l ：查阅 crontab 的工作内容 
				-r ：移除所有的 crontab 的工作内容，若仅要移除一项，请用 -e 去编辑。
			预设情况下，任何使用者只要不被列入 /etc/cron.deny 当中，那么他就可以直接下达『 crontab -e 』去编辑自己的例行性命令了！整个过程就如同上面提到的，会进入 vi 的编辑画面， 然后以一个工作一行来编辑，编辑完毕之后输入『 :wq 』储存后离开 vi 就可以了！ 而每项工作 (每行) 的格式都是具有六个字段，这六个字段的意义为： 代表意义 分钟 小时 日期 月份 周 指令 数字范围 0-59 0-23 1-31 1-12 0-7 呀就指令啊
			比较有趣的是那个『周』喔！周的数字为 0 或 7 时，都代表『星期天』的意思！另外， 还有一些辅助的字符，大概有底下这些： 
				特殊字符 		代表意义 
				*(星号) 		代表任何时刻都接受的意思！举例来说，范例一内那个日、月、周都是 * ， 就代表着『不论何月、何日的礼拜几的 12:00 都执行后续指令』的意思！ 
				,(逗号) 		代表分隔时段的意思。举例来说，如果要下达的工作是 3:00 与 6:00 时，就会是： 0 3,6 * * * command 时间参数还是有五栏，不过第二栏是 3,6 ，代表 3 与 6 都适用！ 
				-(减号) 		代表一段时间范围内，举例来说， 8 点到 12 点之间的每小时的 20 分都进行一项工作： 20 8-12 * * * command 仔细看到第二栏变成 8-12 喔！代表 8,9,10,11,12 都适用的意思！ 
				/n(斜线) 		那个 n 代表数字，亦即是『每隔 n 单位间隔』的意思，例如每五分钟进行一次，则： */5 * * * * command 很简单吧！用 * 与 /5 来搭配，也可以写成 0-59/5 ，相同意思！
		系统的配置文件： /etc/crontab
			这个『 crontab -e 』是针对使用者的 cron 来设计的，如果是『系统的例行性任务』时， 该怎么办呢？是否还是需要以 crontab -e 来管理你的例行性工作排程呢？当然不需要，你只要编辑 /etc/crontab 这个档案就可以啦！有一点需要特别注意喔！那就是 crontab -e 这个 crontab 其实是 /usr/bin/crontab 这个执行档，但是 /etc/crontab 可是一个『纯文本档』喔！你可以 root 癿身份编辑一下这个档案哩！ 基本上， cron 这个服务的最低侦测限制是『分钟』，所以『 cron 会每分钟去读取一次 /etc/crontab 与 /var/spool/cron 里面的数据内容 』，因此，只要你编辑完 /etc/crontab 这个档案，并且将他储存之后，那么 cron 的设定就自动的会来执行了！
			[root@www ~]# cat /etc/crontab 
			SHELL=/bin/bash <==使用哪种 shell 接口 
			PATH=/sbin:/bin:/usr/sbin:/usr/bin <==执行文件搜寻路径 
			MAILTO=root <==若有额外STDOUT，以 email将数据送给谁 
			HOME=/ <==默认此 shell 的家目录所在
			# run-parts 
			01 * * * * root run-parts /etc/cron.hourly <==每小时 
			02 4 * * * root run-parts /etc/cron.daily <==每天 
			22 4 * * 0 root run-parts /etc/cron.weekly <==每周日 
			42 4 1 * * root run-parts /etc/cron.monthly <==每个月 1 号 
			分 时 日 月 周 执行者身份 指令串
			看到这个档案癿内容你大概就了解了吧！呵呵，没错！这个档案与将刚刚我们下达 crontab -e 的内容几乎完全一模一样！只是有几个地方不太相同：
				MAILTO=root： 这个项目是说，当 /etc/crontab 这个档案中的例行性工作的指令发生错误时，或者是该工作的执行结果有 STDOUT/STDERR 时，会将错误讯息或者是屏幕显示的讯息传给谁？默认当然是由系统直接寄发一封 mail 给 root 啦！不过， 由于 root 并无法在客户端中以 POP3 之类的软件收信，因此，鸟哥通常都将这个 e-mail 改成自己的账号，好让我随时了解系统的状况！例如： MAILTO=dmtsai@my.host.name
				PATH=....： 还记得我们在第十一章的 BASH 当中一直提到的执行文件路径问题吧！ 没错啦！这里就是输入执行文件的搜寻路径！使用默认的路径设定就已经很足够了！
				01 * * * * root run-parts /etc/cron.hourly： 这个 /etc/crontab 里面默认定义出四项工作任务，分别是每小时、每天、每周及每个月分别别行一次的工作！ 但是在五个字段后面接的并不是指令，而是一个新的字段，那就是『执行后面那串指令的身份』为何！这与使用者的 crontab -e 不相同。由于使用者自己的 crontab 并不需要指定身份，但 /etc/crontab 里面当然要指定身份啦！以上表的内容来说，系统默认的例行性工作是以 root 的身份来进行的。 那么后面那串指令是什么呢？你可以使用『 which run-parts 』搜寻看看，其实那是一个 bash script 啦！如果你直接进入 /usr/bin/run-parts 去看看， 会发现这支指令会将后面接的『目录』内的所有档案捉出来执行！这也就是说『 如果你想让系统每小时主动帮你执行某个指令，将该指令写成 script，并将该档案放置到 /etc/cron.hourly/ 目录下即可』的意思！ 现在你知道系统是如何进行他默认的一堆例行性工作排程了吗？如果你下达『 ll /etc/cron.daily 』就可以看到一堆档案， 那些档案就是系统提供的 script ，而这堆 scripts 将会在每天的凌晨 4:02 开始运作！这也是为啥如果你是夜猫族， 就会发现奇怪的是，Linux 系统为何早上 4:02 开始会很忙碌的发出一些硬盘跑动的声音！因为他必须要进行 makewhatis, updatedb, rpm rebuild 等等的任务嘛！由于 CentOS 提供的 run-parts 这个 script 的辅助，因此 /etc/crontab 这个档案里面支持两种下达指令的方式， 一种是直接下达指令，一种则是以目录来规划，例如：
					指令型态 01 * * * * dmtsai mail -s "testing" kiki < /home/dmtsai/test.txt 以 dmtsai 这个使用者的身份，在每小时执行一次 mail 指令。
					目录规划 */5 * * * * root run-parts /root/runcron 建立一个 /root/runcron 的目录，将要每隔五分钟执行的『可执行文件』都写到该目录下， 就可以让系统每五分钟执行一次该目录下的所有可执行文件。
		一些注意事项
			资源分配不均的问题
			取消不要的输出项目
				可以直接以『命令重导向』将输出的结果输出到 /dev/null 这个垃圾桶当中就好了！
			安全的检验
				可以藉由检查 /var/log/cron 的内容来视察是否有『非您设定的 cron 被执行了？』
			周与日月不可同时并存
	可唤醒停机期间的工作任务
		什么是 anacron
			anacron 并不是用来取代 crontab 的，anacron 存在的目的就在于我们上头提到的，在处理非 24 小时一直启动的 Linux 系统的 crontab 的执行！所以 anacron 并不能指定何时执行某项任务， 而是以天为单位或者是在开机后立刻进行 anacron 的动作，他会去侦测停机期间应该进行但是并没有进行的 crontab 任务，并将该任务执行一遍后，anacron 就会自动停止了。
			那么 anacron 又是怎么知道我们的系统啥时关机的呢？这就得要使用 anacron 读取的时间记录文件 (timestamps) 了！ anacron 会去分析现在的时间与时间记录文件所记载的上次执行 anacron 的时间，两者比较后若发现有差异， 那就是在某些时刻没有进行 crontab 啰！此时 anacron 就会开始执行未进行的 crontab 仸务了！ 所以 anacron 其实也是透过 crontab 来运作的！因此 anacron 运作癿时间通常有两个，一个是系统开机期间运作，一个是写入 crontab 的排程中。 这样才能够在特定时间分析系统未进行的 crontab 工作嘛！
		anacron 与 /etc/anacrontab
			anacron 其实是一支程序并非一个服务！这支程序在 CentOS 当中已经进入 crontab 的排程喔！ 不相信吗？你可以这样追踪看看：
				[root@www ~]# ll /etc/cron*/*ana* 
				-rwxr-xr-x 1 root root 379 Mar 28 2007 /etc/cron.daily/0anacron 
				-rwxr-xr-x 1 root root 381 Mar 28 2007 /etc/cron.monthly/0anacron 
				-rwxr-xr-x 1 root root 380 Mar 28 2007 /etc/cron.weekly/0anacron # 刚好是每天、每周、每月有排程的工作目录！查阅一下每天的任务 
				[root@www ~]# cat /etc/cron.daily/0anacron 
				if [ ! -e /var/run/anacron.pid ]; then 
					anacron -u cron.daily 
				fi # 所以其实也仅是执行 anacron -u 的指令！因此我们得来谈谈这支程序！
			基本上， anacron 的语法如下： 
			[root@www ~]# anacron [-sfn] [job].. 
			[root@www ~]# anacron -u [job].. 
			选项与参数： 
				-s ：开始一连续的执行各项工作 (job)，会依据时间记录文件的数据判断是否进行； 
				-f ：强制进行，而不去判断时间记录文件的时间戳； 
				-n ：立刻进行未进行的任务，而不延迟 (delay) 等待时间； 
				-u ：仅更新时间记录文件的时间戳，不进行任何工作。 
				job ：由 /etc/anacrontab 定义的各项工作名称。
			所以我们发现其实 /etc/cron.daily/0anacron 仅进行时间戳的更新，而没有进行任何 anacron 的动作！ 在我们的 CentOS 中，anacron 的进行其实是在开机完成后才进行的一项工作任务，你也可以将 anacron 排入 crontab 的排程中。但是为了担心 anacron 误判时间参数，因此 /etc/cron.daily/ 里面的 anacron 才会在档名之前加个 0 (0anacron)，让 anacron 最先进行！就是为了让时间戳先更新！以避免 anacron 误判 crontab 尚未进行任何工作的意思。 接下来我们看一下 /etc/anacrontab 的内容好了： 
				[root@www ~]# cat /etc/anacrontab 
				SHELL=/bin/sh 
				PATH=/sbin:/bin:/usr/sbin:/usr/bin 
				MAILTO=root 
				1 65 cron.daily run-parts /etc/cron.daily 
				7 70 cron.weekly run-parts /etc/cron.weekly 
				30 75 cron.monthly run-parts /etc/cron.monthly 
				天数 延迟时间 工作名称定义 实际要进行的指令串 
				# 天数单位为天；延迟时间单位为分钟；工作名称定义可自定义； 
				# 指令串则通常与 crontab 的设定相同！ 
				[root@www ~]# more /var/spool/anacron/* 
				:::::::::::::: 
				/var/spool/anacron/cron.daily 
				:::::::::::::: 20090315 :::::::::::::: 
				/var/spool/anacron/cron.monthly 
				::::::::::::::20090301 :::::::::::::: 
				/var/spool/anacron/cron.weekly 
				:::::::::::::: 20090315 # 上面则是三个工作名称的时间记录文件以及记录的时间戳
				由于 /etc/cron.daily 内的任务比较多，因此我们使用每天进行的任务来解释一下 anacron 的运作情况好了。 anacron 若下达『 anacron -s cron.daily 』时，他会这样运作的：
					1. 由 /etc/anacrontab 分析到 cron.daily 这项工作名称的天数为 1 天；
					2. 由 /var/spool/anacron/cron.daily 取出最近一次执行 anacron 的时间戳；
					3. 由上个步骤与目前的时间比较，若差异天数为 1 天以上 (吨 1 天)，就准备进行指令；
					4. 若准备进行指令，根据 /etc/anacrontab 的设定，将延迟 65 分钟
					5. 延迟时间过后，开始执行后续指令，亦即『 run-parts /etc/cron.daily 』这串指令；
					6. 执行完毕后， anacron 程序结束。
				所以说，时间戳是非常重要的！anacron 是透过该记录与目前的时间差异，了解到是否应该要进行某项任务的工作！ 举例来说，如果我的主机在 2009/03/15(星期天) 18:00 关机，然后在 2009/03/16(星期一) 8:00 开机，由于我的 crontab 是在早上 04:00 左右进行各项任务，由于该时刻系统是关机的，因此时间戳依旧为 20090315 (旧的时间)， 但是目前时间已经是 20090316 (新的时间)，因此 run-parts /etc/cron.daily 就会在开机过 65 分钟后开始运作了。 所以啰， anacron 并不需要额外的设定，使用默认值即可！只是我们的 CentOS 只有在开机时才会执行 anacron 就是了。
				如果要确定 anacron 是否开机时会主动的执行，你可以下达下列指令： 
					[root@www ~]# chkconfig --list anacron 
					anacron 0:off 1:off 2:on 3:on 4:on 5:on 6:off # 详细的 chkconfig 说明我们会在后续章节提到，注意看 3, 5 # 的项目，都是 on ！那就是有启动啦！开机时才会执行的意思！
		
		
		
第十七章、程序管理与 SELinux 初探
	什么是程序 (process)
		在 Linux 系统当中：『解决任何一个事件时，系统都会将他定义成为一个程序，并且给予这个程序一个 ID ，称为 PID，同时依据启发这个程序的用户与相关属性关系，给予这个 PID 一组有关的权限设定。』
		程序与 程序 (process & program)
			子程序与父程序
				因为每个程序都有一个 PID ，那某个程序的父程序该如何判断？就透过 Parent PID (PPID) 来判断即可。
			fork and exec：过程调用的流程
				其实子程序与父程序之间的关系还挺复杂的，最大的复杂点在于程序互相之间的呼叫。在 Linux 的过程调用通常称为 fork-and-exec 的流程 (注1)！程序都会藉由父程序以复制 (fork) 的方式产生一个一模一样的子程序， 然后被复制出来的子程序再以 exec 的方式来执行实际要进行的程序，最终就成为一个子程序的存在。
			系统或网络服务：常驻在内存的程序
				常驻在内存当中的程序通常都是负责一些系统所提供的功能以服务用户各项任务，因此这些常驻程序就会被我们称为：服务 (daemon)。
	工作管理 (job control)
		什么是工作管理？
			要进行 bash 的 job control 必须要注意到的限制是：
				这些工作所触发的程序必项来自于你 shell 的 子程序(只管理自己的 bash)；
				前景：你可以控制与下达指令的这个环境称为前景的工作 (foreground)；
				背景：可以自行运作的工作，你无法使用 [ctrl]+c 终止他，可使用 bg/fg 呼叫该工作；
				背景中『执行』的程序不能等待 terminal/shell 的输入(input)
		job control 的管理
			bash 只能够管理自己的工作而不能管理其他 bash 的工作，所以即使你是 root 也不能够将别人的 bash 底下的 job 给他拿过来执行。此外，又分前景与背景，然后在背景里面的工作状态又可以分为『暂停 (stop)』与『运作中 (running)』
			直接将指令丢到背景中『执行』的 &
				在背景当中执行的指令，如果有 stdout 及 stderr 时，他的数据依旧是输出到屏幕上面的， 所以，我们会无法看到提示字符，当然也就无法完好的掌控前景工作。同时由于是背景工作的 tar ， 此时你怎么按下 [ctrl]+c 也无法停止屏幕被搞的花花绿绿的！所以啰，最佳的状态就是利用数据流重导向， 将输出数据传送至某个档案中。
					[root@www ~]# tar -zpcvf /tmp/etc.tar.gz /etc > /tmp/log.txt 2>&1 &
			将『目前』的工作丢到背景中『暂停』：[ctrl]-z
				在预设的情况下，使用 [ctrl]-z 丢到背景当中的工作都是『暂停』的状态喔！
			观察目前的背景工作状忞： jobs
				[root@www ~]# jobs [-lrs] 
				选项与参数： 
					-l ：除了列出 job number 与指令串之外，同时列出 PID 的号码； 
					-r ：仅列出正在背景 run 的工作； 
					-s ：仅列出正在背景当中暂停 (stop) 的工作。
				在输出的信息当中，例如上表，仔细看到那个 + - 号喔！那个 + 代表预设的取用工作。 所以说：『目前我有两个工作在背景当中，两个工作都是暂停的， 而如果我仅输入 fg 时，那么那个 [2] 会被拿到前景当中来处理』！ 其实 + 代表最近被放到背景的工作号码， - 代表最近最后第二个被放置到背景中的工作号码。 而超过最后第三个以后的工作，就不会有 +/- 符号存在了！
			将背景工作拿到前景来处理：fg
				[root@www ~]# fg %jobnumber 
				选项与参数： 
					%jobnumber ：jobnumber 为工作号码(数字)。注意，那个 % 是可有可无的！
			让工作在背景下的状态变成运作中： bg
				先用ctrl + z暂停，再用bg命令
			管理背景当中的工作： kill
				[root@www ~]# kill -signal %jobnumber 
				[root@www ~]# kill -l 
				选项与参数： 
					-l ：这个是 L 的小写，列出目前 kill 能够使用的讯号 (signal) 有哪些？ signal ：代表给予后面接的那个工作什么样的指示啰！用 man 7 signal 可知： 
						-1 ：重新读取一次参数的配置文件 (类似 reload)； 
						-2 ：代表与由键盘输入 [ctrl]-c 同样的动作； 
						-9 ：立刻强制删除一个工作； 
						-15：以正常的程序方式终止一项工作。与 -9 是不一样的。
				[root@www ~]# kill -SIGTERM %1 
				# -SIGTERM 与 -15 是一样的！您可以使用 kill -l 来查阅！
				另外， kill 后面接的数字默认会是 PID ，如果想要管理 bash 的工作控制，就得要加上 %数字 了， 这点也得特别留意才行喔！
		脱机管理问题
			要注意的是，我们在工作管理当中提到的『背景』指的是在终端机模式下可以避克 [crtl]-c 中断的一个情境， 并不是放到系统的背景去喔！所以，工作管理的背景依旧与终端机有关啦！ 在这样的情况下，如果你是以进程联机方式连接到你的 Linux 主机，并且将工作以 & 的方式放到背景去， 请问，在工作尚未结束的情况下你脱机了，该工作还会继续进行吗？答案是『否』！不会继续进行，而是会被中断掉。
			那怎么办？如果我的工作需要进行一大段时间，我又不能放置在背景底下，那该如何处理呢？ 首先，你可以参考前一章的 at 来处理即可！因为 at 是将工作放置到系统背景， 而与终端机无关。如果不想要使用 at 的话，那你也可以尝试使用 nohup 这个指令来处理喔！
			这个 nohup 可以让你在脱机或注销系统后，还能够让工作继续进行。他的语法有点像这样： 
				[root@www ~]# nohup [指令与参数] <==在终端机前景中工作 
				[root@www ~]# nohup [指令与参数] & <==在终端机背景中工作
			有够好简单的指令吧！上述指令需要注意的是， nohup 并不支持 bash 内建的指令，因此你的指令必项要是外部指令才行。
	程序管理
		程序的观察
			ps ：将某个时间点的程序运作情况撷取下来
				[root@www ~]# ps aux <==观察系统所有的程序数据 
				[root@www ~]# ps -lA <==也是能够观察所有系统的数据 
				[root@www ~]# ps axjf <==连同部分程序树状态
				选项与参数：
					-A ：所有的 process 均显示出来，与 -e 具有同样的作用； 
					-a ：不与 terminal 有关的所有 process ； 
					-u ：有效使用者 (effective user) 相关的 process ； 
					x ：通常与 a 这个参数一起使用，可列出较完整信息。 
					输出格式规划： 
						l ：较长、较详细的将该 PID 的信息列出； 
						j ：工作的格式 (jobs format) 
						-f ：做一个更为完整的输出。
				仅观察自己的 bash 相关程序： 
					ps -l 
					范例一：将目前属亍您自己这次登入的 PID 与相关信息列示出来(只与自己的 bash 有关) 
					[root@www ~]# ps -l 
					F S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD 
					4 S 0 13639 13637 0 75 0 - 1287 wait pts/1 00:00:00 bash 
					4 R 0 13700 13639 0 77 0 - 1101 - pts/1 00:00:00 ps
					系统整体的程序运作是非常多的，但如果使用 ps -l 则仅列出与你的操作环境 (bash) 有关的程序而已， 亦即最上层的父程序会是你自己的 bash 而没有延伸到 init 这支程序去！那么 ps -l 秀出来的资料有哪些呢？ 我们就来观察看看：
						F：代表这个程序旗标 (process flags)，说明这个程序的总结权限，常见号码有：
							若为 4 表示此程序的权限为 root ；
							若为 1 则表示此子程序仅进行复制(fork)而没有实际执行(exec)。
						S：代表这个程序的状态 (STAT)，主要的状态有：
							R (Running)：该程序正在运作中；
							S (Sleep)：此程序目前正在睡眠状忞(idle)，但可以被唤醒(signal)。
							D ：不可被唤醒的睡眠状态，通常这支程序可能在等待 I/O 的情况(ex>打印)
							T ：停止状态(stop)，可能是在工作控制(背景暂停)或除错 (traced) 状态；
							Z (Zombie)：僵尸状态，程序已经终止但即无法被移除至内存外。
						UID/PID/PPID：代表『此程序被该 UID 所拥有/程序的 PID 号码/此程序的父程序 PID 号码』
						C：代表 CPU 使用率，单位为百分比；
						PRI/NI：Priority/Nice 的缩写，代表此程序被 CPU 所执行的优先级，数值越小代表该程序越快被 CPU 执行。
						ADDR/SZ/WCHAN：都与内存有关，
							ADDR 是 kernel function，指出该程序在内存的哪个部分，如果是个 running 的程序，一般就会显示『 - 』 / SZ 代表此程序用掉多少内存 / WCHAN 表示目前程序是否运作中，同样的， 若为 - 表示正在运作中。
						TTY：登入者的终端机位置，若为进程登录则使用动态终端接口 (pts/n)；
						TIME：使用掉的 CPU 时间，注意，是此程序实际花费 CPU 运作的时间，而不是系统时间；
						CMD：就是 command 的缩写，造成此程序的触发程序之指令为何。
				观察系统所有程序： ps aux
					ps -l 与 ps aux 显示的项目并不相同！在 ps aux 显示的项目中，各字段的意义为：
						USER：该 process 属于那个使用者账号的？
						PID ：该 process 的程序标识符。
						%CPU：该 process 使用掉的 CPU 资源百分比；
						%MEM：该 process 所占用癿物理内存百分比；
						VSZ ：该 process 使用掉的虚拟内存量 (Kbytes)
						RSS ：该 process 占用的固定的内存量 (Kbytes)
						TTY ：该 process 是在那个终端机上面运作，若与终端机无关则显示 ?，另外， tty1-tty6 是本机上面的登入者程序，若为 pts/0 等等的，则表示为由网络连接进主机的程序。
						STAT：该程序目前的状忞，状态显示与 ps -l 的 S 旗标相同 (R/S/T/Z)
						START：该 process 被触发启动的时间；
						TIME ：该 process 实际使用 CPU 运作的时间。
						COMMAND：该程序的实际指令为何？
					除此之外，我们必项要知道的是『僵尸 (zombie) 』程序是什么？ 通常，造成僵尸程序的成因是因为该程序应该已经执行完毕，或者是因故应该要终止了， 但是该程序的父程序即无法完整的将该程序结束掉，而造成那个程序一直存在内存当中。 如果你发现在某个程序的 CMD 后面还接上 <defunct> 时，就代表该程序是僵尸程序啦
					当系统不稳定的时候就容易造成所谓的僵尸程序，可能是因为程序写的不好啦，或者是使用者的操作习惯不良等等所造成。 如果你发现系统中很多僵尸程序时，记得啊！要找出该程序的父程序，然后好好的做个追踪，好好的进行主机的环境优化啊！ 看看有什么地方需要改善的，不要只是直接将他 kill 掉而已呢！
					事实上，通常僵尸程序都已经无法控管，而直接是交给 init 这支程序来负责了，偏偏 init 是系统第一支执行的程序， 他是所有程序的父程序！我们无法杀掉该程序的 (杀掉他，系统就死掉了！)，所以啰，如果产生僵尸程序， 而系统过一阵子还没有办法透过核心非经常性的特殊处理来将该程序删除时，那你只好透过 reboot 的方式来将该程序抹去了！
				top：动态观察程序的变化
					[root@www ~]# top [-d 数字] | top [-bnp] 
					选项与参数： 
						-d ：后面可以接秒数，就是整个程序画面更新的秒数。预设是 5 秒； 
						-b ：以批次的 方式执行 top ，还有更多的参数可以使用喔！ 通常会搭配数据流重导向来将批次的结果输出成为档案。
						-n ：与 -b 搭配，意义是，需要进行几次 top 的输出结果。 
						-p ：指定某些个 PID 来进行观察监测而已。 在 top 执行过程当中可以使用的按键指令： 
						? ：显示在 top 当中可以输入的按键指令； 
						P ：以 CPU 的使用资源排序显示； 
						M ：以 Memory 的使用资源排序显示； 
						N ：以 PID 来排序喔！ 
						T ：由该 Process 使用的 CPU 时间累积 (TIME+) 排序。 
						k ：给予某个 PID 一个讯号 (signal) 
						r ：给予某个 PID 重新制订一个 nice 值。 
						q ：离开 top 软件的按键。
				top 主要分为两个画面，上面的画面为整个系统的资源使用状态，基本上总共有六行，显示的内容依序是：
					第一行(top...)：这一行显示的信息分别为：
						目前的时间，亦即是 17:03:09 那个顷目；
						开机到目前为止所经过的时间，亦即是 up 7days, 16:16 那个项目；
						已经登入系统的用户人数，亦即是 1 user项目；
						系统在 1, 5, 15 分钟的平均工作负载。我们在第十六章课到的 batch 工作方式为负载小于 0.8 就是这个负载啰！代表的是 1, 5, 15 分钟，系统平均要负责运作几个程序(工作)的意思。 越小代表系统越闲置，若高于 1 得要注意你的系统程序是否太过繁复了！
					第二行(Tasks...)：显示的是目前程序的总量与个别程序在什么状忞(running, sleeping, stopped, zombie)。 比较需要注意的是最后的 zombie 那个数值，如果不是 0 ！好好看看到底是那个 process 变成僵尸了吧？
					第三行(Cpus...)：显示的是 CPU 的整体负载，每个项目可使用 ? 查阅。需要特别注意的是 %wa ，那个项目代表的是 I/O wait， 通常你的系统会变慢都是 I/O 产生的问题比较大！因此这里得要注意这个项目耗用 CPU 的资源喔！ 另外，如果是多核心的设备，可以按下数字键『1』来切换成不同 CPU 的负载率。
					第四行与第五行：表示目前的物理内存与虚拟内存 (Mem/Swap) 的使用情况。 再次重申，要注意的是 swap 的使用量要尽量的少！如果 swap 被用的很大量，表示系统的物理内存实在不足！
					第六行：这个是当在 top 程序当中输入指令时，显示状态的地方。
					至于 top 下半部分的画面，则是每个 process 使用的资源情况。比较需要注意的是：
						PID ：每个 process 的 ID 啦！
						USER：该 process 所属的使用者；
						PR ：Priority 的简写，程序的优先执行顺序，越小越早被执行；
						NI ：Nice 的简写，与 Priority 有关，也是越小越早被执行；
						%CPU：CPU 的使用率；
						%MEM：内存的使用率；
						TIME+：CPU 使用时间的累加；
			pstree
				[root@www ~]# pstree [-A|U] [-up] 
				选项与参数： 
					-A ：各程序树之间的连接以 ASCII 字符来连接； 
					-U ：各程序树之间的连接以万国码的字符来连接。在某些终端接口下可能会有错误； 
					-p ：并同时列出每个 process 的 PID； 
					-u ：并同时列出每个 process 的所属账号名称。
				由 pstree 的输出我们也可以很清楚的知道，所有的程序都是依附在 init 这支程序底下的！ 仔细看一下，这支程序的 PID 是一号喔！因为他是由 Linux 核心所主动呼叫的第一支程序！所以 PID 就是一号了。 这也是我们刚刚提到僵尸程序时有提到，为啥发生僵尸程序需要重新启动？ 因为 init 要重新启动，而重新启动 init 就是 reboot 啰！
		程序的管理
			要给予某个已经存在背景中的工作某些动作时，是直接给予一个讯号给该工作号码即可。那么到底有多少 signal 呢？ 你可以使用 kill -l (小写的 L ) 或者是 man 7 signal 都可以查询到！主要的讯号代号与名称对应及内容是：
			代号 	名称 		内容 
			1 		SIGHUP 		启动被终止的程序，可让该 PID 重新获取自己的配置文件，类似重新启动 
			2 		SIGINT 		相当于用键盘输入 [ctrl]-c 来中断一个程序的进行
			9 		SIGKILL 	代表强制中断一个程序的进行，如果该程序进行到一半， 那么尚未完成的部分可能会有『半产品』产生，类似 vim会有 .filename.swp 保留下来。 
			15 		SIGTERM 	以正常的结束程序来终止该程序。由于是正常的终止， 所以后续的动作会将他完成。不过，如果该程序已经发生问题，就是无法使用正常的方法终止时， 输入这个 signal 也是没有用的。 
			17 		SIGSTOP 	相当于用键盘输入 [ctrl]-z 来暂停一个程序的进行	
			kill -signal PID
				kill 后面直接加数字与加上 %number 的情况是不同的，直接加数字是PID，%number是job number。
			killall -signal 指令名称
				有没有可以利用『下达指令的名称』来给予讯号的？
					[root@www ~]# killall [-iIe] [command name] 
					选项与参数： 
						-i ：interactive 的意思，交互式的，若需要删除时，会出现提示字符给用户； 
						-e ：exact 的意思，表示『后面接的 command name 要一致』，但整个完整的指令 不能超过 15 个字符。 
						-I ：指令名称(可能含参数)忽略大小写。
		关于程序的执行顺序		
			Priority 与 Nice 值
				我们 Linux 给予程序一个所谓的『优先执行序 (priority, PRI)』， 这个 PRI 值越低代表越优先的意思。
				由于 PRI 是核心动态调整的，我们用户也无权去干涉 PRI ！那如果你想要调整程序的优先执行序时，就得要透过 Nice 值了！Nice 值就是上表的 NI 啦！一般来说， PRI 与 NI 的相关性如下： PRI(new) = PRI(old) + nice 不过你要特别留意到，如果原本的 PRI 是 50 ，并不是我们给予一个 nice = 5 ，就会让 PRI 变成 55 喔！ 因为 PRI 是系统『动态』决定的，所以，虽然 nice 值是可以影响 PRI ，不过， 最终的 PRI 是要经过系统分析后才会决定的。另外， nice 值是有正负的喔，而既然 PRI 越小越早被执行， 所以，当 nice 值为负值时，那举该程序就会降低 PRI 值，亦即会变的较优先被处理。此外，你必项要留意到：
					nice 值可调整的范围为 -20 ~ 19 ；
					root 可随意调整自己或他人程序的 Nice 值，且范围为 -20 ~ 19 ；
					一般用户仅可调整自己程序的 Nice 值，且范围仅为 0 ~ 19 (避克一般用户抢占系统资源)；
					一般使用者仅可将 nice 值越调越高，例如本来 nice 为 5 ，则未来仅能诽整到大于 5；
				这也就是说，要调整某个程序的优先执行序，就是『调整该程序的 nice 值』啦！
				nice ：新执行的指令即给予新的 nice 值
					[root@www ~]# nice [-n 数字] command 
					选项与参数： 
						-n ：后面接一个数值，数值的范围 -20 ~ 19。
				renice ：已存在程序的 nice 重新调整
					[root@www ~]# renice [number] PID 
					选项与参数： 
						PID ：某个程序的 ID 啊！
				由上面这个范例当中我们也看的出来，虽然修改的是 bash 那个程序，但是该程序所触发的 ps 指令当中的 nice 也会继承而为 10 喔！了解了吧！整个 nice 值是可以在父程序 --> 子程序之间传递的呢！ 另外，除了 renice 之外，其实那个 top 同样的也是可以调整 nice 值的！
		系统资源的观察	
			free ：观察内存使用情况 
				[root@www ~]# free [-b|-k|-m|-g] [-t] 
				选项与参数： 
					-b ：直接输入 free 时，显示的单位是 Kbytes，我们可以使用 b(bytes), m(Mbytes) k(Kbytes), 及 g(Gbytes) 来显示单位喔！ 
					-t ：在输出的最终结果，显示物理内存与 swap 的总量。
				Mem 那一行显示的是物理内存的量， Swap 则是虚拟内存的量。 total 是总量， used 是已被使用的量， free 则是剩余可用的量。 后面的 shared/buffers/cached 则是在已被使用的量当中，用来作为缓冲及快取的量。
				很多朋友都会问到这个问题『我的系统明明很轻松，为何内存会被用光光？』现在瞭了吧？ 被用光是正常的！而需要注意的反而是 swap 的量。一般来说， swap 最好不要被使用，尤其 swap 最好不要被使用超过 20% 以上， 如果您发现 swap 的用量超过 20% ，那么，最好还是买物理内存来插吧！ 因为， Swap 的效能跟物理内存实在差很多，而系统会使用到 swap ， 绝对是因为物理内存不足了才会这样做的
			uname：查阅系统与核心相关信息
				[root@www ~]# uname [-asrmpi] 
				选项与参数： 
					-a ：所有系统相关的信息，包括底下的数据都会被列出来； 
					-s ：系统核心名称 
					-r ：核心的版本 
					-m ：本系统的硬件名称，例如 i686 或 x86_64 等； 
					-p ：CPU 的类型，与 -m 类似，只是显示的是 CPU 的类型！ 
					-i ：硬件的平台 (ix86)
			uptime：观察系统启动时间与工作负载
				这个指令很单纯呢！就是显示出目前系统已经开机多久的时间，以及 1, 5, 15 分钟的平均负载就是了。还记得 top 吧？没错啦！这个 uptime 可以显示出 top 画面的最上面一行！
			netstat ：追踪网络或插槽文件
				这个指令比较常被用在网络的监控方面，
				基本上， netstat 的输出分为两大部分，分别是网络与系统自己的程序相关性部分： 
					[root@www ~]# netstat -[atunlp] 
					选项与参数： 
						-a ：将目前系统上所有的联机、监听、Socket 数据都列出来 
						-t ：列出 tcp 网络封包的数据 
						-u ：列出 udp 网络封包的数据 
						-n ：不以程序的朋务名称，以埠号 (port number) 来显示； 
						-l ：列出目前正在网络监听 (listen) 的服务； 
						-p ：列出该网络服务的程序 PID
				因特网联机情况的部分：
					Proto ：网络的封包协议，主要分为 TCP 与 UDP 封包，相关资料请参考服务器篇；
					Recv-Q：非由用户程序链接到此 socket 的复制的总 bytes 数；
					Send-Q：非由进程主机传送过来的 acknowledged 总 bytes 数；
					Local Address ：本地端的 IP:port 情况
					Foreign Address：进程主机的 IP:port 情况
					State ：联机状态，主要有建立(ESTABLISED)及监听(LISTEN)；
				socket file 的输出字段有：
					Proto ：一般就是 unix 啦；
					RefCnt：连接到此 socket 的程序数量；
					Flags ：联机的旗标；
					Type ：socket 存取的类型。主要有确认联机的 STREAM 与不需确认的 DGRAM 两种；
					State ：若为 CONNECTED 表示多个程序之间已经联机建立。
					Path ：连接到此 socket 的相关程序的路径！或者是相关数据输出的路径。
			dmesg ：分析核心产生的讯息
				系统在开机的时候，核心会去侦测系统的硬件，你的某些硬件到底有没有被捉到，那就与这个时候的侦测有关。 但是这些侦测的过程要不是没有显示在屏幕上，就是很飞快的在屏幕上一闪而逝！能不能把核心侦测的讯息捉出来瞧瞧？ 可以的，那就使用 dmesg 吧！ 所有核心侦测的讯息，不管是开机时候还是系统运作过程中，反正只要是核心产生的讯息，都会被记录到内存中的某个保护区段。 dmesg 这个指令就能够将该区段的讯息诺出来的！因为讯息实在太多了，所以执行时可以加入这个管线指令『 | more 』来使画面暂停！
			vmstat ：侦测系统资源变化
				vmstat 可以侦测『 CPU / 内存 / 磁盘输入输出状忞 』等等
				[root@www ~]# vmstat [-a] [延迟 [总计侦测次数]] <==CPU/内存等信息 
				[root@www ~]# vmstat [-fs] <==内存相关 
				[root@www ~]# vmstat [-S 单位] <==设定显示数据的单位 
				[root@www ~]# vmstat [-d] <==与磁盘有关 
				[root@www ~]# vmstat [-p 分割槽] <==与磁盘有关 
				选项与参数： 
					-a ：使用 inactive/active(活跃与否) 取代 buffer/cache 的内存输出信息； 
					-f ：将开机到目前为止，系统复制 (fork) 的程序数； 
					-s ：将一些事件 (开机至目前为止) 导致的内存变化情况列表说明； 
					-S ：后面可以接单位，让显示的数据有单位。例如 K/M 取代 bytes 的容量； 
					-d ：列出磁盘的读写总量统计表 
					-p ：后面列出分割槽，可显示该分割槽的读写总量统计表
				各项字段的意义为何？ 基本说明如下：
					内存字段 (procs) 的项目分别为： r ：等待运作中的程序数量；b：不可被唤醒的程序数量。这两个项目越多，代表系统越忙碌 (因为系统太忙，所以很多程序就无法被执行或一直在等待而无法被唤醒)。
					内存字段 (memory) 项目分别为： swpd：虚拟内存被使用的容量； free：未被使用的内存容量； buff：用于缓冲存储器； cache：用于高速缓存。 这部份则与 free 是相同的。
					内存置换空间 (swap) 的项目分别为： si：由磁盘中将程序取出的量； so：由于内存不足而将没用到的程序写入到磁盘的 swap 的容量。 如果 si/so 的数值太大，表示内存内的数据常常得在磁盘与主存储器之间传来传去，系统效能会很差！
					磁盘读写 (io) 的项目分别为： bi：由磁盘写入的区块数量； bo：写入到磁盘去的区块数量。如果这部份的值越高，代表系统的 I/O 非常忙碌！
					系统 (system) 的顷目分别为： in：每秒被中断的程序次数； cs：每秒钟进行的事件切换次数；这两个数值越大，代表系统与接口设备的沟通非常频繁！ 这些接口设备当然包括磁盘、网络卡、时间钟等。
					CPU 的项目分别为： us：非核心层的 CPU 使用状态； sy：核心层所使用的 CPU 状态； id：闲置的状态； wa：等待 I/O 所耗费的 CPU 状忞； st：被虚拟机 (virtual machine) 所盗用的 CPU 使用状忞 (2.6.11 以后才支持)。
	特殊档案与程序
		具有 SUID/SGID 权限的指令执行状态
			SUID 的程序是如何被一般用户执行，与具有什么特色呢？
				SUID 权限仅对二进制程序(binary program)有效；
				执行者对于该程序需要具有 x 的可执行权限；
				本权限仅在执行该程序的过程中有效 (run-time)；
				执行者将具有该程序拥有者 (owner) 的权限。
		您该如何查询整个系统的 SUID/SGID 的档案呢？ 应该是还不会忘记吧？使用 find 即可啊！ find / -perm +6000
		/proc/* 代表的意义
			其实，我们之前提到的所谓的程序都是在内存当中嘛！而内存当中的数据又都是写入到 /proc/* 这个目录下的，所以啰，我们当然可以直接观察 /proc 这个目录当中的档案啊！
			/proc 目录底下的档案啦！相关的档案与对应的内容是这样的： (注3) 
				檔名 				档案内容 
				/proc/cmdline 		加载 kernel 时所下达的相关参数！查阅此档案，可了解系统是如何启动的！ 
				/proc/cpuinfo 		本机的 CPU 的相关信息，包含频率、类型与运算功能等 
				/proc/devices 		这个档案记录了系统各个主要装置的主要装置代号，与 mknod 有关呢！ 
				/proc/filesystems 	目前系统已经加载的文件系统啰！ 
				/proc/interrupts 	目前系统上面的 IRQ 分配状态。 
				/proc/ioports 		目前系统上面各个装置所配置的 I/O 地址。 
				/proc/kcore 		这个就是内存的大小啦！好大对吧！但是不要读他啦！ 
				/proc/loadavg 		还记得 top 以及 uptime 吧？没错！上头的三个平均数值就是记录在此！ 
				/proc/meminfo 		使用 free 列出的内存信息，嘿嘿！在这里也能够查阅到！ 
				/proc/modules 		目前我们的 Linux 已经加载的模块列表，也可以想成是驱动程序啦！ 
				/proc/mounts 		系统已经挂载的数据，就是用 mount 这个指令呼叫出来的数据啦！ 
				/proc/swaps 		到底系统挂加载的内存在哪里？呵呵！使用掉的 partition 就记录在此啦！
				/proc/partitions 	使用 fdisk -l 会出现目前所有的 partition 吧？在这个档案当中也有记录喔！ 
				/proc/pci 			在 PCI 总线上面，每个装置的详细情况！可用 lspci 来查阅！ 
				/proc/uptime 		就是用 uptime 的时候，会出现的信息啦！ 
				/proc/version 		核心的版本，就是用 uname -a 显示的内容啦！ 
				/proc/bus/* 		一些总线的装置，还有 USB 的装置也记录在此喔！
		查询已开启档案或已执行程序开启之档案
			fuser：藉由档案(或文件系统)找出正在使用该档案的程序
				[root@www ~]# fuser [-umv] [-k [i] [-signal]] file/dir 
				选项与参数： 
					-u ：除了程序的 PID 之外，同时列出该程序的拥有者； 
					-m ：后面接的那个档名会主动的上提到该文件系统的最顶层，对 umount 不成功很有效！ 
					-v ：可以列出每个档案与程序还有指令的完整相关性！ 
					-k ：找出使用该档案/目录的 PID ，并试图以 SIGKILL 这个讯号给予该 PID； 
					-i ：此项与 -k 配合，在删除 PID 指前会先询问使用者意愿！ 
					-signal：例如 -1 -15 等等，若不加的话，预设是 SIGKILL (-9) 啰！
				比较有趣的是那个 ACCESS 的项目，那个项目代表的意义为：
					c ：此程序在当前的目录下(非次目录)；
					e ：可被触发为执行状态；
					f ：是一个被开启的档案；
					r ：代表顶层目录 (root directory)；
					F ：该档案被开启了，不过在等待回应中；
					m ：可能为分享的动态函式库；
				fuser 可以让我们了解到某个档案 (或文件系统) 目前正在被哪些程序所利用！
			lsof ：列出被程序所开启的档案文件名
				相对于 fuser 是由档案或者装置去找出使用该档案或装置的程序，反过来说， 如何查出某个程序开启或者使用的档案与装置呢？呼呼！那就是使用 lsof 啰～
				[root@www ~]# lsof [-aUu] [+d] 
					选项与参数： 
						-a ：多项数据需要『同时成立』才显示出结果时！ 
						-U ：仅列出 Unix like 系统的 socket 文件类型； 
						-u ：后面接 username，列出该用户相关程序所开启的档案； 
						+d ：后面接目录，亦即找出某个目录底下已经被开启的档案！
			pidof ：找出某支正在执行的程序的 PID	
				[root@www ~]# pidof [-sx] program_name 
				选项与参数： 
					-s ：仅列出一个 PID 而不列出所有的 PID 
					-x ：同时列出该 program name 可能的 PPID 那个程序的 PID
	SELinux 初探
		什么是 SELinux
			什么是 SELinux 呢？其实他是『 Security Enhanced Linux 』的缩写，字面上的意义就是安全强化的 Linux 之意！
			当初设计的目标：避免资源的误用
				其实 SELinux 是在进行程序、档案等细部权限设定依据的一个核心模块！ 由于启动网络服务的也是程序，因此刚好也能够控制网络服务能否存取系统资源的一道关卡！
			传统的档案权限与账号关系：自主式访问控制, DAC
				知道系统的账号主要分为系统管理员 (root) 与一般用户，而这两种身份能否使用系统上面的档案资源则与 rwx 的权限设定有关。 不过你要注意的是，各种权限设定对 root 是无效的。因此，当某个程序想要对档案进行存取时， 系统就会根据该程序的拥有者/群组，并比对档案的权限，若通过权限检查，就可以存取该档案了。
				这种存取文件系统的方式被称为『自主式访问控制 (Discretionary Access Control, DAC)』，基本上，就是依据程序的拥有者与档案资源的 rwx 权限来决定有无存取的能力。 不过这种 DAC 的访问控制有几个困扰，那就是：
					root 具有最高的 权限：如果不小心某支程序被有心人士取得， 且该程序属于 root 的权限，那么这支程序就可以在系统上进行任何资源的存取！真是要命！
					用户可以取得程序来变更档案资源的访问权限：如果你不小心将某个目录的权限设定为 777 ，由于对任何人的权限会变成 rwx ，因此该目录就会被任何人所任意存取！
			以政策规则设定特定程序读取特定档案：委任式访问控制, MAC，(Mandatory Access Control, MAC)
				委任式访问控制 (MAC) 有趣啦！他可以针对特定的程序与特定的档案资源来进行权限的控管！ 也就是说，即使你是 root ，那么在使用不同的程序时，你所能取得的权限并不一定是 root ， 而得要看当时该程序的设定而定。如此一来，我们针对控制的『主体』变成了『程序』而不是用户喔！ 此外，这个主体程序也不能任意使用系统档案资源，因为每个档案资源也有针对该主体程序设定可取用的权限！ 如此一来，控件目就细多了！但整个系统程序那么多、档案那么多，一项一项控制可就没完没了！ 所以 SELinux 也提供一些预设的政策 (Policy) ，并在该政策内提供多个规则 (rule) ，让你可以选择是否启用该控制规则！
		SELinux 的运作模式
			SELinux 是透过 MAC 的方式来控管程序，他控制的主体是程序， 而目标则是该程序能否读取的『档案资源』！所以先来说明一下这些咚咚的相关性啦！(注4)
				主体 (Subject)： SELinux 主要想要管理的就是程序，因此你可以将『主体』跟本章课到的 process 划上等号；
				目标 (Object)： 主体程序能否存取的『目标资源』一般就是文件系统。因此这个目标项目可以与文件系统划上等号；
				政策 (Policy)： 由于程序与档案数量庞大，因此 SELinux 会依据某些服务来制订基本的存取安全性政策。这些政策内还会有详细的规则 (rule) 来指定不同的服务开放某些资源的存取与否。
					在目前的 CentOS 5.x 里面仅有提供两个主要的政策，分别是：
						targeted：针对网络服务限制较多，针对本机限制较少，是预设的政策；
						strict：完整的 SELinux 限制，限制方面较为严格。
					建议使用预设的 targeted 政策即可。
				安全性本文 (security context)： 我们刚刚课到了主体、目标与政策面，但是主体能不能存取目标除了政策指定之外，主体与目标的安全性本文必项一致才能够顸利存取。 这个安全性本文 (security context) 有点类似文件系统的 rwx 啦！安全性本文的内容与设定是非常重要的！ 如果设定错误，你的某些服务(主体程序)就无法存取文件系统(目标资源)，当然就会一直出现『权限不符』的错误讯息了！
			主体程序必须要通过 SELinux 政策内的规则放行后，就可以与目标资源进行安全性本文的比对， 若比对失败则无法存取目标，若比对成功则可以开始存取目标。
			安全性本文 (Security Context)
				安全性本文存在于主体程序中与目标档案资源中。程序在内存内，所以安全性本文可以存入是没问题。 那档案的安全性本文是记录在哪里呢？事实上，安全性本文是放置到档案的 inode 内的，因此主体程序想要读取目标档案资源时，同样需要读取 inode ， 这 inode 内就可以比对安全性本文以及 rwx 等权限值是否正确，而给予适当的读取权限依据。
				那么安全性本文到底是什么样的存在呢？我们先来看看 /root 底下的档案的安全性本文好了。 观察安全性本文可使用『 ls -Z 』去观察如下：(注意：你必项已经启动了 SELinux 才行！
				安全性本文主要用冒号分为三个字段，这三个字段的意义为： Identify:role:type 身份识别:角色:类型
			这三个字段的意义仔细的说明一下吧：
				身份识别 (Identify)： 相当于账号方面的身份识别！主要的身份识别则有底下三种常见的类型：
					root：表示 root 的账号身份，如同上面的表格显示的是 root 家目录下的数据啊！
					system_u：表示系统程序方面的识别，通常就是程序啰；
					user_u：代表的是一般使用者账号相关的身份。
					你会发现身份识别中，除了 root 之外，其他的识别后面都会加上『 _u 』的字样呢！ 这个身份识别重点再让我们了解该数据为何种身份所有哩～ 而系统上面大部分的数据都会是 system_u 或 root 啦！至于如果是在 /home 底下的数据，那么大部分应该就会是 user_u 啰！
				角色 (Role)： 透过角色字段，我们可以知道这个数据是属于程序、档案资源还是代表使用者。一般的角色有：
					object_r：代表的是档案或目录等档案资源，这应该是最常见的啰；
					system_r：代表的就是程序啦！不过，一般使用者也会被指定成为 system_r 喔！
					你也会发现角色的字段最后面使用『 _r 』来结尾！因为是 role 的意思嘛！
				类型 (Type) ：(最重要！) 在预设的 targeted 政策中， Identify 与 Role 字段基本上是不重要的！重要的在于这个类型 (type) 字段！ 基本上，一个主体程序能不能读取到这个档案资源，与类型字段有关！而类型字段在档案与程序的定义不太相同，分别是：
					type：在档案资源 (Object) 上面称为类型 (Type)；
					domain：在主体程序 (Subject) 则称为领域 (domain) 了！
					domain 需要与 type 搭配，则该程序才能够顸利的读取档案资源啦！
		SELinux 的启动、关闭与观察	
			目前 SELinux 支持三种模式，分别如下：
				enforcing：强制模式，代表 SELinux 运作中，且已经正确的开始限制 domain/type 了；
				permissive：宽容模式：代表 SELinux 运作中，不过仅会有警告讯息并不会实际限制 domain/type 的存取。这种模式可以运来作为 SELinux 的 debug 之用；
				disabled：关闭，SELinux 并没有实际运作。
			那你怎么知道目前的 SELinux 模式呢？就透过 getenforce 吧！
			我们又如何知道 SELinux 的政策 (Policy) 为何呢？这时可以使用 sestatus 来观察：
				[root@www ~]# sestatus [-vb] 
				选项与参数： 
					-v ：检查列于 /etc/sestatus.conf 内的档案与程序的安全性本文内容； 
					-b ：将目前政策的规则布尔值列出，亦即某些规则 (rule) 是否要启动 (0/1) 之意；
			SELinux 的配置文件是哪个档案啊？ 其实就是 /etc/selinux/config 这个档案喔
			SELinux 的启动与关闭
				如果改变了政策则需要重新启动，因为 SELinux 是整合到核心里面去的， 你只可以在 SELinux 运作下切换成为强制 (enforcing) 或宽容 (permissive) 模式，不能够直接关闭 SELinux 的！ 同时，由 SELinux 关闭 (disable) 的状态到开启的状态也需要重新启动啦！
				到 /boot/grub/menu.lst 这个档案去，看看核心有无关闭 SELinux。确认 kernel 后面不可以接『 selinux=0 』这个项目！因为 selinux=0 指定给核心时， 则核心会自动的忽略 /etc/selinux/config 的设定值，而直接略过 SELinux 的加载，所以你的 SELinux 模式就会变成 disabled 啦！
				让 SELinux 模式在 enforcing 与 permissive 之间切换的方法为：
					[root@www ~]# setenforce [0|1] 
					选项与参数： 0 ：转成 permissive 宽容模式； 1 ：转成 Enforcing 强制模式
		SELinux 网络服务运作范例
			ps -Z 这个『 -Z 』的选项可以让我们查阅程序的安全性本文
		重设 SELinux 安全性本文
			[root@www ~]# chcon [-R] [-t type] [-u user] [-r role] 档案 
			[root@www ~]# chcon [-R] --reference=范例文件 档案 
			选项与参数： 
				-R ：连同该目录下的次目录也同时修改； 
				-t ：后面接安全性本文的类型字段！例如 httpd_sys_content_t ； 
				-u ：后面接身份识别，例如 system_u； 
				-r ：后面接角色，例如 system_r； 
				--reference=范例文件：拿某个档案当范例来修改后续接的档案的类型！
			那有没有可以使用预设的安全性本文来还原的方式？ 有的，那就是 restorecon 这玩意儿：
				[root@www ~]# restorecon [-Rv] 档案或目录 
				选项与参数： 
					-R ：连同次目录一起修改； 
					-v ：将过程显示到屏幕上
			
		SELinux 所需的服务
			setroubleshoot --> 错误讯息写入 /var/log/messages
			几乎所有 SELinux 相关的程序都会以 se 为开头，这个服务也是以 se 为开头！这个服务会将关于 SELinux 的错误讯息与克服方法记录到 /var/log/messages 里头，所以你一定得要启动这个服务才好。
			auditd --> 详细资料写入 /var/log/audit/audit.log
				audit 是稽核的意思，这个 auditd 会将 SELinux 发生的错误信息写入 /var/log/audit/audit.log 中！
				与 setroubleshoot 不同的是， auditd 会将许多的 SELinux 信息都记录下来，不只是错误讯息而已， 因此登录档 /var/log/audit/audit.log 非常的庞大！要直接到这档案里面去搜寻数据是挺累人的～ 还好，SELinux 有提供一个 audit2why 的指令来让我们查询错误讯息的回报呢！那么这个指令如何使用呢？ 可以这样用的：[root@www ~]# audit2why < /var/log/audit/audit.log
		SELinux 的政策与规则管理	
			政策查阅
				[root@www ~]# seinfo [-Atrub] 
				选项与参数： 
					-A ：列出 SELinux 的状态、规则布尔值、身份识别、角色、类别等所有信息 
					-t ：列出 SELinux 的所有类别 (type) 种类 
					-r ：列出 SELinux 的所有角色 (role) 种类 
					-u ：列出 SELinux 的所有身份识别 (user) 种类
					-b ：列出所有规则的种类 (布尔值)
				想要知道详细的规则时， 就得要使用 sesearch 这个指令了！
					[root@www ~]# sesearch [-a] [-s 主体类别] [-t 目标类别] [-b 布尔值] 
					选项与参数： 
						-a ：列出该类别或布尔值的所有相关信息 
						-t ：后面还要接类别，例如 -t httpd_t 
						-b ：后面还要接布尔值的规则，例如 -b httpd_enable_ftp_server
				实际的政策数据都是放置到 /etc/selinux/targeted/policy/ 底下， 事实上，所有与 targetd 相关的信息都是放置到 /etc/selinux/targeted 里面的呢！包括安全性本文相关的信息。
			布尔值的查询与修改
				上面我们透过 sesearch 知道了，其实 Subject 与 Object 能否有存取的权限，是与布尔值有关的， 那么系统有多少布尔值可以透过 seinfo -b 来查询
				[root@www ~]# getsebool [-a] [布尔值条款] 
				选项与参数： 
					-a ：列出目前系统上面的所有布尔值条款设定为开启或关闭值
				那么如果查询到某个布尔值，并且以 sesearch 知道该布尔值的用途后，想要关闭或启动他，又该如何处置？ 
					[root@www ~]# setsebool [-P] 布尔值=[0|1] 
					选项与参数： 
						-P ：直接将设定值写入配置文件，该设定数据未来会生效的！
			默认目录的安全性本文查询与修改
				[root@www ~]# semanage {login|user|port|interface|fcontext|translation} -l 
				[root@www ~]# semanage fcontext -{a|d|m} [-frst] file_spec 
				选项与参数： 
					fcontext ：主要用在安全性本文方面的用途， 
					-l 为查询的意思； 
					-a ：增加的意思，你可以增加一些目录的默认安全性本文类型设定； 
					-m ：修改的意思； 
					-d ：删除的意思。		
			
			
			
第十八章、认识系统服务 (daemons)			
	什么是 daemon 与服务 (service)
		daemon 的主要分类
			如果依据 daemon 的启动与管理方式来区分，基本上，可以将 daemon 分为可独立启动的 stand alone ， 与透过一支super daemon 来统一管理的服务这两大类，这两类 daemon 的说明如下：
				stand_alone：此 daemon 可以自行单独启动服务
					这种类型的 daemon 可以自行启动而不必透过其他机制的管理； daemon 启动并加载到内存后就一直占用内存与系统资源。最大的优点就是：因为是一直存在内存内持续的提供服务， 因此对于发生客户端的要求时，stand alone 的 daemon 响应速度较快。常见的 stand alone daemon 有 WWW 的 daemon (httpd)、FTP 的 daemon (vsftpd) 等等
				super daemon： 一支特殊的 daemon 来统一管理
					这一种服务的启动方式则是藉由一个统一的 daemon 来负责唤起服务！这个特殊的 daemon 就被称为 super daemon 。 早期的 super daemon 是 inetd 这一个，后来则被 xinetd 所取代了。这种机制比较有趣的地方在于， 当没有客户端的要求时，各项服务都是未启动的情况，等到有来自客户端的要求时， super daemon 才唤醒相对应的服务。当客户端的要求结束后，被唤醒的这个服务也会关闭并释放系统资源。 这种机制的好处是： (1)由于 super daemon 负责唤醒各项服务，因此 super daemon 可以具有安全控管的机制，就是类似网络防火墙的功能啦！ (2)由于服务在客户端的联机结束后就关闭，因此不会一直占用系统资源。但是缺点是什么呢？ 因为有客户端的联机才会唤醒该服务，而该服务加载到内存的时间需要考虑进去，因此服务的反应时间会比较慢一些啦！ 常见的 super daemon 所管理的服务例如 telnet 这个玩意儿就是啦！
				daemon 工作形态的类型
					如果以 daemon 提供服务的的工作状态来区分，又可以将 daemon 分为两大类，分别是：
						signal-control 这种 daemon 是透过讯号来管理的，只要有任何客户端的需求进来，他就会立即启动去处理！例如打印机的服务 (cupsd)。
						interval-control 这种 daemon 则主要是『每隔一段时间就主动的去执行某项工作』，所以，你要作的是在配置文件指定服务要进行的时间与工作， 该服务在指定的时间才会去完成工作。我们在第十六章提到的 atd 与 crond 就属于这种类型的 daemon 啦 (每分钟侦测一次配置文件)
				daemon 的命名规则
					这些服务的名称被建立之后，被挂上 Linux 使用时，通常在服务的名称之后会加上一个 d ，例如例行性命令的建立的 at, 与 cron 这两个服务， 他的程序文件名会被取为 atd 与 crond，这个 d 代表的就是 daemon 的意思。
		服务与埠口的对应
			系统上面有没有什么设定可以让服务与埠号对应在一起呢？那就是 /etc/services 啦！第一栏为 daemon 的名称、第二栏为该 daemon 所使用的端口号与网络数据封包协议， 封包协议主要为可靠联机的 TCP 封包以及较快速但为非面向连接的 UDP 封包。
		daemon 的启动脚本与启动方式
			通常 distribution 都会记录每一支 daemon 启动后所取得程序的 PID 在 /var/run/ 这个目录下呢！
			通常 distribution 会给我们一个简单的 shell script 来进行启动的功能。 该 script 可以进行环境的侦测、配置文件的分析、PID 档案的放置，以及相关重要交换文件案的锁住 (lock) 动作， 你只要执行该 script ，上述的动作就一口气连续的进行，最终就能够顺利且简单的启动这个 daemon 啰
			CentOS 5.x 通常将 daemon 相关的档案放在哪里？ 以及某些重要的配置文件又是放置到哪里？基本上是放在这些地方：
				/etc/init.d/* ：启动脚本放置处 系统上几乎所有的服务启动脚本都放置在这里！事实上这是公认的目录，我们的 CentOS 实际上放置在 /etc/rc.d/init.d/ 啦！ 不过还是有设定连结档到 /etc/init.d/ 的！既然这是公认的目录，因此建议您记忆这个目录即可！啰
				/etc/sysconfig/* ：各服务的初始化环境配置文件 几乎所有的服务都会将初始化的一些选项设定写入到这个目录下，举例来说，登录档的 syslog 这支 daemon 的初始化设定就写入在 /etc/sysconfig/syslog 这里呢！而网络的设定则写在 /etc/sysconfig/network 这个档案中。 所以，这个目录内的档案也是挺重要的；
				/etc/xinetd.conf, /etc/xinetd.d/* ：super daemon 配置文件 super daemon 的主要配置文件 (其实是默认值) 为 /etc/xinetd.conf ，不过我们上面就谈到了， super daemon 只是一个统一管理的机制，他所管理的其他 daemon 的设定则写在 /etc/xinetd.d/* 里头喔！
				/etc/* ：各服务各自的配置文件 第六章就读过了，大家的配置文件都是放置在 /etc/ 底下的喔！
				/var/lib/* ：各服务产生的数据库 一些会产生数据的服务都会将他的数据写入到 /var/lib/ 目录中。举例来说，数据库管理系统 MySQL 的数据库默认就是写入 /var/lib/mysql/ 这个目录下啦！
				/var/run/* ：各服务的程序之 PID 记录处 我们在第十七章谈到可以使用讯号 (signal) 来管理程序， 既然 daemon 是程序，所以当然也可以利用 kill 或 killall 来管理啦！不过为了担心管理时影响到其他的程序， 因此 daemon 通常会将自己的 PID 记录一份到 /var/run/ 当中！例如登录文件的 PID 就记录在 /var/run/syslogd.pid 这个档案中。如此一来， /etc/init.d/syslog 就能够简单的管理自己的程序啰。
			Stand alone 的 /etc/init.d/* 启动
				由于系统的环境都已经帮你制作妥当，所以利用 /etc/init.d/* 来启动、关闭与观察，就非常的简单！话虽如此， 
				CentOS 还是有提供另外一支可以启动 stand alone 服务的脚本喔，那就是 service 这个程序。 其实 service 仅是一支 script 啦，他可以分析你下达的 service 后面的参数，然后根据你的参数再到 /etc/init.d/ 去取得正确的服务来 start 或 stop 哩！他的语法是这样的啦： 
					[root@www ~]# service [service name] (start|stop|restart|...) 
					[root@www ~]# service --status-all 
					选项与参数： 
						service name：亦即是需要启动的服务名称，需与 /etc/init.d/ 对应； 
						start|... ：亦即是该服务要进行的工作。 
						--status-all：将系统所有的 stand alone 的服务状态通通列出来
			Super daemon 的启动方式
				因为 super daemon 要管理后续的其他服务嘛，他当然自己要常驻在内存中啦！所以 Super daemon 自己启动的方式与 stand alone 是相同的！ 但是他所管理的其他 daemon 就不是这样做啰！必须要在配置文件中设定为启动该 daemon 才行。配置文件就是 /etc/xinetd.d/* 的所有档案。那如何得知 super daemon 所管理的服务是否有启动呢？你可以这样做： [root@www ~]# grep -i 'disable' /etc/xinetd.d/*
				因为 disable 是『取消』的意思，因此如果『 disable = yes 』则代表取消此项服务的启动，如果是『 disable = no 』 才是有启动该服务啦！
				也就是说，你先修改 /etc/xinetd.d/ 底下的配置文件，然后再重新启动 xinetd 就对了！而 xinetd 是一个 stand alone 启动的服务！这部份得要特别留意呢！
	解析 super daemon 的配置文件		
		默认值配置文件：/etc/xinetd.conf
			为什么 /etc/xinetd.conf 可以称为默认值的配置文件呢？因为如果你有启动某个 super daemon 管理的服务， 但是该服务的设定值并没有指定上述的那些项目，那么该服务的设定值就以上述的默认值为主！
			既然这只是个预设参数档，那么自然有更多的服务参数档案啰～没错～而所有的服务参数档都在 /etc/xinetd.d 里面，这是因为上表当中的最后一行啊！这样瞭了吧！ ^_^。那举每个参数档案的内容是怎样呢？一般来说，他是这样的： 
				service <service_name> { <attribute> <assign_op> <value> <value> ... ............. }
				第一行一定都有个 service ，至于那个 <service_name> 里面的内容，则与 /etc/services 有关，因为他可以对照着/etc/services 内的服务名称与埠号来决定所要启用的 port 是哪个啊！ 然后相关的参数就在两个大刮号中间。
				attribute 是一些 xinetd 的管理参数， 
				assign_op 则是参数的设定方法。 assign_op 的主要设定形式为： 
					= ： 表示后面的设定参数就是这样啦！ 
					+= ： 表示后面的设定为『在原来的设定里头加入新的参数』 
					-= ： 表示后面的设定为『在原来的参数舍弃这里输入的参数！』
				用途不太相同，敬请留意呦！好了！底下再来说一说那些 attribute 与 value ！ 
					attribute (功能) 		说明与范例 
					一般设定项目：服务的识别、启动与程序 
					disable (启动不否) 		设定值：[yes|no]，预设 disable = yes disable 为取消的意思，此值可设定该服务是否要启动。预设所有的 super daemon 管理的服务都不启动的。 若要启动就得要设定为『 disable = no 』 
					id (服务识别) 			设定值：[服务的名称] 虽然服务在配置文件开头『 service 服务名称』已经指定了，不过有时后会有重复的设定值，此时可以用 id 来取代服务名称。 你可以参考一下 /etc/xinetd.d/time-stream 来思考一下原理。 
					server (程序文件名) 	设定值：[program 的完整檔名] 这个就是指出这个服务的启动程序！例如 /usr/bin/rsync 为启动 rsync 服务的指令，所以这个设定值就会成为： 『 server = /usr/bin/rsync 』 
					server_args (程序参数) 	设定值：[程序相关的参数] 这里应该输入的就是你的 server 那里需要输入的一些参数啦！例如 rsync 需要加入 --daemon ， 所以这里就设定：『 server_args = --daemon 』。与上面 server 搭配，最终启动服务的方式『/usr/bin/rsync --daemon』 
					user (服务所属UID) 		设定值：[使用者账号] 如果 xinetd 是以 root 的身份启动来管理的，那么这个项目可以设定为其他用户。此时这个 daemon 将会以此设定值指定的身份来启动该服务的程序喔！举例来说，你启动 rsync 时会以这个设定值作为该程序的 UID。 
					group 					跟 user 的意思相同！此项目填入组名即可。 
					一般设定项目：联机方式与联机封包协议 
					socket_type (封包类型) 	设定值：[stream|dgram|raw]，与封包有关 stream 为联机机制较为可靠的 TCP 封包，若为 UDP 封包则使用 dgram 机制。raw 代表 server 需要与 IP 直接对谈！举例来说 rsync 使用 TCP ，故设定为『socket_type = stream 』 
					protocol (封包类型) 	设定值：[tcp|udp]，通常使用 socket_type 取代此设定 使用的网络协议，需参考 /etc/protocols 内的通讯协议，一般使用 tcp 或 udp。由于与 socket_type 重复， 因此这个项目可以不指定。 
					wait (联机机制) 		设定值：[yes(single)|no(multi)]，预设 wait = no 这就是我们刚刚提到的 Multi-threaded 与 single-threaded ！一般来说，我们希望大家的要求都可以同时被启用，所以可以设定『 wait = no 』 此外，一般 udp 设定为 yes 而 tcp 设定为 no。 
					instances (最大联机数) 	设定值：[数字或 UNLIMITED] 这个服务可接受的最大联机数量。如果你只想要开放 30 个人联机 rsync 时，可在配置文件内加入：『 instances = 30 』
					per_source (单一用户来源)设定值：[一个数字或 NULIMITED] 如果想要控制每个来源 IP 仅能有一个最大的同时联机数，就指定这个项目吧！例如同一个 IP 最多只能连 10 条联机『 per_source = 10 』 
					cps (新联机限制) 		设定值：[两个数字] 为了避免短时间内大量的联机要求导致系统出现忙碌的状态而有这个 cps 的设定值。第一个数字为一秒内能够接受的最多新联机要求， 第二个数字则为，若超过第一个数字那暂时关闭该服务的秒数。 
					一般设定项目：登录文件的记录 
					log_type (登录档类型) 	设定值：[登录项目 等级] 当数据记录时，以什么登录项目记载？且需要记载的等级为何(默认为 info 等级)。这两个设定值得要看过下一章登录档后才会知道哩！这边你先有印象即可。 
					log_on_success 
					log_on_failure (登录状态)设定值：[PID,HOST,USERID,EXIT,DURATION] 在『成功登入』或『失败登入』之后，需要记录的项目：PID 为记录该 server 启动时候的 process ID ， HOST 为进程主机的 IP、USERID 为登入者的账号、EXIT 为离开的时候记录的项目、DURATION 为该用户使用此服务多久？ 
					进阶设定项目：环境、网络端口口与联机机制等 
					env (额外变量设定) 		设定值：[变量名称=变量内容] 这一个项目可以让你设定环境变量，环境变量的设定规则可以参考第十一章。 
					port (非正规埠号) 		设定值：[一组数字(小于 65534)] 这里可以设定不同的服务与对应的 port ，但是请记住你的 port 与服务名称必须与 /etc/services 内记载的相同才行！不过，若服务名称是你自定义的，那么这个 port 就可以随你指定 
					redirect (服务转址) 	设定值：[IP port] 将 client 端对我们 server 的要求，转到另一部主机上去！呵呵！这个好玩呦！ 例如当有人要使用你的 ftp 时，你可以将他转到另一部机器上面去！那个 IP_Address 就代表另一部进程主机的 IP 啰！ 
					includedir (呼叫外部设定)设定值：[目录名称] 表示将某个目录底下的所有档案都给他塞进来 xinetd.conf 这个设定里头！这东西有用多了， 如此一来我们可以一个一个设定不同的项目！而不需要将所有的服务都写在 xinetd.conf 当中！你可以在 /etc/xinetd.conf 发现这个设定呦！ 
					安全控管项目： 
					bind (服务接口锁定) 	设定值：[IP] 这个是设定『允讲使用此一服务的适配卡』的意思！举个例子来说，你的 Linux 主机上面有两个 IP ，而你只想要让 IP1 可以使用此一服务，但 IP2 不能使用此服务，这里就可以将 IP1 写入即可！那么 IP2 就不 可以使用此一 server 啰 
					interface 				设定值：[IP] 与 bind 相同 
					only_from (防火墙机制) 	设定值：[0.0.0.0, 192.168.1.0/24, hostname, domainname] 这东西用在安全机制上面，也就是管制『只有这里面规定的 IP 或者是主机名可以登入！』如果是 0.0.0.0 表示所有的 PC 皆可登入，如果是 192.168.1.0/24 则表示为 C class 的网域！亦即由192.168.1.1 ~ 192.168.1.255 皆可登入！另外，也可以选择 domain name ，例如 .dic.ksu.edu.tw 就可以允讲昆山资传系网域的 IP 登入你的主机使用该 server ！ 
					no_access (防火墙机制) 	设定值：[0.0.0.0, 192.168.1.0/24, hostname, domainname] 跟 only_from 差不多啦！就是用来管理可否进入你的 Linux 主机启用你的 server 服务的管理项目！ no_access 表示『不可登入』的 PC 啰！ 
					access_times (时间控管) 设定值：[00:00-12:00, HH:MM-HH:MM] 这个项目在设定『该服务 server 启动的时间』，使用的是 24 小时的设定！例如你的 ftp 要在 8 点到 16 点开放的话，就是： 08:00-16:00。 
					umask 					设定值：[000, 777, 022] 还记得在第七章提到的 umask 这个东西吗？呵呵！没错！ 就是那个鬼玩意儿啰！可以设定用户建立目录或者是档案时候的属性！系统建议值是 022 。
	服务的防火墙管理 xinetd, TCP Wrappers
		一般来说，系统的防火墙分析主要可以透过封包过滤或者是透过软件分析，我们的 Linux 默认有提供一个软件分析的工具， 那就是 /etc/hosts.deny, /etc/hosts.allow 这两个可爱的配置文件！另外，如果有安装 tcp wrappers 套件时， 我们甚至可以加上一些额外的追踪功能呢！
		/etc/hosts.allow, /etc/hosts.deny 管理
			任何以 xinetd 管理的服务，都可以透过 /etc/hosts.allow, /etc/hosts.deny 来设定防火墙。那么什么是防火墙呢？简单的说，就是针对来源 IP 或网域进行允许或拒绝的设定， 以决定该联机是否能够成功达成连接的一种方式就是了。其实我们刚刚修改 /etc/xinetd.d/rsync 里头的 no_access, only_from 也可以进行这方面的防火墙设定。不过，使用 /etc/hosts.allow, /etc/hosts.deny 则更容易集中控管，在设定与查询方面也较为方便！
			其实 /etc/hosts.allow 与 /etc/hosts.deny 也是 /usr/sbin/tcpd 的配置文件，而这个 /usr/sbin/tcpd 则是用来分析进入系统的 TCP 网络封包的一个软件，TCP 是一种面向连接的网络联机封包，包括 www, email, ftp 等等都是使用 TCP 封包来达成联机的喔。 所以啰，顾名思义，这个套件本身的功能就是在分析 TCP 网络数据封包啦！而 TCP 封包的文件头主要记录了来源与目标主机的 IP 与 port ，因此藉由分析 TCP 封包并搭配 /etc/hosts.{allow,deny} 的规则比对，就可以决定该联机是否能够进入我们的主机啦。 所以啦，我们要使用 TCP Wrappers 来控管的就是：
				1. 来源 IP 或/与 整个网域的 IP 网段；
				2. port (就是服务啦，前面有谈到启动某个埠口是 daemon 的责任啊)
			基本上只要一个服务受到 xinetd 管理，或者是该服务的程序支持 TCP Wrappers 函式的功能时，那么该服务的防火墙方面的设定就能够以 /etc/hosts.{allow,deny} 来处理啰。换个方式来说，只要不支持 TCP Wrappers 函式功能的软件程序就无法使用 /etc/hosts.{allow,deny} 的设定值啦
			ldd (library dependency discovery) 这个指令可以查询某个程序的动态函式库支持状态，因此透过这个 ldd 我们可以轻松的就查询到 sshd, httpd 有无支持 tcp wrappers 所提供的 libwrap.so 这个函式库档案。
			配置文件语法
				这两个档案的设定语法都是一样的，基本上，看起来应该像这样： 
					<service(program_name)> : <IP, domain, hostname> : <action> 
					<服务 (亦即程序名称)> : <IP 或领域 或主机名> : < 动作 > 
					# 上头的 < > 是不存在于配置文件中的喔！
				我们存在两个档案，其中需要注意的是：
					写在 hosts.allow 当中的 IP 与网段，为预设『可通行』的意思，亦即最后一个字段 allow 可以不用写；
					而写在 hosts.deny 当中的 IP 与网段则预设为 deny ，第三栏的 deny 亦可省略；
					这两个档案的判断依据是： (1) 以 /etc/hosts.allow 为优先，而 (2) 若分析到的 IP 或网段并没有记录在 /etc/hosts.allow ，则以 /etc/hosts.deny 来判断。
				此外，我们还可以使用一些特殊参数在第一及第二个字段喔！内容有：
					ALL：代表全部的 program_name 或者是 IP 都接受的意思，例如 ALL: ALL: deny
					LOCAL：代表来自本机的意思，例如： ALL: LOCAL: allow
					UNKNOWN：代表不知道的 IP 或者是 domain 或者是服务时；
					KNOWN：代表为可览析的 IP, domain 等等信息时；
		TCP Wrappers 特殊功能
			那么有没有更安全的设定？例如，当有其他人扫瞄我的 rsync port 时，我就将他的 IP 记住，以做为未来的查询与认证之用呢？ 是有的！只是，那就得要有额外的动作参数加在第三栏了，而且你还需要安装了 TCP Wrappers 软件才行。要确定有没有安装 TCP Wrappers 可以使用『 rpm -q tcp_wrappers 』来查询喔。至于更加细部的主要动作则有：
				spawn (action) 可以利用后续接的 shell 来进行额外的工作，且具有变量功能，主要的变量内容为： %h (hostname), %a (address), %d (daemon)等等；
				twist (action) 立刻以后续的指令进行，且执行完后终止该次联机的要求 (DENY)
			为了达成追踪来源目标的相关信息的目的，此时我们需要 safe_finger 这个指令的辅助才行。而且我们还希望客户端的这个恶意者能够被警告。 整个流程可以是这样的：
				1. 利用 safe_finger 去追踪出对方主机的信息 (包括主机名、用户相关信息等)；
				2. 将该追踪到的结果以 email 的方式寄给我们本机的 root ；
				3. 在对方屏幕上面显示不可登入且警告他已经被记录的讯息
			由于是抵挡的机制，因此我们这个 spawn 与 twist 的动作大多是写在 /etc/hosts.deny 档案中的。我们将上述的动作写成类似如下的东东： 
				[root@www ~]# vim /etc/hosts.deny 
				rsync : ALL: spawn (echo "security notice from host $(/bin/hostname)" ;\ 
				echo; /usr/sbin/safe_finger @%h ) | \ 
				/bin/mail -s "%d-%h security" root & \ 
				: twist ( /bin/echo -e "\n\nWARNING connection not allowed.\n\n" )
			上面其实是针对一个 rsync 所写的信息，你可以看到上面这四行共有三个冒号来隔开成四个咚咚，这四个咚咚的意义是：
				1. rsync： 指的就是 rsync 这个服务的程序啰；
				2. ALL： 指的是来源，这个范围指的当然是全部的所有来源啰，因为是 ALL 嘛！
				3. spawn (echo "security notice from host $(/bin/hostname)" ; echo ; /usr/sbin/safe_finger @%h ) | /bin/mail -s "%d-%h security" root &： 由于要将一些侦测的数据送给 root 的邮件信箱，因此需要使用数据流汇整的括号( )，括号内的重点在于 safe_finger 的项目，他会侦测到客户端主机的相关信息，然后使用管线命令将这些数据送给 mail 处理， mail 会将该信息以标头为 security 的字样寄给 root 啦！由于 spawn 只是中间的过程，所以还能够有后续的动作哩！
				4. twist ( /bin/echo -e "\n\nWARNING connection not allowed.\n\n" )： 这个动作会将 Warning 的字样传送到客户端主机的屏幕上！ 然后将该联机中断。
	系统开启的服务	
		观察系统启动的服务
			观察系统已启动的服务方式很多，不过，我们最常使用 netstat 来观察。基本上，以 ps 来观察整个系统上面的服务是比较妥当的，因为他可以将全部的 process 都找出来。不过，我们比较关心的还是在于有启动网络监听的服务啊， 所以鸟哥会比较喜欢使用 netstat 来查阅啦。
		设定开机后立即启动服务的方法	
			到底我的 Linux 主机是怎么开机的呢？
				1. 打开计算机电源，开始读取 BIOS 并进行主机的自我测试；
				2. 透过 BIOS 取得第一个可开机装置，读取主要开机区 (MBR) 取得开机管理程序；
				3. 透过开机管理程序的设定，取得 kernel 并加载内存且侦测系统硬件；
				4. 核心主动呼叫 init 程序；
				5. init 程序开始执行系统初始化 (/etc/rc.d/rc.sysinit)
				6. 依据 init 的设定进行 daemon start (/etc/rc.d/rc[0-6].d/*)
				7. 加载本机设定 (/etc/rc.d/rc.local)
			chkconfig： 管理系统服务默认开机启动与否
				[root@www ~]# chkconfig --list [服务名称] 
				[root@www ~]# chkconfig [--level [0123456]] [服务名称] [on|off] 
				选项与参数： 
					--list ：仅将目前的各项服务状态栏出来 
					--level：设定某个服务在该 level 下启动 (on) 或关闭 (off)
			ntsysv： 类图形接口管理模式
				注意喔， chkconfig 很多的 distributions 都存在，但是 ntsysv 则是 Red Hat 系统特有的！ 
				[root@www ~]# ntsysv [--level <levels>] 
				选项与参数： 
					--level ：后面可以接不同的 run level ，例如 ntsysv --level 35
			chkconfig： 设定自己的系统服务 
				[root@www ~]# chkconfig [--add|--del] [服务名称] 
				选项与参数： 
					--add ：增加一个服务名称给 chkconfig 来管理，该服务名称必须在 /etc/init.d/ 内 
					--del ：删除一个给 chkconfig 管理的服务
			现在你知道 chkconfig 与 ntsysv 是真好用的东西，那么如果我自己写了一个程序并且想要让该程序成为系统服务好让 chkconfig 来管理时， 可以怎么进行呢？只要将该服务加入 init 可以管理的 script 当中，亦即是 /etc/init.d/ 当中即可。 举个例子，我们在 /etc/init.d/ 里面建立一个 myvbird 档案，该档案仅是一个简单的服务范例，基本上，没有任何用途.... 对于该档案的必须性是这样的：
				myvbird 将在 run level 3 及 5 启动；
				myvbird 在 /etc/rc.d/rc[35].d 当中启动时，以 80 顺位启动，以 70 顺位结束。
			关亍所谓的顺位问题，我们会在第二十章介绍，这里你先看看即可。 你该如何进行呢？可以这样做： 
				[root@www ~]# vim /etc/init.d/myvbird 
				#!/bin/bash 
				# chkconfig: 35 80 70 
				# description: 没啥！只是用来作为练习之用的一个范例 
				echo "Nothing"
			这个档案很好玩喔！你可以参考你自己系统上面的档案；基本上，比较重要的是第二行，他的语法是： 『 chkconfig:[runlevels] [启动顺位] [停止顺位] 』其中， runlevels 为不同的 run level 状态，启动顺位 (start number) 与 结束顺位 (stop number) 则是在 /etc/rc.d/rc[35].d 内建立以 S80myvbird 及 K70myvbird 为档名的设定方式！ 
				[root@www ~]# chkconfig --list myvbird 
				service myvbird supports chkconfig, but is not referenced in any runlevel (run 'chkconfig --add myvbird') # 尚未加入 chkconfig 的管理机制中！所以需要再动点手脚 
				[root@www ~]# chkconfig --add myvbird; chkconfig --list myvbird 
				myvbird 0:off 1:off 2:off 3:on 4:off 5:on 6:off # 看吧！加入了 chkconfig 的管理当中了！ 
				# 很有趣吧！如果要将这些数据都删除的话，那么就下达这样的情况： 
				[root@www ~]# chkconfig --del myvbird 
				[root@www ~]# rm /etc/init.d/myvbird
			
			
第十九章、认识与分析登录档	
	什么是登录档
		那么什么是登录档呢？简单的说，就是记录系统活动信息的几个档案， 例如：何时、何地 (来源 IP)、何人 (什么服务名称)、做了什么动作 (讯息登录啰)。
		登录档的重要性
			解决系统方面的错误
			解决网络服务的问题
			过往事件记录簿
		Linux 常见的登录档档名
			登录文件的权限通常是设定为仅有 root 能够读取而已。
			/var/log/cron
			/var/log/dmesg
				记录系统在开机的时候核心侦测过程所产生的各项信息。由于 CentOS 默认将开机时核心的硬件侦测过程取消显示， 因此额外将数据记录一份在这个档案中
			/var/log/lastlog
				可以记录系统上面所有的账号最近一次登入系统时的相关信息
			/var/log/maillog 戒 /var/log/mail/*
				记录邮件的往来信息，其实主要是记录 sendmail (SMTP 协议提供者) 与 dovecot (POP3 协议提供者) 所产生的讯息啦。 SMTP 是发信所使用的通讯协议， POP3 则是收信使用的通讯协议。 sendmail 与 dovecot 则分别是两套达成通讯协议的软件
			/var/log/messages
				这个档案相当的重要，几乎系统发生的错误讯息 (或者是重要的信息) 都会记录在这个档案中； 如果系统发生莫名的错误时，这个档案是一定要查阅的登录档之一。
			/var/log/secure
				基本上，只要牵涉到『需要输入账号密码』的软件，那么当登入时 (不管登入正确或错误) 都会被记录在此档案中。 包括系统的 login 程序、图形接口登入所使用的 gdm 程序、 su, sudo 等程序、还有网络联机的 ssh, telnet 等程序， 登入信息都会被记载在这里；
			/var/log/wtmp, /var/log/faillog
				这两个档案可以记录正确登入系统者的帐户信息 (wtmp) 与错误登入时所使用的帐户信息 (faillog)
			/var/log/httpd/*, /var/log/news/*, /var/log/samba/*
				不同的网络朋务会使用它们自己的登录档案来记载它们自己产生的各项讯息
		登录档所需相关服务 (daemon) 与程序
			针对登录文件所需的功能，我们需要的服务与程序有：
				syslogd：主要登录系统与网络等服务的讯息；
				klogd：主要登录核心产生的各项信息；
				logrotate：主要在进行登录文件的轮替功能
	syslogd ：记录登录文件的服务
		登录档内容的一般格式
			一般来说，系统产生的讯息经过 syslog 而记录下来的数据中，每条讯息均会记录底下的几个重要数据：
				事件发生的日期与时间；
				发生此事件的主机名；
				启动此事件的朋务名称 (如 samba, xinetd 等) 或函式名称 (如 libpam ..)；
				该讯息的实际数据内容。
			当然，这些信息的『详细度』是可以修改的
		syslog 的配置文件：/etc/syslog.conf
			基本上， syslog 针对各种服务与讯息记录在某些档案的配置文件就是 /etc/syslog.conf， 
			这个档案规定了『(1)什么服务 (2)的什么等级讯息 (3)需要被记录在哪里(装置或档案)』 这三个咚咚，所以设定的语法会是这样： 
				服务名称[.=!]讯息等级 讯息记录的文件名或装置或主机 
				# 底下以 mail 这个朋务产生的 info 等级为例： 
					mail.info /var/log/maillog_info # 这一行说明：mail 服务产生的大于等于 info 等级的讯息，都记录到 # /var/log/maillog_info 档案中的意思。
			我们将上面的数据简单的分为三部分来说明：
				服务名称
					syslog 本身有规范一些服务，你可以透过这些服务来储存系统的讯息。syslog 认识的朋务主要有底下这些： (可使用 man 3 syslog 查询到相关的信息) 
					服务类别 		说明 
					auth (authpriv) 主要与认证有关的机制，例如 login, ssh, su 等需要账号/密码的咚咚； 
					cron 			就是例行性工作排程 cron/at 等产生讯息记录的地方； 
					daemon 			与各个 daemon 有关的讯息； 
					kern 			就是核心 (kernel) 产生讯息的地方； 
					lpr 			亦即是打印相关的讯息啊！ 
					mail 			只要与邮件收发有关的讯息记录都属于这个； 
					news 			与新闻组服务器有关的东西； 
					syslog 			就是 syslogd 这支程序本身产生的信息啊！ 
					user, 
					uucp, 
					local0 ~ local7 与 Unix like 机器本身有关的一些讯息。
				讯息等级
					基本上，syslog 将讯息分为七个主要的等级，依序是这样的(由不重要排列到重要讯息等级)： 
						等级 	等级名称 	说明 
						1 		info 		仅是一些基本的讯息说明而已； 
						2 		notice 		比 info 还需要被注意到的一些信息内容； 
						3 		warning (warn) 警示的讯息，可能有问题，但是还不至于影响到某个 daemon 运作的信息；基本上， info, notice, warn 这三个讯息都是在告知一些基本信息而已，应该还不至于造成一些系统运作困扰； 
						4 		err (error) 一些重大的错误讯息，例如配置文件的某些设定值造成该服务无法启动的信息说明， 通常藉由 err 的错误告知，应该可以了解到该服务无法启动的问题呢！ 
						5 		crit 		比 error 还要严重的错误信息，这个 crit 是临界点 (critical) 的缩写，这个错误已经很严重了喔！ 
						6 		alert 		警告警告，已经很有问题的等级，比 crit 还要严重！ 
						7 		emerg (panic) 疼痛等级，意指系统已经几乎要当机的状态！ 很严重的错误信息了。通常大概只有硬件出问题，导致整个核心无法顺利运作，就会出现这样的等级的讯息吧！
				除了这些有等级的讯息外，还有两个特殊的等级，那就是 debug(错误侦测等级) 与 none (不需登录等级) 两个，当我们想要作一些错误侦测，或者是忽略掉某些服务的信息时， 就用这两个咚咚吧！ 特别留意一下在讯息等级之前还有 [.=!] 的链接符号喔！他代表的意思是这样的：
					. ：代表『比后面还要高的等级 (含该等级) 都被记录下来』的意思，例如： mail.info 代表只要是 mail 的信息，而且该信息等级高于 info (含 info 本身)时，就会被记录下来的意思。
					.=：代表所需要的等级就是后面接的等级而已， 其他的不要！
					.!：代表不等亍， 亦即是除了该等级外的其他等级都记录。
				讯息记录的文件名或装置或主机
					底下就是一些常见的放置处：
						档案的绝对路径：通常就是放在 /var/log 里头的档案啦！
						打印机或其他：例如 /dev/lp0 这个打印机装置
						使用者名称：显示给用户啰！
						进程主机：例如 @www.vbird.tsai 当然啦，要对方主机也能支持才行！
						*：代表『目前在在线的所有人』，类似 wall 这个指令的意义！
		登录档的安全性设置
			syslog 的登录档只要『被编辑过』就无法继续记录！ 所以才会导致不能记录的问题。要让该登录档可以继续写入，你只要重新启动 syslog (/etc/init.d/syslog restart) 即可。
		登录档朋务器的设定
			既然是登录档服务器，那么我们的 Linux 主机当然会启动一个埠口来监听了，那个预设的埠口就是 UDP 的 514 喔！
			既然是登录档『服务器』，所以当然有服务器与客户端 (client) 啰！这两者的设定分别是这样的： 
				# 1. Server 端：修改 syslogd 的启动配置文件，通常在 /etc/sysconfig 内！ 
					[root@www ~]# vim /etc/sysconfig/syslog # 找到底下这一行： SYSLOGD_OPTIONS="-m 0" # 改成底下这样子！ SYSLOGD_OPTIONS="-m 0 -r" 
				# 2. 重新启动与观察 syslogd 喔！ 
					[root@www ~]# /etc/init.d/syslog restart 
					[root@www ~]# netstat -lunp | grep syslog
					Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name 
					udp 0 0 0.0.0.0:514 0.0.0.0:* 13981/syslogd # 嘿嘿！你的登录文件主机已经设定妥当啰！很简单吧！
			至于 client 端的设定就简单多了！只要指定某个信息传送到这部主机即可！ 举例来说，我们的登录档朋务器 IP 为 192.168.1.100 ，而 client 端希望所有的数据都送给主机， 所以，可以在 /etc/syslog.conf 里面新增这样的一行： [root@www ~]# vim /etc/syslog.conf *.* @192.168.1.100
	登录档的轮替(logrotate)
		syslog 利用的是 daemon 的方式来启动的， 当有需求的时候立刻就会被执行的，但是 logrotate 却是在规定的时间到了之后才来进行登录档的轮替， 所以这个 logrotate 程序当然就是挂在 cron 底下进行的呦
		logrotate 的配置文件
			那么 logrotate 这个程序的参数配置文件在哪里呢？呵呵！那就是：
				/etc/logrotate.conf
				/etc/logrotate.d/
			那个 logrotate.conf 才是主要的参数档案，至于 logrotate.d 是一个目录， 该目录里面的所有档案都会被主动的读入 /etc/logrotate.conf 当中来进行！另外，在 /etc/logrotate.d/ 里面的档案中，如果没有规定到的一些细部设定，则以 /etc/logrotate.conf 这个档案的规定来指定为默认值！
			由这个档案的设定我们可以知道 /etc/logrotate.d 其实就是由 /etc/logrotate.conf 所规划出来的目录，所以，其实我们可以将所有的资料都给他写入 /etc/logrotate.conf 即可，但是这样一来这个档案就实在是太复杂了，尤其是当我们使用很多的服务在系统上面时， 每个服务都要去修改 /etc/logrotate.conf 的设定也似乎不太合理～ 所以，如果独立出来一个目录，那么每个以 RPM 打包方式所建立的服务的登录档轮替设定， 就可以独自成为一个档案，并且放置到 /etc/logrotate.d/ 当中即可，真是方便又合理的做法啊！ ^_^
			logrotate.conf 的设定语法是：
				登录文件的绝对路径文件名 ... { 
					个别的参数设定值，如 monthly, compress 等等 
				}
			/etc/logrotate.d/下的配置文件的设定语法是：
				檔名：被处理的登录文件绝对路径文件名写在前面，可以使用空格符分隔多个登录档；
				参数：上述档名进行轮替的参数使用 { } 包括起来；
				执行脚本：可呼叫外部指令来进行额外的命令下达，这个设定需与 sharedscripts .... endscript 设定合用才行。至于可用的环境为：
					prerotate：在启动 logrotate 之前进行的指令，例如修改登录文件的属性等动作；
					postrotate：在做完 logrotate 之后启动的指令，例如重新启动 (kill -HUP) 某个服务！
					Prerotate 与 postrotate 对于已加上特殊属性的档案处理上面，是相当重要的执行程序！
		实际测试 logrotate 的动作
			[root@www ~]# logrotate [-vf] logfile 
			选项与参数： 
				-v ：启动显示模式，会显示 logrotate 运作的过程喔！ 
				-f ：不论是否符合配置文件的数据，强制每个登录档都进行 rotate 的动作！
		自定义登录文件的轮替功能
	分析登录档
		CentOS 预设提供的 logwatch
			CentOS 5.x 上面预设的 logwatch 这个套件所提供的分析工具， 他会每天分析一次登录档案，并且将数据以 email 的格式寄送给 root 呢


第二十章、开机流程、模块管理与 Loader
	Linux 的开机流程分析
		开机流程一览
			简单来说，系统开机的经过可以汇整成底下的流程的：
				1. 加载 BIOS 的硬件信息与进行自我测试，并依据设定取得第一个可开机的装置；
				2. 读取并执行第一个开机装置内 MBR 的 boot Loader (亦即是 grub, spfdisk 等程序)；
				3. 依据 boot loader 的设定加载 Kernel ，Kernel 会开始侦测硬件与加载驱动程序；
				4. 在硬件驱动成功后，Kernel 会主动呼叫 init 程序，而 init 会取得 run-level 信息；
				5. init 执行 /etc/rc.d/rc.sysinit 档案来准备软件执行的作业环境 (如网络、时区等)；
				6. init 执行 run-level 的各个服务并启动 (script 方式)；
				7. init 执行 /etc/rc.d/rc.local 档案；
				8. init 执行终端机仿真程序 mingetty 来启动 login 程序，最后就等待用户登入啦；
		BIOS, boot loader 与 kernel 载入
			BIOS, 开机自我测试与 MBR
				在个人计算机架构下，你想要启动整部系统首先就得要让系统去加载 BIOS (Basic Input Output System)，并透过 BIOS 程序去加载 CMOS 的信息，并且藉由 CMOS 内的设定值取得主机的各项硬件配置， 例如 CPU 与接口设备的沟通频率啊、开机装置的搜寻顺序啊、硬盘的大小与类型啊、 系统时间啊、各周边总线的是否启动 Plug and Play (PnP, 即插即用装置) 啊、 各接口设备的 I/O 地址啊、以及与 CPU 沟通的 IRQ 岔断等等的信息。
				在取得这些信息后，BIOS 还会进行开机自我测试 (Power-on Self Test, POST) (注1)。 然后开始执行硬件侦测的初始化,并设定 PnP 装置，之后再定义出可开机的装置顺序， 接下来就会开始进行开机装置的数据读取了 (MBR 相关的任务开始)。
				由于我们的系统软件大多放置到硬盘中嘛！所以 BIOS 会指定开机的装置好让我们可以读取磁盘中的操作系统核心档案。 但由于不同的操作系统他的文件系统格式与相同，因此我们必须要以一个开机管理程序来处理核心档案加载 (load) 的问题， 因此这个开机管理程序就被称为 Boot Loader 了。那这个 Boot Loader 程序安装在哪里呢？就在开机装置的第一个扇区 (sector) 内，也就是我们一直谈到的 MBR (Master Boot Record, 主要启动记录区)。
				那你会不会觉得很奇怪啊？既然核心档案需要 loader 来读取，那每个操作系统的 loader 都不相同， 这样的话 BIOS 又是如何读取 MBR 内的 loader 呢？很有趣的问题吧！其实 BIOS 是透过硬件的 INT 13 中断功能来读取 MBR 的，也就是说，只要 BIOS 能够侦测的到你的磁盘 (不论该磁盘是 SATA 还是 IDE 接口)，那他就有办法透过 INT 13 这条信道来读取该磁盘的第一个扇区内的 MBR 啦！(注2) 这样 boot loader 也就能够被执行啰！
			Boot Loader 的功能
				刚刚说到 Loader 的最主要功能是要认识操作系统的文件格式并据以加载核心到主存储器中去执行。 由于不同操作系统的文件格式不一致，因此每种操作系统都有自己的 boot loader 啦！用自己的 loader 才有办法载入核心档案嘛！那问题就来啦，你应该有听说过多重操作系统吧？也就是在一部主机上面安装多种不同的操作系统。 既然你 (1)必须要使用自己的 loader 才能够加载属亍自己的操作系统核心，而 (2)系统的 MBR 只有一个，那你怎么会有办法同时在一部主机上面安装 Windows 与 Linux 呢？
				其实每个文件系统 (filesystem, 或者是 partition) 都会保留一块启动扇区 (boot sector) 提供操作系统安装 boot loader ， 而通常操作系统默认都会安装一份 loader 到他根目录所在的文件系统的 boot sector 上。如果我们在一部主机上面安装 Windows 与 Linux 后，该 boot sector, boot loader 与 MBR 的相关性会有点像下图：
				如上图所示，每个操作系统默认是会安装一套 boot loader 到他自己的文件系统中 (就是每个 filesystem 左下方的方框)，而在 Linux 系统安装时，你可以选择将 boot loader 安装到 MBR 去，也可以选择不安装。 如果选择安装到 MBR 的话，那理论上你在 MBR 与 boot sector 都会保有一份 boot loader 程序的。 至于 Windows 安装时，他预设会主动的将 MBR 与 boot sector 都装上一份 boot loader！所以啦， 你会发现安装多重操作系统时，你的 MBR 常常会被不同的操作系统的 boot loader 所覆盖啦！
				虽然各个操作系统都可以安装一份 boot loader 到他们的 boot sector 中， 这样操作系统可以透过自己的 boot loader 来加载核心了。问题是系统的 MBR 只有一个哩！ 你要怎么执行 boot sector 里面的 loader 啊？这个我们得要回忆一下第三章约略提过的 boot loader 的功能了。boot loader 主要的功能如下：
					提供选单：用户可以选择不同的开机项目，这也是多重引导的重要功能！
					载入核心档案：直接指向可开机的程序区段来开始操作系统；
					转交其他 loader：将开机管理功能转交给其他 loader 负责。
				由于具有选单功能，因此我们可以选择不同的核心来开机。而由于具有控制权转交的功能，因此我们可以加载其他 boot sector 内的 loader 啦！不过 Windows 的 loader 预设不具有控制权转交的功能，因此你不能使用 Windows 的 loader 来加载 Linux 的 loader 喔！这也是为啥第三章谈到 MBR 与多重引导时，会特别强调先装 Windows 再装 Linux 的缘故。
			加载核心侦测硬件与 initrd 的功能
				当我们藉由 boot loader 的管理而开始读取核心档案后，接下来， Linux 就会将核心解压缩到主存储器当中， 并且利用核心的功能，开始测试与驱动各个周边装置，包括储存装置、CPU、网络卡、声卡等等。 此时 Linux 核心会以自己的功能重新侦测一次硬件，而不一定会使用 BIOS 侦测到的硬件信息喔！也就是说，核心此时才开始接管 BIOS 后的工作了。 那么核心档案在哪里啊？一般来说，他会被放置到 /boot 里面，并且取名为 /boot/vmlinuz 才对！
				[root@www ~]# ls --format=single-column -F /boot 
				config-2.6.18-92.el5 <==此版本核心被编译时选择的功能与模块配置文件 
				grub/ <==就是开机管理程序 grub 相关数据目录 
				initrd-2.6.18-92.el5.img <==虚拟文件系统档！ 
				System.map-2.6.18-92.el5 <==核心功能放置到内存地址的对应表 
				vmlinuz-2.6.18-92.el5 <==就是核心档案啦！最重要者！
				为了硬件开发商与其他核心功能开发者的便利， 因此 Linux 核心是可以透过动态加载核心模块的 (就请想成驱劢程序即可)，这些核心模块就放置在 /lib/modules/ 目录内。 由于模块放置到磁盘根目录内 (要记得 /lib 不可以与 / 分别放在不同的 partition ！)， 因此在开机的过程中核心必须要挂载根目录，这样才能够读取核心模块提供加载驱动程序的功能。 而且为了担心影响到磁盘内的文件系统，因此开机过程中根目录是以只读的方式来挂载的喔。
				一般来说，非必要的功能且可以编译成为模块的核心功能，目前的 Linux distributions 都会将他编译成为模块。 因此 USB, SATA, SCSI... 等磁盘装置的驱动程序通常都是以模块的方式来存在的。 现在来思考一种情况，假设你的 linux 是安装在 SATA 磁盘上面的，你可以透过 BIOS 的 INT 13 取得 boot loader 与 kernel 档案来开机，然后 kernel 会开始接管系统并且侦测硬件及尝试挂载根目录来取得额外的驱动程序。
				问题是，核心根本不认识 SATA 磁盘，所以需要加载 SATA 磁盘的驱动程序， 否则根本就无法挂载根目录。但是 SATA 的驱动程序在 /lib/modules 内，你根本无法挂载根目录又怎么读取到 /lib/modules/ 内的驱动程序？是吧！非常的两难吧！在这个情况之下，你的 Linux 是无法顺利开机的！ 那怎办？没关系，我们可以透过虚拟文件系统来处理这个问题。
				虚拟文件系统 (Initial RAM Disk) 一般使用的档名为 /boot/initrd ，这个档案的特色是，他也能够透过 boot loader 来加载到内存中， 然后这个档案会被解压缩并且在内存当中仿真成一个根目录， 且此仿真在内存当中的文件系统能够提供一支可执行的程序，透过该程序来加载开机过程中所最需要的核心模块， 通常这些模块就是 USB, RAID, LVM, SCSI 等文件系统与磁盘接口的驱动程序啦！等载入完成后， 会帮助核心重新呼叫 /sbin/init 来开始后续的正常开机流程。
				如上图所示，boot loader 可以加载 kernel 与 initrd ，然后在内存中让 initrd 解压缩成为根目录， kernel 就能够藉此加载适当的驱动程序，最终释放虚拟文件系统，并挂载实际的根目录文件系统， 就能够开始后续的正常开机流程。更详细的 initrd 说明，你可以自行使用 man initrd 去查阅看看。 底下让我们来了解一下 CentOS 5.x 的 initrd 档案内容有什么吧！ ^_^
					# 1. 先将 /boot/initrd 复制到 /tmp/initrd 目录中，等待解压缩： 
						[root@www ~]# mkdir /tmp/initrd 
						[root@www ~]# cp /boot/initrd-2.6.18-92.el5.img /tmp/initrd/ 
						[root@www ~]# cd /tmp/initrd 
						[root@www initrd]# file initrd-2.6.18-92.el5.img initrd-2.6.18-92.el5.img: gzip compressed data, ... # 原来是 gzip 的压缩文件！因为是 gzip ，所以扩展名给他改成 .gz 吧！ 
					# 2. 将上述的档案解压缩： 
						[root@www initrd]# mv initrd-2.6.18-92.el5.img initrd-2.6.18-92.el5.gz 
						[root@www initrd]# gzip -d initrd-2.6.18-92.el5.gz 
						[root@www initrd]# file initrd-2.6.18-92.el5 initrd-2.6.18-92.el5: ASCII cpio archive (SVR4 with no CRC) # 搞了老半天，原来还是 cpio 的指令压缩成的档案啊！解压缩看看！ 
					# 3. 用 cpio 解压缩 
						[root@www initrd]# cpio -ivcdu < initrd-2.6.18-92.el5 
						[root@www initrd]# ll 
						drwx------ 2 root root 4096 Apr 10 02:05 bin 
						drwx------ 3 root root 4096 Apr 10 02:05 dev 
						drwx------ 2 root root 4096 Apr 10 02:05 etc 
						-rwx------ 1 root root 1888 Apr 10 02:05 init 
						-rw------- 1 root root 5408768 Apr 10 02:00 initrd-2.6.18-92.el5 
						drwx------ 3 root root 4096 Apr 10 02:05 lib 
						drwx------ 2 root root 4096 Apr 10 02:05 proc 
						lrwxrwxrwx 1 root root 3 Apr 10 02:05 sbin -> bin 
						drwx------ 2 root root 4096 Apr 10 02:05 sys 
						drwx------ 2 root root 4096 Apr 10 02:05 sysroot
					# 看！是否很像根目录！尤其也是有 init 这个执行档！务必看一下权限！ # 接下来看看 init 这个档案内有啥咚咚？ 
					# 4. 观察 init 档案内较重要的执行项目 
						[root@www initrd]# cat init #!/bin/nash <==使用类似 bash 的 shell 来执行 
						mount -t proc /proc /proc <==挂载内存的虚拟文件系统 
						....(中间省略).... 
						echo Creating initial device nodes 
						mknod /dev/null c 1 3 <==建立系统所需要的各项装置！ 
						....(中间省略).... 
						echo "Loading ehci-hcd.ko module" 
						insmod /lib/ehci-hcd.ko <==加载各项核心模块，就是驱动程序！ 
						....(中间省略).... 
						echo Creating root device. 
						mkrootdev -t ext3 -o defaults,ro hdc2 <==尝试挂载根目录啦！ 
						....(底下省略)....
				例题： 是否没有 initrd 就无法顺利开机？ 
					答： 不见得的！需要 initrd 最重要的原因是，当开机时无法挂载根目录的情况下， 此时就一定需要 initrd ，例如你的根目录在特殊的磁盘接口 (USB, SATA, SCSI) ， 或者是你的文件系统较为特殊 (LVM, RAID) 等等，才会需要 initrd。 如果你的 Linux 是安装在 IDE 接口的磁盘上，并且使用默认的 ext2/ext3 文件系统， 那么不需要 initrd 也能够顺利的开机进入 Linux 的！
		第一支程序 init 及配置文件 /etc/inittab 与 runlevel
			在核心加载完毕、进行完硬件侦测与驱动程序加载后，此时你的主机硬件应该已经准备就绪了 (ready) ， 此时核心会主动的呼叨第一支程序，那就是 /sbin/init 啰。/sbin/init 最主要的功能就是准备软件执行的环境，包括系统的主机名、网络设定、语系处理、文件系统格式及其他服务的启动等。 而所有的动作都会透过 init 的配置文件，亦即是 /etc/inittab 来规划，而 inittab 内还有一个很重要的设定项目，那就是默认的 runlevel (开机执行等级) 啦！
			Run level：执行等级有哪些？
				Linux 就是藉由设定 run level 来规定系统使用不同的服务来启动，让 Linux 的使用环境不同。基本上，依据有无网络与有无 X Window 而将 run level 分为 7 个等级，分别是：
					0 - halt (系统直接关机)
					1 - single user mode (单人维护模式，用在系统出问题时的维护)
					2 - Multi-user, without NFS (类似底下的 runlevel 3，但无 NFS 服务)
					3 - Full multi-user mode (完整含有网络功能的纯文本模式)
					4 - unused (系统保留功能)
					5 - X11 (与 runlevel 3 类似，但加载使用 X Window)
					6 - reboot (重新启动)
			/etc/inittab 的内容与语法
				首先，这个档案的语法是利用冒号 (:) 将设定分隔成为四个字段，每个字段的意义与说明如下：
					[设定项目]:[run level]:[init 的动作行为]:[指令项目]
					1. 设定项目：最多四个字符，代表 init 的主要工作项目，只是一个简单的代表说明。
					2. run level：该项目在哪些 run level 底下进行的意思。如果是 35 则代表 runlevel 3 与 5 都会执行。
					3. init 的动作项目：主要可以进行的动作项目意义有： 
						inittab 设定值 		意义说明 
						initdefault 		代表预设的 run level 设定值 
						sysinit 			代表系统初始化的动作项目 
						ctrlaltdel 			代表 [ctrl]+[alt]+[del] 三个按键是否可以重新启动的设定 
						wait 				代表后面字段设定的指令项目必须要执行完毕才能继续底下其他的动作 
						respawn 			代表后面字段的指令可以无限制的再生 (重新启动)。举例来说， tty1 的 mingetty 产生的可登入画面， 在你注销而结束后，系统会再开一个新的可登入画面等待下一个登入。
					4. 更多的设定项目请参考 man inittab 的说明。
					5. 指令项目：亦即应该可以进行的指令，通常是一些 script 啰。
			init 的处理流程
				事实上 /etc/inittab 的设定也有点类似 shell script 啦，因为该档案内容的设定也是一行一行的从上往下处理的， 因此我们可以知道 CentOS 的 init 依据 inittab 设定的处理流程会是：
					1. 先取得 runlevel 亦即默认执行等级的相关等级 (以鸟哥的测试机为例，为 5 号)；
					2. 使用 /etc/rc.d/rc.sysinit 进行系统初始化
					3. 由于 runlevel 是 5 ，因此只进行『l5:5:wait:/etc/rc.d/rc 5』，其他行则略过
					4. 设定好 [ctrl]+[alt]+[del] 这组的组合键功能
					5. 设定不断电系统的 pf, pr 两种机制；
					6. 启动 mingetty 的六个终端机 (tty1 ~ tty6)
					7. 最终以 /etc/X11/perfdm -nodaemon 启动图形接口啦！
				这个 run level 1 有点像是 Windows 系统当中的『安全模式』啦， 专门用来处理当系统有问题时的操作环境。此外，当系统发现有问题时，举例来说，不正常关机造成 filesystem 的不一致现象时，系统会主动的进入单人维护模式呢！
		init 处理系统初始化流程 (/etc/rc.d/rc.sysinit)
			还记得上面提到 /etc/inittab 里头有这一句『 si::sysinit:/etc/rc.d/rc.sysinit 』吧？ 这表示：『我开始加载各项系统服务之前，得先做好整个系统环境，我主要利用 /etc/rc.d/rc.sysinit 这个 shell script 来设定好我的系统环境的。』
			如果你使用 vim 去查阅过 /etc/rc.d/rc.sysinit 的话，那么可以发现他主要的工作大抵有这几项：
				1. 取得网络环境与主机类型： 读取网络配置文件 /etc/sysconfig/network ，取得主机名与默认通讯闸 (gateway) 等网络环境。
				2. 测试与挂载内存装置 /proc 及 USB 装置 /sys： 除挂载内存装置 /proc 之外，还会主动侦测系统上是否具有 usb 的装置， 若有则会主动加载 usb 的驱动程序，并且尝试挂载 usb 的文件系统。
				3. 决定是否启动 SELinux ： 我们在第十七章谈到的 SELinux 在此时进行一些检测， 并且检测是否需要帮所有的档案重新编写标准的 SELinux 类型 (auto relabel)。
				4. 启动系统的随机数生成器 随机数生成器可以帮助系统进行一些密码加密演算的功能，在此需要启动两次随机数生成器。
				5. 设定终端机 (console) 字形：
				6. 设定显示于开机过程中的欢迎画面 (text banner)；
				7. 设定系统时间 (clock) 与时区设定：需读入 /etc/sysconfig/clock 设定值
				8. 接口设备的侦测与 Plug and Play (PnP) 参数的测试： 根据核心在开机时侦测的结果 (/proc/sys/kernel/modprobe ) 开始进行 ide / scsi / 网络 / 音效 等接口设备的侦测，以及利用以加载的核心模块进行 PnP 装置的参数测试。
				9. 用户自定义模块的加载 使用者可以在 /etc/sysconfig/modules/*.modules 加入自定义的模块，则此时会被加载到系统当中
				10.加载核心的相关设定： 系统会主动去读取 /etc/sysctl.conf 这个档案的设定值，使核心功能成为我们想要的样子。
				11.设定主机名与初始化电源管理模块 (ACPI)
				12.初始化软件磁盘阵列：主要是透过 /etc/mdadm.conf 来设定好的。
				13.初始化 LVM 的文件系统功能
				14.以 fsck 检验磁盘文件系统：会进行 filesystem check
				15.进行磁盘配额 quota 的转换 (非必要)：
				16.重新以可擦写模式挂载系统磁盘：
				17.启动 quota 功能：所以我们不需要自定义 quotaon 的动作
				18.启动系统虚拟随机数生成器 (pseudo-random)：
				19.清除开机过程当中的临时文件：
				20.将开机相关信息加载 /var/log/dmesg 档案中。
			在 /etc/rc.d/rc.sysinit 将基本的系统设定数据都写好了，也将系统的数据设定完整！ 而如果你想要知道到底开机的过程中发生了什么事情呢？那么就执行『 dmesg 』吧。 另外，基本上，在这个档案当中所进行的很多工作的预设配置文件，其实都在 /etc/sysconfig/ 当中呢！ 所以，请记得将 /etc/sysconfig/ 内的档案好好的瞧一瞧喔！ ^
			在 CentOS 当中，如果我们想要加载核心模块的话， 可以将整个模块写入到 /etc/sysconfig/modules/*.modules 当中，在该目录下， 只要记得档名最后是以 .modules 结尾即可。
		启动系统服务与相关启动配置文件 (/etc/rc.d/rc N & /etc/sysconfig)
			依据我们在 /etc/inittab 里面提到的 run level 设定值，就可以来决定启动的服务项目了。
			那么各个不同的 run level 服务启动的各个 shell script 放在哪？还记得 /etc/inittab 里面提到的： 
				l0:0:wait:/etc/rc.d/rc 0 
				l1:1:wait:/etc/rc.d/rc 1 
				l2:2:wait:/etc/rc.d/rc 2 
				l3:3:wait:/etc/rc.d/rc 3 
				l4:4:wait:/etc/rc.d/rc 4 
				l5:5:wait:/etc/rc.d/rc 5 <==本例中，以此项目来解释 
				l6:6:wait:/etc/rc.d/rc 6
				上面提到的就是各个 run level 要执行的各项脚本放置处啦！主要是透过 /etc/rc.d/rc 这个指令来处理相关认务！ 由于鸟哥使用预设的 runlevel 5 ，因此我们主要针对上述特殊字体那行来解释好了： /etc/rc.d/rc 5 的意义是这样的 (建议您自行使用 vim 去观察一下 /etc/rc.d/rc 这个档案，你会更有概念！)：
					透过外部第一号参数 ($1) 来取得想要执行的脚本目录。亦即由 /etc/rc.d/rc 5 可以取得 /etc/rc5.d/ 这个目录来准备处理相关的脚本程序；
					找到 /etc/rc5.d/K??* 开头的档案，并进行『 /etc/rc5.d/K??* stop 』的动作；
					找到 /etc/rc5.d/S??* 开头的档案，并进行『 /etc/rc5.d/S??* start 』的动作；
			透过上面的说明我们可以知道所有的项目都与 /etc/rc5.d/ 有关，那么我们就来瞧瞧这个目录下有些什么玩意儿吧！
			在这个目录下的档案很有趣，主要具有几个特点：
				檔名全部以 Sxx 戒 Kxx ，其中 xx 为数字，且这些数字在档案之间是有相关性的！
				全部是连结档，连结到 stand alone 服务启动的目录 /etc/init.d/ 去
			我们在第十八章谈过服务的启动主要是以『/etc/init.d/服务档名 {start,stop}』来启动与关闭的，那么透过刚刚 /etc/rc.d/rc 程序的解说，我们可以清楚的了解到了 /etc/rc5.d/[SK]xx 其实就是跑到 /etc/init.d/ 去找到相对应的服务脚本， 然后分别进行 start (Sxx) 或 stop (Kxx) 的动作而已啦！举例来说，以上述的表格内的 K91capi 及 S10network 为例好了， 透过 /etc/rc.d/rc 5 的执行，这两个档案会这样进行：
				/etc/rc5.d/K91capi stop --> /etc/init.d/capi stop
				/etc/rc5.d/S10network start --> /etc/init.d/network start
			你有想要启劢该 runlevel 时就执行的服务，那么利用 Sxx 并指向 /etc/init.d/ 的特定服务启动脚本后， 该服务就能够在开机时启动啦！就这么简单！问题是，你需要自行处理这个 K, S 开头的连结档吗？ 并不需要的，第十八章谈到的 chkconfig 就是在负责处理这个连结档啦！
			那么为什么 K 与 S 后面要有数字呢？因为各不同的服务其实还是互有关系的。举例来说，如果要启动 WWW 朋务，总是得要有网络吧？所以 /etc/init.d/network 就会比较先被启动啦！那么您就会知道在 S 或者是 K 后面接的数字是啥意思了吧？嘿嘿，那就是执行的顺序啦！
		用户自定义开机启动程序 (/etc/rc.d/rc.local)
			我有任何想要在开机时就进行的工作时，直接将他写入 /etc/rc.d/rc.local ， 那么该工作就会在开机的时候自动被加载喔
		根据 /etc/inittab 之设定，加载终端机或 X-Window 接口
			要注意的是那个 respawn 的 init 动作项目，他代表『当后面的指令被终止 (terminal) 时， init 会主动的重新启动该项目。』这也是为何我们登入 tty1 终端机接口后，以 exit 离开后， 系统还是会重新显示等待用户输入的画面的原因啊！
		开机过程会用到的主要配置文件
			我们在 /sbin/init 的运作过程中有谈到许多执行脚本，包括 /etc/rc.d/rc.sysinit 以及 /etc/rc.d/rc 等等， 其实这些脚本都会使用到相当多的系统配置文件，这些开机过程会用到的配置文件则大多放置在 /etc/sysconfig/ 目录下。 同时，由亍核心还是需要加载一些驱动程序 (核心模块)，此时系统自定义的装置与模块对应文件 (/etc/modprobe.conf) 就显的挺重要了喔！
			关于模块： /etc/modprobe.conf
				这个档案大多在指定系统内的硬件所使用的模块啦！这个档案通常系统是可以自行产生的，所以你不必手动去订正他！ 不过，如果系统捉到错误的驱动程序，或者是你想要使用更新的驱动程序来对应相关的硬件配备时， 你就得要自行手动的处理一下这个档案了。
			/etc/sysconfig/*
				整个开机的过程当中，老是读取的一些服务的相关配置文件都是记录在 /etc/sysconfig目录下的！那么该目录底下有些啥玩意儿？我们找几个重要的档案来谈谈：
					authconfig： 这个档案主要在规范使用者的身份认证的机制，包括是否使用本机的 /etc/passwd, /etc/shadow 等， 以及 /etc/shadow 密码记录使用何种加密算法，还有是否使用外部密码服务器提供的账号验证 (NIS, LDAP) 等。 系统默认使用 MD5 加密算法，并且不使用外部的身份验证机制；
					clock： 此档案在设定 Linux 主机的时区，可以使用格林威治时间(GMT)，也可以使用台湾的本地时间 (local)。基本上，在 clock 档案内的设定项目『 ZONE 』所参考的时区位于 /usr/share/zoneinfo 目录下的相对路径中。而且要修改时区的话，还得将 /usr/share/zoneinfo/Asia/Taipei 这个档案复制成为 /etc/localtime 才行！
					i18n： i18n 在设定一些语系的使用方面，例如最麻烦的文字接口下的日期显示问题！ 如果你是以中文安装的，那么预设语系会被选择 zh_TW.UTF8 ，所以在纯文本接口之下， 你的档案日期显示可能就会呈现乱码！这个时候就需要更改一下这里啦！更动这个 i18n 的档案，将里面的 LC_TIME 改成 en 即可！
					keyboard & mouse： keyboard 与 mouse 就是在设定键盘与鼠标的形式；
					network： network 可以设定是否要启动网络，以及设定主机名还有通讯闸 (GATEWAY) 这两个重要信息呢！
					network-scripts/： 至于 network-scripts 里面的档案，则是主要用在设定网络卡～ 
			Run level 的切换
				依据开机是否自动进入不同 run level 设讴定，我们可以说：
					1. 要每次开机都执行某个预设的 run level ，则需要修改 /etc/inittab 内的设定项目， 亦即是『 id:5:initdefault: 』里头的数字啊；
					2. 如果仅只是暂时变更系统的 run level 时，则使用 init [0-6] 来进行 run level 的变更。 但下次重新启动时，依旧会是以 /etc/inittab 的设定为准。
				假设原本我们是以 run level 5 登入系统的，但是因为某些因素，想要切换成为 run level 3 时， 该怎么办呢？很简单啊，执行『 init 3 』即可切换。但是 init 3 这个动作到底做了什么呢？ 我们不是说了吗？事实上，不同的 run level 只是加载的服务不同罢了， 亦即是 /etc/rc5.d/ 还有 /etc/rc3.d 内的 Sxxname 与 Kxxname 有差异而已。 所以说，当执行 init 3 时，系统会：
					先比对 /etc/rc3.d/ 及 /etc/rc5.d 内的 K 与 S 开头的档案；
					在新的 runlevel 亦即是 /etc/rc3.d/ 内有多的 K 开头档案，则予以关闭；
					在新的 runlevel 亦即是 /etc/rc3.d/ 内有多的 S 开头档案，则予以启动；
	核心与核心模块
		在整个开机的过程当中，是否能够成功的驱动我们主机的硬件配备， 是核心 (kernel) 的工作！而核心一般都是压缩文件，因此在使用核心之前，就得要将他解压缩后， 才能加载主存储器当中。
		那么核心与核心模块放在哪？
			核心： /boot/vmlinuz 或 /boot/vmlinuz-version；
			核心解压缩所需 RAM Disk： /boot/initrd (/boot/initrd-version)；
			核心模块： /lib/modules/version/kernel 或 /lib/modules/$(uname -r)/kernel；
			核心原始码： /usr/src/linux (要安装才会有！否则预设不安装的！)
		如果该核心被顺利的加载系统当中了，那么就会有几个信息记录下来：
			核心版本： /proc/version
			系统核心功能： /proc/sys/kernel
		如果我有个新的硬件，偏偏我的操作系统不支持，该怎么办？很简单啊！
			重新编译核心，并加入最新的硬件驱动程序原始码；
			将该硬件的驱动程序编译成为模块，在开机时加载该模块
		核心模块与相依性
			基本上，核心模块的放置处是在 /lib/modules/$(uname -r)/kernel 当中，里面主要还分成几个目录：
				arch ：与硬件平台有关的项目，例如 CPU 的等级等等； 
				crypto ：核心所支持的加密的技术，例如 md5 或者是 des 等等； 
				drivers ：一些硬件的驱动程序，例如显示适配器、网络卡、PCI 相关硬件等等； 
				fs ：核心所支持的 filesystems ，例如 vfat, reiserfs, nfs 等等； 
				lib ：一些函式库； 
				net ：与网络有关的各项协议数据，还有防火墙模块 (net/ipv4/netfilter/*) 等等； 
				sound ：与音效有关的各项模块；
			/lib/modules/$(uname -r)/modules.dep 这个档案,他记录了在核心支持的模块的各项相依性。
			利用 depmod 这个指令就可以达到建立该档案的需求了！
				[root@www ~]# depmod [-Ane] 
				选项与参数： 
					-A ：不加任何参数时， depmod 会主动的去分析目前核心的模块，并且重新写入 /lib/modules/$(uname -r)/modules.dep 当中。若加入 -A 参数时，则 depmod 会去搜寻比 modules.dep 内还要新的模块，如果真找到新模块，才会更新。 
					-n ：不写入 modules.dep ，而是将结果输出到屏幕上(standard out)； 
					-e ：显示出目前已加载的不可执行的模块名称
		核心模块的观察
			利用 lsmod来查看目前核心加载了多少的模块
				[root@www ~]# lsmod
				使用 lsmod 之后，系统会显示出目前已经存在于核心当中的模块，显示的内容包括有：
					模块名称(Module)；
					模块的大小(size)；
					此模块是否被其他模块所使用 (Used by)。
			查阅每个模块的信息
				[root@www ~]# modinfo [-adln] [module_name|filename] 
				选项与参数： 
				-a ：仅列出作者名称； 
				-d ：仅列出该 modules 的说明 (description)； 
				-l ：仅列出授权 (license)； -n ：仅列出该模块的详细路径。
				事实上，这个 modinfo 除了可以『查阅在核心内的模块』之外，还可以检查『某个模块档案』， 因此，如果你想要知道某个档案代表的意义为何，利用 modinfo 加上完整檔名吧！
		核心模块的加载与移除
			最简单而且建议的，是使用 modprobe 这个指令来加载模块， 这是因为 modprobe 会主动的去搜寻 modules.dep 的内容，先克服了模块的相依性后， 才决定需要加载的模块有哪些，很方便。至于 insmod 则完全由使用者自行加载一个完整文件名的模块， 并不会主动的分析模块相依性啊！
				[root@www ~]# insmod [/full/path/module_name] [parameters]
				[root@www ~]# rmmod [-fw] module_name 
				选项与参数： 
					-f ：强制将该模块移除掉，不论是否正被使用； 
					-w ：若该模块正被使用，则 rmmod 会等待该模块被使用完毕后，才移除他！
			使用 insmod 与 rmmod 的问题就是，你必须要自行找到模块的完整文件名才行，而且如同上述范例二的结果， 万一模块有相依属性的问题时，你将无法直接加载或移除该模块呢！所以近年来我们都建议直接使用 modprobe 来处理模块加载的问题，这个指令的用法是：
				[root@www ~]# modprobe [-lcfr] module_name 
				选项与参数： 
					-c ：列出目前系统所有的模块！(更详细的代号对应表) 
					-l ：列出目前在 /lib/modules/`uname -r`/kernel 当中的所有模块完整文件名； 
					-f ：强制加载该模块； 
					-r ：类似 rmmod ，就是移除某个模块啰～
		核心模块的额外参数设定： /etc/modprobe.conf
			如果您想要修改某些模块的额外参数设定， 就在这个档案内设定吧
	Boot Loader: Grub
		boot loader 是载入核心的重要工具
		boot loader 的两个 stage
			在 BIOS 读完信息后，接下来就是会到第一个开机装置的 MBR 去读取 boot loader 了。这个 boot loader 可以具有选单功能、直接加载核心档案以及控制权移交的功能等， 系统必须要有 loader 才有办法加载该操作系统的核心就是了。但是我们都知道， MBR 是整个硬盘的第一个 sector 内的一个区块，充其量整个大小也扄 446 bytes 而已。 我们的 loader 功能这么强，光是程序代码与设定数据不可能只占不到 446 bytes 的容量吧？那如何安装？
			为了解决这个问题，所以 Linux 将 boot loader 的程序代码执行与设定值加载分成两个阶段 (stage) 来执行：
				Stage 1：执行 boot loader 主程序：
					第一阶段为执行 boot loader 的主程序，这个主程序必须要被安装在开机区，亦即是 MBR 或者是 boot sector 。但如前所述，因为 MBR 实在太小了，所以，MBR 或 boot sector 通常仅安装 boot loader 的最小主程序， 并没有安装 loader 的相关配置文件；
				Stage 2：主程序加载配置文件： 第二阶段为透过 boot loader 加载所有配置文件与相关的环境参数档案 (包括文件系统定义与主要配置文件 menu.lst)， 一般来说，配置文件都在 /boot 底下。
					那么这些配置文件是放在哪里啊？这些与 grub 有关的档案都放置到 /boot/grub 中.从上面的说明你可以知道 /boot/grub/ 目录下最重要的就是配置文件 (menu.lst) 以及各种文件系统的定义！ 我们的 loader 读取了这种文件系统定义数据后，就能够认识文件系统并读取在该文件系统内的核心档案啰。
		grub 的配置文件 /boot/grub/menu.lst 与选单类型
			grub 的优点挺多的，包括有：
				认识与支持较多的文件系统，并且可以使用 grub 的主程序直接在文件系统中搜寻核心档名；
				开机的时候，可以『自行编辑与修改开机设定项目』，类似 bash 的指令模式；
				可以动态搜寻配置文件，而不需要在修改配置文件后重新安装 grub 。亦即是我们只要修改完 /boot/grub/menu.lst 里头的设定后，下次开机就生效了！
			硬盘与分割槽在 grub 中的代号
				安装在 MBR 的 grub 主程序，最重要的任务之一就是从磁盘当中加载核心档案， 以让核心能够顺利的驱动整个系统的硬件。所以啰， grub 必须要认识硬盘才行啊！那么 grub 到底是如何认识硬盘的呢？ 嘿嘿！ grub 对硬盘的代号设定与传统的 Linux 磁盘代号可完全是不同的！grub 对硬盘的识别使用的是如下的代号： (hd0,0)
				其实叧要注意几个东西即可，那就是：
					硬盘代号以小括号 ( ) 包起来；
					硬盘以 hd 表示，后面会接一组数字；
					以『搜寻顺序』做为硬盘的编号，而不是依照硬盘扁平电缆的排序！(这个重要！)
					第一个搜寻到的硬盘为 0 号，第二个为 1 号，以此类推；
					每颗硬盘的第一个 partition 代号为 0 ，依序类推。
			/boot/grub/menu.lst 配置文件：
				[root@www ~]# vim /boot/grub/menu.lst 
				default=0 <==默认开机选项，使用第 1 个开机选单 (title) 
				timeout=5 <==若 5 秒内未动键盘，使用默认选单开机 
				splashimage=(hd0,0)/grub/splash.xpm.gz <==背景图示所在的档案
				hiddenmenu <==读秒期间是否显示出完整的选单画面(预设隐藏) 
				title CentOS (2.6.18-92.el5) <==第一个选单的内容 root (hd0,0) 
				kernel /vmlinuz-2.6.18-92.el5 ro root=LABEL=/1 rhgb quiet 
				initrd /initrd-2.6.18-92.el5.img
				在 title 以前的四行，都是属于 grub 的整体设定，包括预设的等待时间与默认的开机项目， 还有显示的画面特性等等。至于 title 后面才是指定开机的核心档案或者是 boot loader 控制权。 在整体设定方面的项目主要常见的有：
					default=0
						这个必须要与 title 作为对照，在配置文件里面有几个 title ，开机的时候就会有几个选单可以选择
					timeout=5
						如果 timeout=0 代表直接使用 default 值进行开机而不读秒，timeout=-1 则代表直接进入选单不读秒了！
					splashimage=(hd0,0)/grub/splash.xpm.gz
						有没有发现你的 CentOS 在开机的时候背景不是黑白而是有色彩变化的呢？那就是这个档案提供的背景图示啦(注3)！不过这个档案的实际路径写法怎么会是这样啊？很简单啊～上述的意思是：在 (hd0,0) 这个分割槽内的最顶层目录中，底下的 grub/splash.xpm.gz 那个档案的意思。 由于鸟哥将 /boot 这个目录独立成为 /dev/hda1 ，因此这边就会写成『在 /dev/hda1 里面的 grub/splash.xpm.gz 』的意思啦
					hiddenmenu
						这个说的是，开机时是否要显示选单？目前 CentOS 默认是不要显示选单， 如果您想要显示选单，那就将这个设定值批注掉！
				开机时可以选择 (1)直接指定核心档案开机或 (2)将 boot loader 控制权转移到下个 loader (此过程称为 chain-loader)
					直接指定核心开机
						既然要指定核心开机，所以当然要找到核心档案啦！此外，有可能还需要用到 initrd 的 RAM Disk 配置文件。但是如前说的， 尚未开机完成，所以我们必须要以 grub 的硬盘识别方式找出完整的 kernel 与 initrd 檔名才行。 因此，我们可能需要有底下的方式来设定才行！ 
							1. 先指定核心档案放置的 partition，再读取档案 (目录树)， 最后才加入档案的实际文件名与路径 (kernel 与 initrd)； 鸟哥的 /boot 为 /dev/hda1 ，因此核心档案的设定则成为： root (hd0,0) <==代表核心档案放在那个 partition 当中 kernel /vmlinuz-2.6.18-92.el5 ro root=LABEL=/1 rhgb quiet initrd /initrd-2.6.18-92.el5.img
								上面的 root, kernel, initrd 后面接的参数的意义说明如下：
									root ：代表的是『核心档案放置的那个 partition 而不是根目录』喔！以鸟哥的案例来说，我的根目录为 /dev/hda2 而 /boot 独立为 /dev/hda1 ，因为与 /boot 有关， 所以磁盘代号就会成为 (hd0,0) 啰。 
									kernel ：至于 kernel 后面接的则是核心的档名，而在档名后面接的则是核心的参数。 由于开机过程中需要挂载根目录，因此 kernel 后面接的那个 root=LABEL=/1 指的是『Linux 的根目录在哪个 partition 』的意思。 还记得第八章谈过的 LABEL 挂载功能吧？ 是的，这里使用 LABEL 来挂载根目录。至于 rhgb 为色彩显示而 quiet 则是安静模式 (屏幕不会输出核心侦测的信息)。 
									initrd ：就是前面提到的 initrd 制作出 RAM Disk 的档案档名啦！
							2. 直接指定 partition 与档名，不需要额外指定核心档案所在装置代号 
								kernel (hd0,0)/vmlinuz-2.6.18-92.el5 ro root=LABEL=/1 rhgb quiet initrd (hd0,0)/initrd-2.6.18-92.el5.img
					利用 chain loader 的方式转交控制权
						所谓的 chain loader (开机管理程序的链结) 仅是在将控制权交给下一个 boot loader 而已， 所以 grub 并不需要认识与找出 kernel 的檔名 ，『 他只是将 boot 的控制权交给下一个 boot sector 或 MBR 内的 boot loader 而已 』 所以通常他也不需要去查验下一个 boot loader 的文件系统！
						一般来说， chain loader 的设定只要两个就够了，一个是预计要前往的 boot sector 所在的分割槽代号， 另一个则是设定 chainloader 在那个分割槽的 boot sector (第一个扇区) 上！假设我的 Windows 分割槽在 /dev/hda1 ，且我又只有一颗硬盘，那么要 grub 将控制权交给 windows 的 loader 只要这样就够了： 
							[root@www ~]# vi /boot/grub/menu.lst 
							....前略.... 
							title Windows partition 
							root (hd0,0) <==设定使用此分割槽 
							chainloader +1 <== +1 可以想成第一个扇区，亦即是 boot sector
						上面的范例中，我们可以很简单的这样想：那个 (hd0,0) 就是 Windows 的 C 槽所在磁盘， 而 chainloader +1 就是让系统加载该分割槽当中的第一个扇区 (就是 boot sector) 内的开机管理程序。 
						不过，由于 Windows 的开机碟需要设定为活化 (active) 状态，且我们的 grub 预设会去检验该分割槽的文件系统。 因此我们可以重新将上面的范例改写成这样： 
							[root@www ~]# vi /boot/grub/menu.lst 
							....前略.... 
							title Windows partition 
							rootnoverify (hd0,0) <==不检验此分割槽 
							chainloader +1 
							makeactive <==设定此分割槽为开机碟(active)
						grub 的功能还不止此，他还能够隐藏某些分割槽。举例来说，我的 /dev/hda5 是安装 Linux 的分割槽， 我不想让 Windows 能够认识这个分割槽时，你可以这样做： 
							[root@www ~]# vi /boot/grub/menu.lst 
							....前略.... 
							title Windows partition 
							hide (hd0,4) <==隐藏 (hd0,4) 这个分割槽 
							rootnoverify (hd0,0) 
							chainloader +1 
							makeactive
		initrd 的重要性与建立新 initrd 档案
			我们在本章稍早之前『 boot loader 与 kernel 载入』的地方已经提到过 initrd 这玩意儿，他的目的在于提供开机过程中所需要的最重要核心模块，以让系统开机过程可以顺利完成。 会需要 initrd 的原因，是因为核心模块放置于 /lib/modules/$(uname -r)/kernel/ 当中， 这些模块必须要根目录 (/) 被挂载时才能够被读取。但是如果核心本身不具备磁盘的驱动程序时， 当然无法挂载根目录，也就没有办法取得驱动程序，因此造成两难的地步。
			initrd 可以将 /lib/modules/.... 内的『开机过程当中一定需要的模块』包成一个档案 (檔名就是 initrd)， 然后在开机时透过主机的 INT 13 硬件功能将该档案读出来觋压缩，幵丏 initrd 在内存内会仿真成为根目录， 由于此虚拟文件系统 (Initial RAM Disk) 主要包含磁盘与文件系统的模块，因此我们的核心最后就能够认识实际的磁盘， 那就能够进行实际根目录的挂载啦！所以说：『initrd 内所包含的模块大多是与开机过程有关，而主要以文件系统及硬盘模块 (如 usb, SCSI 等) 为主』的啦！
			如果妳有特殊需要所以想重制 initrd 档案的话， 可以使用 mkinitrd 来处理的:
				[root@www ~]# mkinitrd [-v] [--with=模块名称] initrd文件名 核心版本 
				选项与参数： 
					-v ：显示 mkinitrd 的运作过程 
					--with=模块名称：模块名称指的是模块的名字而已，不需要填写档名。
						举例来说， 目前核心版本的 ext3 文件系统模块为底下的文件名： /lib/modules/$(uname -r)/kernel/fs/ext3/ext3.ko 那你应该要写成： --with=ext3 就好了 (省略 .ko) initrd檔名：你所要建立的 
					initrd 档名，尽量取有意义又好记的名字。 
					核心版本 ：某一个核心的版本，如果是目前的核心则是『 $(uname -r) 』
		测试与安装 grub
			如果你的 Linux 主机本来就是使用 grub 作为 loader 的话，那么你就不需要重新安装 grub 了， 因为 grub 本来就会主动去读取配置文件啊！您说是吧！但如果你的 Linux 原来使用的并非 grub ， 那么就需要来安装啦！如何安装呢？首先，你必须要使用 grub-install 将一些必要的档案复制到 /boot/grub 里面去，你应该这样做的：
				[root@www ~]# grub-install [--root-directory=DIR] INSTALL_DEVICE 
				选项与参数： 
					--root-directory=DIR 那个 DIR 为实际的目录，使用 grub-install 默认会将 grub 所有的档案都复制到 /boot/grub/* ，如果想要复制到其他目录与装置去， 就得要用这个参数。 INSTALL_DEVICE 安装的装置代号啦！
			安装些什么呢？因为 boot loader 有两个 stage ，而配置文件得要放置到适当的地方。 这个 grub-install 就是在安装配置文件 (包括文件系统定义档与 menu.lst 等等) 而已！ 如果要将 grub 的 stage1 主程序安装起来，就得要使用 grub shell 的功能喔！
			grub-install 是安装 grub 相关的档案 (例如文件系统定义档) 到你的装置上面去等待在开机时被读取，但还需要设定好配置文件 (menu.lst) 后，再以 grub shell 来安装 grub 主程序到 MBR 或者是 boot sector 上面去喔！
			我们已经将配置文件处理完毕，但是你要知道的是，我们并不知道 /dev/hda1 到底有没有包含 grub 的主程序， 因此我们想要将 grub 主程序再次的安装到 /dev/hda1 的 boot sector ，也想要重新安装 grub 到 MBR 上面去。 此时我们就得要使用 grub shell 啰！整个安装与 grub shell 的动作其实很简单， 如果您有兴趣研究的话，可以使用 info grub 去查阅～鸟哥这里仅介绍几个有用的指令而已。
				用『 root (hdx,x) 』选择含有 grub 目录的那个 partition 代号；
				用『 find /boot/grub/stage1 』看看能否找到安装信息档案；
				用『 find /boot/vmlinuz 』看看能否找到 kernel file (不一定要成功！)；
				用『 setup (hdx,x) 』戒『 setup (hdx) 』将 grub 安装在 boot sector 或 MBR；
				用『 quit 』来离开 grub shell ！
			由于我们最需要安装的就是那个 stage1 啦！那才是 grub 的主程序嘛！而且配置文件通常与主程序摆在同一个目录下。 因此我们需要使用 root (hd0,0) 去找到 /boot/grub/stage1 喔！接下来，请用 grub 来进入 grub shell 吧！进入 grub 后，会出现一个『 grub> 』的提示字符啊！
			最后总结一下：
				1. 如果是从其他 boot loader 转成 grub 时，得先使用 grub-install 安装 grub 配置文件；
				2. 开始编辑 menu.lst 这个重要的配置文件；
				3. 透过 grub 来将主程序安装到系统中，如 MBR 的 (hd0) 戒 boot sector 的 (hd0,0) 等等。
		开机前的额外功能修改
			grub 支持在线编修指令喔！这是个很有用的功能！假如刚刚你将 menu.lst 的内容写错了，导致出现无法开机的问题时， 我们可以查阅该 title 选单的内容并加以修改喔
			你还可以使用：
				e：进入 grub shell 的编辑画面；
				o：在游标所在行底下再新增一行；
				d：将游标所在行删除。
			grub 是可以直接使用核心档案来开机的，所以，如果您很清楚的知道你的根目录 (/) 在那个 partition ，而且知道你的核心档案档名 (通常都会有个 /boot/vmlinuz 连结到正确的档名)， 那么直接在grub编辑状态下设定好kernel的信息,按下 [Enter] 按键后，然后输入 b 来 boot ，就可以开机啦！所以说，万一你的 /boot/grub/menu.lst 设定错误，或者是因为安装的缘故，或者是因为核心档案的缘故，导致无法顺利开机时，记得啊，可以在 grub 的选单部分， 使用 grub shell 的方式去查询 (find) 或者是直接指定核心档案，就能够开机啦！
			另外，很多时候我们的 grub 可能会发生错误，导致『连 grub 都无法启动』，那么根本就无法使用 grub 的在线编修功能嘛！怎么办？没关系啊！我们可以利用具有 grub 开机的 CD 来开机， 然后再以 CD 的 grub 的在线编修，嘿嘿！同样可以使用硬盘上面的核心档案来开机啦
		关于核心功能当中的 vga 设定
			事实上，你的 tty1~tty6 除了 80x24 的分辨率外，还能够有其他分辨率的支持喔！但前提之下是你的核心必须支持 FRAMEBUFFER_CONSOLE 这个核心功能选项才行。如何确定有没有支持呢？你可以查阅 /boot/config-2.6.18-92.el5 这个档案，然后这样搜寻： [root@www ~]# grep 'FRAMEBUFFER_CONSOLE' /boot/config-2.6.18-92.el5 CONFIG_FRAMEBUFFER_CONSOLE=y # 这个项目如果出现 y 那就是有支持啦！如果被批注或是 n ，那就是没支持啦！
		BIOS 无法读取大硬盘的问题
			现在你知道问题所在啦！那就是 BIOS 无法读取大容量磁盘内的 kernel 与 initrd 档案。 那如何解决呢？很简单啦！就让 kernel 与 initrd 档案放置在大硬盘的最前头，由于 BIOS 至少可以读到大磁盘的 1024 磁柱内的数据，因此就能够读取核心与虚拟文件系统的档案啰。那如何让 kernel 与 initrd 放置到整颗硬盘的最前面呢？简单的要命吧！就建立 /boot 独立分割槽，并将 /boot 放置到最前面即可
		为个别选单加上密码
			那如何在开机的过程里面提供密码保护呢？首先，你必须要建立密码，而且还需要是加密过后的喔！ 否则人家跑到 /boot/grub/menu.lst 不就可以探查到你的开机密码了？那如何建立加密的密码呢？ 我们可以透过 grub 提供的 md5 编码来处理的，如下所示：
				[root@www ~]# grub-md5-crypt 
				Password: <==输入密码 
				Retype password: <==再输入一次 
				$1$kvlI0/$byrbNgkt/.REKPQdfg287. <==这就是产生的 md5 密码！
				上面产生的最后一行，由 $ 开始到 . 结束的那行，就是你的密码经过 md5 编码过后的咚咚！
			你必须要注意的是：password 这个项目一定要在 title 底下的第一行。 不过，此项功能还是可能被破解的，因为用户可以透过编辑模式 (e) 进入选单，并删除密码字段并按下 b 就能够进行开机流程了！真糟糕！那怎办？只好透过整体的 password (放在所有的 title 之前) ， 然后在 title 底下的第一行设定 lock ，那使用者想要编辑时，也得要输入密码才行啊
	开机过程的问题解决
		忘记 root 密码的解决之道
			其实在 Linux 环境中 root 密码忘记时还是可以救回来的！只要能够进入并且挂载 / ， 然后重新设定一下 root 的密码，就救回来啦！这是因为开机流程中，若强制核心进入 runlevel 1 时， 默认是不需要密码即可取得一个 root 的 shell 来救援的。整个动作有点像这样：
				1. 重新启动！一定要重新启动！怎么重开都没关系；
				2. 在开机进入 grub 选单后， 
					(1)在你要进入的选单上面点 'e' 进入详细设定； 
					(2)将光棒移动到 kernel 上方并点 'e' 进入编辑画面； 
					(3)然后出现如下画面来处理： grub edit> kernel /vmlinuz-2.6.18-92.el5 ro root=LABEL=/ rhgb quiet single
					重点就是那个特殊字体的咚咚啦！按下 [enter] 再按下 b 就能够开机进入单人维护模式了。
				3. 进入单人维护模式后，系统会以 root 的权限直接给你一个 shell ，此时你就能够执行『 passwd 』这个指令来重建 root 的密码啦！然后直接『 init 5 』就可以切换成为 X 窗口接口啰！就是这么简单。
		init 配置文件错误
			前一个 root 密码挽救的方法其实可以用在很多地方，唯一一个无法挽救的情况，那就是 /etc/inittab 这个档案设定错误导致的无法开机！根据开机流程，我们知道 runlevel 0~6 都会读取 /etc/inittab 配置文件， 因此你使用 single mode (runlevel 1) 当然也是要读取 /etc/inittab 来进行开机的。那既然无法进入单人维护模式， 就表示这题无解啰？非也非也，既然预设的 init 无法执行，那我们就告诉核心不要执行 init ，改呼叫 bash 啊！ 可以略过 init 吗？可以的，同样在开机进入 grub 后，同样在 grub edit 的情况下这样做： grub edit> kernel /vmlinuz-2.6.18-92.el5 ro root=LABEL=/ rhgb quiet init=/bin/bash
			因为我们指定了核心呼叫的第一支程序 (init) 变成 /bin/bash，因此 /sbin/init 就不会被执行。 又根据开机流程的说明，我们知道此时虽然可以利用 root 取得 bash 来工作，但此时 (1)除了根目录外，其他的目录都没有被挂载； (2)根目录被挂载成为只读状态。因此我们还需要进行一些动作才行！如下所示：
			鸟哥仅下达两个指令，
				『 mount -o remount,rw / 』用途是将根目录重新挂载成为可擦写，至于『 mount -a 』则是参考 /etc/fstab 的内容重新挂载文件系统！ 此时你又可以开机进行救援的工作了！只是救援完毕后，你得要使用『 reboot 』重新启动一次才行！
		BIOS 磁盘对应的问题 (device.map)
			由于目前硬盘很便宜啊，所以很多朋友就想说：『那我能不能将 Windows 安装在 /dev/hda 而 Linux 安装在 /dev/hdb ， 然后调整 BIOS 的开机装置顺序，如此则两套系统各有各的 loader 安装在个别硬盘的 MBR 当中了！』。 这个想法非常好，如此一来两者就不会互相干扰，因为每颗磁盘的 MBR 个别有不同操作系统的 loader 嘛！ 问题是，grub 对磁盘的装置代号使用的是侦测到的顺序啊！ 也就是说，你调整了 BIOS 磁盘开机顺序后，你的 menu.lst 内的装置代号就可能会对应到错误的磁盘上了！啊！真想哭！ 没关系的，我们可以透过 /boot/grub/device.map 这个档案来写死每个装置对 grub 磁盘代号的对应喔！ 举例来说，鸟哥的这个档案内容如下： [root@www ~]# cat /boot/grub/device.map (fd0) /dev/fd0 (hd0) /dev/hda
			如果你不清楚如何处理的话，也可以利用 grub-install 的功能喔！例如： [root@www ~]# grub-install --recheck /dev/hda1/这样 device.map 就会主动的被更新了
		因文件系统错误而无法开机
			最容易出错的设定而导致无法顺利开机的步骤，通常就是 /etc/fstab 这个档案了，尤其是使用者在实作 Quota 时，最容易写错参数， 又没有经过 mount -a 来测试挂载，就立刻直接重新吪劢，真要命！无法开机成功怎么办？
			看到最后两行，他说可以输入 root 的密码继续加以救援喔！那请输入 root 的密码来取得 bash 并以 mount -o remount,rw / 将根目录挂载成可擦写后，继续处理吧！其实会造成上述画面可能的原因除了 /etc/fstab 编辑错误之外，如果你曾经不正常关机后，也可能导致文件系统不一致 (Inconsistent) 的情况， 也有可能会出现相同的问题啊！如果是扇区错乱的情况，请看到上图中的第二行处， fsck 告知其实是 /dev/md0 出错， 此时你就应该要利用 fsck 去检测 /dev/md0 才是！等到系统发现错误，并且出现『clear [Y/N]』时，输入『 y 』吧！ 
			这个 fsck 的过程可能会很长，而且如果你的 partition 上面的 filesystem 有过多的数据损毁时， 即使 fsck 完成后，可能因为伤到系统槽，导致某些关键系统档案数据的损毁，那么依旧是无法进入 Linux 的。此时，就好就是将系统当中的重要数据复制出来，然后重新安装，并且检验一下， 是否实体硬盘有损伤的现象才好！不过一般来说，不太可能会这样啦～ 通常都是 fsck 处理完毕后，就能够顺利再次进入 Linux 了。
		利用 chroot 切换到另一颗硬盘工作
			这是『 change root directory 』的意思啦！意思就是说，可以暂时将根目录移动到某个目录下， 然后去处理某个问题，最后再离开该 root 而回到原本的系统当中。 举例来说，补习班中心最容易有两三个 Linux 系统在同一个主机上面，假设我的第一个 Linux 无法进入了，那么我可以使用第二个 Linux 开机，然后在第二个 Linux 系统下将第一个 Linux 挂载起来， 最后用 chroot 变换到第一个 Linux ，就能够进入到第一个 Linux 的环境当中去处理工作了。 你同样也可以将你的 Linux 硬盘拔到另一个 Linux 主机上面去，然后用这个 chroot 来切换， 以处理你的硬盘问题啊！那怎么做啊？粉简单啦！
				1. 用尽任何方法，进入一个完整的 Linux 系统 ( run level 3 戒 5 )；
				2. 假设有问题的 Linux 磁盘在 /dev/hdb1 上面，且他整个系统的排列是：
				3. 挂载点 装置文件名
				4. / → /dev/hdb1
				5. /var → /dev/hdb2
				6. /home → /dev/hdb3
					/usr → /dev/hdb5 若如此的话，那么在我目前的这个 Linux 底下，我可以建立一个目录，然后可以这样做： 
					挂载点 装置文件名 
					/chroot/ → /dev/hdb1 
					/chroot/var/ → /dev/hdb2 
					/chroot/home/ → /dev/hdb3 
					/chroot/usr/ → /dev/hdb5
				7. 全部挂载完毕后，再输入『 chroot /chroot 』嘿嘿！你就会发现，怎么根目录 (/) 变成那个 /dev/hdb1 的环境啦
		


第二十一章、系统设定工具(网络与打印机)与硬件侦测
	CentOS 系统设定工具： setup
		系统设定除了使用手动的方式编辑配置文件之外 (例如 /etc/inittab, /etc/fstab 等)，其实在 Red Hat 系统的 RHEL, CentOS 及 Fedora 还有提供一支综合程序来管理的，那就是 setup 这个指令的功能啰！老实说， setup 其实只有在 Red Hat 的系列才有， 在其他的 Linux distributions 并不存在
		使用者身份验证设定
		网络设定项目(手动设定IP与自动取得)
			重新启动网络的方法很简单，这样做即可：
				[root@www ~]# /etc/init.d/network restart 
				Shutting down interface eth0: [ OK ] 
				Shutting down loopback interface: [ OK ] 
				Bringing up loopback interface: [ OK ] 
				Bringing up interface eth0: [ OK ]
		防火墙设定
		键盘形式设定		
		系统服务的启动与否设定
			ntsysv指令
		系统时钟的时区设定
			时区的设定，其实就是找出与 /etc/sysconfig/clock 有关的设定项目而已。实际上，上面图示出现的咚咚，就与 /usr/share/zoneinfo/ 目录内的数据有关而已。
		X 窗口接口分辨率设定
			其实这些设定都是修改 /etc/X11/xorg.conf 这个配置文件啦！
	利用 CUPS 设定 Linux 打印机
		Linux 的打印组件 (打印作业、队列、服务与打印机)
			打印组件
				打印作业：
					例如 Open Office 这类较大型的办公室软件中，可以利用内建的程序产生打印的动作。 也可以使用类似 lpr 这类指令列程序来直接打印某个档案。打印软件产生的打印动作，就是产生一个打印的工作 (job)， 这个打印作业就会进入排队等待 (队列, queue) 的环境中，等待打印服务来进行输出。
				打印队列：
					一般来说，打印队列会以打印机的名字来命名， 让大家知道你的打印作业将要使用哪部打印机输出之故。
				打印服务：
					就是实际负责沟通队列内的打印作业与打印机的服务啦！打印服务其实就是将队列内的打印作业，将她的数据转成打印机讣识的格式后， 直接交给打印机来输出而已。但是打印服务必须要认识与沟通打印机，因此他就得要连上打印机与驱动打印机才行。 目前常见的打印服务有 CUPS 与 LPRng ，不过以 CUPS 为主流啦！
					一般我们说的打印机驱动 程序，其实就是将打印作业的数据转成打印机格式啦！ 而目前常见的打印机格式为使用 Postscript 的打印格式，Linux 预设的 CUPS 本身就支持这种打印格式，因此， 只要你购买的打印机有支持 postscript ，那么安装起来应该是很轻松的才是。我们在上面提到的打印机支持网站中， 里面的驱动程序很多就是 postscript 打印机描述档案 (Postscript Printer Description (注1))
					那万一没有 PPD 档案呢？没关系，我们可以透过打印机制作商提供的其他定义档 (例如 Ghostscript) 来解释打印作业的数据， 让打印机认识该格式后，就能够顺利打印了！这也就是说，其实打印机驱动程序就是将数据转成打印机认识的格式后， 就能够加以输出了。而常见的格式为 Postscript 及 Ghostscript 啰！
					那么这些打印的 PPD 驱动程序档放在哪里呢？其实就放在 /usr/share/cups/model/ 底下啦！
		CUPS 支持的联机模式
			常见的打印机联机分享方式有底下这些：
				socket
				LPD (Line Pritner Daemon)
				IPP (Internet Printing Protocol)
					这是目前比较流行的打印机打印协议，我们的 CUPS 预设也是支持这种协议啊！当启动 IPP 时，打印机会启动 port 631 ，打印的 数据就是透过这个 port 来进行传送的。另外，如果你癿打印机或者 Linux 主机启动了 ipp 之后， 嘿嘿！你可以直接使用浏觅器，输入： ipp://printer_IP/printername，或者是： http:/printer_IP:631 就能够直接在线处理打印机的设定了！
				SMB (Server Message Block)
			CentOS 5.x 预设提供的就是 CUPS 的 IPP 协议喔
			那如果你的打印机是透过线材 (USB/串行端口) 连上主机的呢？那就得要考虑底下的连接接口啰！
				parallel ：平行串行端口啊，就是 25 针那种玩意儿！他是连接到 /dev/lp[0-2] 等装置。 在 CUPS 里面的装置使用格式为： parallel:/dev/lp0；
				USB ：常见的 USB 打印机啊！ CUPS 使用的格式为： usb:/dev/usb/lp0 。
		以 Web 接口控管网络打印机
			在预设的情况底下，要进行浏览器接口的管理动作时，你必须要：
				必须要启动 CUPS 这个服务 (/etc/init.d/cups start)
				具有 root 的权限 (需要 root 的密码来设定)；
				预设仅能在本机 (localhost) 管理，无法使用进程联机连到此 Linux 管理；
			那个 nmap 是个可以扫瞄主机端口的软件 (port scan) ，这个软件其实是黑客软件，他默认并没有安装到 CentOS 上， 但是你可以使用『 yum install nmap 』来安装他
		以 Web 接口控管 USB 本机打印机
			lsusb可以列出USB装置信息
		将 Linux 本机打印机开放成为网络打印机
		手动设定打印机
			几个重要的档案为：
				/etc/cups/printers.conf：打印机的设定值，都写在这个档案中；
				/etc/cups/cupsd.conf：CUPS 的主要配置文件，包括做为服务器之用途的设定。
				/etc/cups/ppd/*.ppd：就是各个打印机的驱动程序 (PPD 配置文件)；
			1. 下载合适的 PPD 驱动程序定义档
				如果你有自己下载自己打印机的驱动程序时，请将你下载的档案放置到 /usr/share/cups/model/ 目录下， 因为后续要操作的指令会到此目录中找寻驱动程序定义文件喔！
			2. 启动 CUPS 以及打印机
			3. 使用 lpadmin 进行打印机的建立与删除
				指令设定/删除打印机的方式就是透过 lpadmin 这个指令啊！这个指令的语法是这样的：
					[root@www ~]# lpadmin [-p 自定义队列名] [-v URI] [-m PPD] [-E] <==建立打印机 
					[root@www ~]# lpadmin [-d 已存在的队列名] <==设定成为默认打印机 
					[root@www ~]# lpadmin [-x 已存在的队列名] <==删除此一打印机队列 
					选项与参数： 
						-p ：后面接的就是打印机的队列名称，这个名称可自定义，但还是定为有意义较佳。 
						-v ：后面接的就是装置的相关位置，常见的装置有： 
							串行端口 ： parallel:/dev/lp0 
							USB ： usb:/dev/usb/lp0 
							网络打印机 ： ipp://192.168.201.253/ 
							提供特殊插槽： socket://192.168.201.253:9100 
						-m ：后面接的通常就是 PPD 的定义档，注意，要放置到 /usr/share/cups/model/ 底下！ 
						-E ：作为可接受 (accept) 此打印作业之意！
					其实这个 lpadmin 指令只是在更新 /etc/cups/ 目录里面的两个数据而已， 一个是 /etc/cups/printers.conf ，这个档案主要是规范了打印机的相关装置、是否接受打印作业、 打印机的队列名称、页面的限制等等，反正就是整个打印机的规范就是了。 至于这个打印机相关的 PPD 档案则是以打印机的队列名称链接到 /etc/cups/ppd/ 目录下。
			4. 打印机状态的观察
				[root@www ~]# lpstat [-adprt] 
				选项与参数： 
					-a ：列出目前可以接受打印作业的打印机队列名称； 
					-d ：列出目前系统的默认打印机 (未指定打印队列时，默认输出的打印机)； 
					-p ：列出每部打印机目前的工作状态，包含工作的 ID； 
					-r ：列出目前 CUPS 服务是否有在运作？ 
					-t ：列出目前打印系统中更为详细的信息说明，很适合查询喔！
			5. 利用 lpr 与 lp 来产生打印作业
				[root@www ~]# lpr [-P printer队列] [-# 打印份数] -U [username] file 
				选项与参数： 
					-P ：若没有默认打印机 (default) 或者想要由不同打印机输出时，可用 -P 指定打印机 
					-# ：如果这份文件你想要打印多个副本时，用这个 -# 加上份数就对了！ 
					-U ：有些打印机有限制可使用的使用者账号，此时就得要使用这个选项；
				[root@www ~]# lp [-d printer队列] [-n 打印份数] file 
				选项与参数： 
					-d ：后面接的是打印机的队列名称。如果有多部打印机才需要指定； 
					-n ：就是打印的份数啊！
			6. 打印作业的观察 (lpq) 与删除 (lprm)
				[root@www ~]# lpq [-al] [-P 打印队列] 
				选项与参数： 
					-a ：列出所有打印机上面在队列当中癿工作情况； 
					-l ：用其他较长格式来输出打印的相关信息 (拥有者与档案大小等等) 
					-P ：后面接特定的打印机，与 -a 不同。
				[root@www ~]# lprm [-P printer队列] job_id 
				选项与参数： 
					-P ：后面直接指定某部打印机的某个工作号码。注意，那个 job_id 就是刚刚我们使用 lpq 查看到的那个 Job 的号码啦！
	硬件数据收集与驱动，及 lm_sensors
		硬件信息的收集与分析
			我们也知道 Linux kernel 在开机时就能够侦测主机硬件并加载适当的模块来驱动硬件了。 而核心所侦测到的各项硬件装置，后来就会被记录在 /proc 与 /sys 当中了。 包括 /proc/cpuinfo, /proc/partitions, /proc/interrupts 等等。
			那除了直接呼叫出 /proc 底下的档案内容之外，其实 Linux 有提供几个简单的指令来将核心所侦测到的硬件叫出来的～ 常见的指令有底下这些：
				fdisk：第八章曾经谈过，可以使用 fdisk -l 将分割表列出；
				hdparm：第八章谈过的，可观察硬盘的信息与测试读写速度；
				dmesg：第十七章谈过， 观察核心运作过程当中所显示的各项讯息记录；
				vmstat：第十七章谈过，可分析系统 (CPU/RAM/IO) 目前的状态；
				lspci：列出整个 PC 系统的 PCI 接口装置！很有用的指令；
				lsusb：列出目前系统上面各个 USB 端口口的状态，与连接的 USB 装置；
				iostat：与vmstat 类似，可实时列出整个 CPU 与接口设备的 Input/Output 状态。
			lspci
				[root@www ~]# lspci [-vvn] 
				选项与参数： 
					-v ：显示更多的 PCI 接口装置的详细信息； 
					-vv ：比 -v 还要更详细的细部信息； 
					-n ：直接观察 PCI 的 ID 而不是厂商名称
				/usr/share/hwdata/pci.ids, 其实那个就是 PCI 的标准 ID 与厂牌名称的对应表啦！ 此外，刚刚我们使用 lspci 时，其实所有的数据都是由 /proc/bus/pci/ 目录下的数据所取出的呢
			lsusb
				[root@www ~]# lsusb [-t] 
				选项与参数： 
					-t ：使用类似树状目录来显示各个 USB 端口口的相关性
			iostat
				[root@www ~]# iostat [-c|-d] [-k|-m] [-t] [间隔秒数] [侦测次数] 
				选项与参数： 
					-c ：仅显示 CPU 的状态； 
					-d ：仅显示储存设备的状态，不可与 -c 一起用； 
					-k ：默认显示的是 block ，这里可以改成 K bytes 的大小来显示； 
					-m ：与 -k 类似，只是以 MB 的单位来显示结果。 
					-t ：显示日期出来；
		驱动 USB 装置
			启动 USB 的随身碟或快闪碟
				我们之前谈过 USB 的磁盘代号是： /dev/sd[a-p] 之类的，类似 SCSI 硬盘的代号， 这是因为 USB 的磁盘装置使用 SCSI 相关的装置代号，因此，如果您要使用 USB 随身碟的话，嘿嘿！那么您的 Linux 主机就得要支持 SCSI 装置才行～
		使用 lm_sensors 取得温度、电压等信息
			所谓的『超频』就是让系统原有的运作频率增加， 让 CPU/PCI/VGA 前端总线速度提升到非正规的频率，以取得较高的计算机效能。
			由于 lm_sensors 主要是依据『主板芯片组的型号，带入相关的模块后，再侦测其温度、电压』的， 如果该主板芯片组并不是 lm_sensors 所支持的模块，那自然就无法找出该芯片组的温压啰～ 所以啦，我们在使用 lm_sensors 之前，必须要确定主板是有提供温度、电压的， 再来，必须要加载主板的驱动模块，然后才有办法使用 lm_sensors 来进行侦测。
			lm_sensors 本来就提供我们一个不错的主板芯片组侦测程序， 那就是 sensors-detect 这个指令。侦测到主板芯片组后，将该信息写入配置文件当中， 就可以使用 sensors 指令直接读取目前的 CPU、机壳、电源、风扇等等的信息了！
			sensors-detect会进行型号的侦测，并且主动的建立了 /etc/sysconfig/lm_sensors 的参数配置文件
			侦测的指令就是 sensors
				[root@www ~]# sensors
		udev 与 hal 简介
			其实所有的硬件都是档案，这些装置档案必须要使用 mknod 才能建立的！ 那到底 (1)硬件如何侦测与 (2)装置档案如何主动建立呢？这就与 udev 及 HAL 这两个东西有关了。
			事实上，系统所有的硬件应该都是给核心管理癿，但我们知道操作系统在内存内是受保护的，用户根本无权使用操作系统核心。 为了解决这个问题于是有 udev 的产生。这个 udev 是个用户层级软件，他可以让用户自行处理 /dev 底下的装置！
			但我们如何知道系统上面多了个硬件呢？这时候就得要硬件抽象层 (Hardware Abstraction Layer, HAL) 的辅助了。 HAL 可以将系统目前的所有硬件进行快照，并持续检视这个快照的内容(注5)。如果有新的 PnP 硬件插入时， HAL 就会发现目前的硬件与快照不同，此时就会通知 udev 进行新的装置的建置了！如此一来，两者的配合就能够让你的装置 PnP 啰！
			udev 是在 /etc/rc.d/rc.sysinit 就启动了， 而 hal 则是在 /etc/init.d/haldaemon 这个服务才启动
			假设你想要将你的随身碟取名为较有趣的装置，不想再使用类似 /dev/sda1 之类的名称时，可以怎么作呢？ 我们可以透过更改 udev 的规则 (rule) 来使用 mknod 建立不同名称的装置档案。
			udev 建立装置档案的规则放置到 /etc/udev/rules.d/ 目录下，在该目录下的档案可以依序进行处理的。 以最简单的语法来看，在该目录下可以使用的变量与对应可以是： KERNEL=="核心能够分析到的档名", NAME="你要使用的装置文件名"

		
		
		
第二十二章、软件安装：原始码与 Tarball
	开放源码的软件安装与升级简介
		什么是开放源码、编译程序与可执行文件
			在 Linux 系统上面，一个档案能不能被执行看的是有没有可执行的那个权限 (具有 x permission)，不过，Linux 系统上真正认识的可执行文件其实是二进制文件 ( binary program)
			怎么知道一个档案是否为 binary 呢？可以使用file指令
		什么是函式库
		什么是 make 与 configure		
			当执行 make 时，make 会在当时的目录下搜寻 Makefile (or makefile) 这个文本文件，而 Makefile 里面则记录了原始码如何编译的详细信息！ make 会自动的判别原始码是否经过变动了，而自动更新执行档
			make 是一支程序，会去找 Makefile ，那 Makefile 怎么写？ 通常软件开发商都会写一支侦测程序来侦测用户的作业环境， 以及该作业环境是否有软件开发商所需要的其他功能，该侦测程序侦测完毕后，就会主动的建立这个 Makefile 的规则档案啦！通常这支侦测程序的文件名为 configure 或者是 config 。
			一般来说，侦测程序会侦测的数据大约有底下这些：
				是否有适和的编译程序可以编译本软件的程序代码；
				是否已经存在本软件所需要的函式库，或其他需要的相依软件；
				操作系统平台是否适合本软件，包括 Linux 的核心版本；
				核心的表头定义档 (header include) 是否存在 (驱动程序必须要的侦测)。
		什么是 Tarball 的软件
			如果能够将这些原始码透过档案的打包与压缩技术来将档案的数量与容量减小， 不但让用户容易下载，软件开发商的网站带宽也能够节省很多很多啊！这就是 Tarball 档案的由来啰！
			Tarball 是一个软件包， 你将他解压缩之后，里面的档案通常就会有：
				源代码档案；
				侦测程序档案 (可能是 configure 或 config 等檔名)；
				本软件的简易说明与安装说明 (INSTALL 或 README)。
		如何安装与升级软件
			基本上更新的方法可以分为两大类，分别是：
				直接以原始码透过编译来安装与升级；
				直接以编译好的 binary program 来安装与升级。
			一个软件的 Tarball 是如何安装的呢？基本流程是这样的啦：
				1. 将 Tarball 由厂商的网页下载下来；
				2. 将 Tarball 解开，产生很多的原始码档案；
				3. 开始以 gcc 进行原始码的编译 (会产生目标文件 object files)；
				4. 然后以 gcc 进行函式库、主、子程序的链接，以形成主要的 binary file；
				5. 将上述的 binary file 以及相关的配置文件安装至自己的主机上面。
				上面第 3, 4 步骤当中，我们可以透过 make 这个指令的功能来简化他
	使用传统程序语言进行编译的简单范例
		编译时加入额外函式库连结的方式： 
			[root@www ~]# gcc sin.c -lm -L/lib -L/usr/lib <==重点在 -lm
			特别注意，使用 gcc 编译时所加入的那个 -lm 是有意义的，他可以拆开成两部份来看：
				-l ：是『加入某个函式库(library)』的意思，
				m ：则是 libm.so 这个函式库，其中， lib 与扩展名(.a 戒 .so)不需要写
				所以 -lm 表示使用 libm.so (或 libm.a) 这个函式库的意思～至于那个 -L 后面接的路径呢？这表示： 『我要的函式库 libm.so 请到 /lib 或 /usr/lib 里面搜寻！』 上面的说明很清楚了吧！不过，要注意的是，由于 Linux 预设是将函式库放置在 /lib 与 /usr/lib 当中，所以你没有写 -L/lib 与 -L/usr/lib 也没有关系的！不过，万一哪天你使用的函式库并非放置在这两个目录下，那么 -L/path 就很重要了！否则会找不到函式库喔！
			[root@www ~]# gcc sin.c -lm -I/usr/include
				-I/path 后面接的路径( Path )就是设定要去搜寻相关的 include 档案的目录啦！不过，同样的，默认值是放置在 /usr/include 底下，除非你的 include 档案放置在其他路径，否则也可以略过这个项目！
	用 make 进行宏编译
		make 有这些好处：
			简化编译时所需要下达的指令；
			若在编译完成之后，修改了某个原始码档案，则 make 仅会针对被修改了的档案进行编译，其他的 object file 不会被更动；
			最后可以依照相依性来更新 (update) 执行档。
		makefile 的基本语法与变量
			基本的 makefile 规则是这样的：
				标的(target): 目标文件1 目标文件2 
				<tab> gcc -o 欲建立的执行文件 目标文件1 目标文件2
				那个标的 (target) 就是我们想要建立的信息，而目标文件就是具有相关性的 object files ，那建立执行文件的语法就是以 <tab> 按键开头的那一行！特别给他留意喔，『命令行必须要以 tab 按键作为开头』才行！他的规则基本上是这样的：
					在 makefile 当中的 # 代表批注；
					<tab> 需要在命令行 (例如 gcc 这个编译程序指令) 的第一个字符；
					标的 (target) 与相依档案(就是目标文件)之间需以『:』隔开。
				我们可以再藉由 shell script 那时学到的『变数』来更简化 makefile，与 bash shell script 的语法有点不太相同，变量的基本语法为：
					1. 变量与变量内容以『=』隔开，同时两边可以具有空格；
					2. 变量左边不可以有 <tab> ，例如上面范例的第一行 LIBS 左边不可以是 <tab>；
					3. 变量与变量内容在『=』两边不能具有『:』；
					4. 在习惯上，变数最好是以『大写字母』为主；
					5. 运用变量时，以 ${变量} 或 $(变量) 使用；
					6. 在该 shell 的环境变量是可以被套用的，例如提到的 CFLAGS 这个变数！
					7. 在指令列模式也可以给予变量。
				环境变量取用的规则是这样的：
					1. make 指令列后面加上的环境变量为优先；
					2. makefile 里面指定的环境变量第二；
					3. shell 原本具有的环境变量第三。
				还有一些特殊的变量需要了解的喔：
					$@：代表目前的标的(target)
	Tarball 的管理与建议
		使用原始码管理软件所需要的基础软件
			gcc 戒 cc 等 C 诧言编译程序 (compiler)
			make 及 autoconfig 等软件
			需要 Kernel 提供的 Library 以及相关的 Include 档案
		Tarball 安装的基本步骤
			安装的基础动作大多是这样的：
				1. 取得原始档：将 tarball 档案在 /usr/local/src 目录下解压缩；
				2. 取得步骤流程：进入新建立的目录底下，去查阅 INSTALL 与 README 等相关档案内容 (很重要的步骤！)；
				3. 相依属性软件安装：根据 INSTALL/README 的内容察看并安装好一些相依的软件 (非必要)；
				4. 建立 makefile：以自动侦测程序 (configure 或 config) 侦测作业环境，并建立 Makefile 这个档案；
				5. 编译：以 make 这个程序并使用该目录下的 Makefile 做为他的参数配置文件，来进行 make (编译或其他) 的动作；
				6. 安装：以 make 这个程序，并以 Makefile 这个参数配置文件，依据 install 这个标的 (target) 的指定来安装到正确的路径！
			通常『make clean』代表着将目标文件 (object file) 清除掉，『make』则是将原始码进行编译而已。 注意喔！编译完成的可执行文件与相关的配置文件还在原始码所在的目录当中喔！因此，最后要进行『make install』来将编译完成的所有咚咚都给他安装到正确的路径去，这样就可以使用该软件啦！
		一般 Tarball 软件安装的建议事项 (如何移除？升级？)
			在预设的情况下， man 会去搜寻 /usr/local/man 里面的说明文件
			通常我们会建议大家将自己安装的软件放置在 /usr/local 下，至于原始码 (Tarball)则建议放置在 /usr/local/src (src 为 source 的缩写)底下啊。
			为了方便 Tarball 的管理，通常鸟哥会这样建议使用者：
				1. 最好将 tarball 的原始数据解压缩到 /usr/local/src 当中；
				2. 安装时，最好安装到 /usr/local 这个默认路径下；
				3. 考虑未来的反安装步骤，最好可以将每个软件单独的安装在 /usr/local 底下；
				4. 为安装到单独目录的软件之 man page 加入 man path 搜寻： 如果你安装的软件放置到 /usr/local/software/ ，那么 man page 搜寻的设定中，可能就得要在 /etc/man.config 内的 40~50 行左右处，写入如下的一行：
					MANPATH /usr/local/software/man 这样才可以使用 man 来查询该软件的在线文件啰！
		利用 patch 更新原始码
			diff，这个指令可以将『两个档案之间的差异性列出来』呢！那我们也知道新旧版本的档案之间， 其实只有修改一些程序代码而已，那么我们可以透过 diff 比对出新旧版本之间的文字差异，然后再以相关的指令来将旧版的档案更新吗？ 呵呵！当然可以啦！那就是 patch 这个指令啦！很多的软件开发商在更新了原始码之后，几乎都会释出所谓的 patch file，也就是直接将原始码 update 而已的一个方式喔
			patch 的基本语法如下： 
				patch -p数字 < patch_file 
				特别留意那个『 -p数字』，那是与 patch_file 里面列出的文件名有关的信息。假如在 patch_file 第一行写的是这样： *** /home/guest/example/expatch.old 那么当我下达『 patch -p0 < patch_file 』时，则更新的档案是『 /home/guest/example/expatch.old 』，如果『 patch -p1 < patch_file』，则更新的档案为『home/guest/example/expatch.old』，如果『patch -p4 < patch_file』则更新『expatch.old』，也就是说， -pxx 那个 xx 代表『拿掉几个斜线(/)』的意思
	函式库管理		
		动态与静态函式库
			函式库又依照是否被编译到程序内部而分为动态与静态函式库
			静态函式库的特色：
				扩展名：(扩展名为 .a) 这类的函式库通常扩展名为 libxxx.a 的类型；
				编译行为： 这类函式库在编译的时候会直接整合到执行程序当中，所以利用静态函式库编译成的档案会比较大一些喔；
				独立执行的状态： 这类函式库最大的优点，就是编译成功的可执行文件可以独立执行，而不需要再向外部要求读取函式库的内容 (请参照动态函式库的说明)。
				升级难易度： 虽然执行档可以独立执行，但因为函式库是直接整合到执行档中， 因此若函式库升级时，整个执行档必须要重新编译才能将新版的函式库整合到程序当中。 也就是说，在升级方面，只要函式库升级了，所有将此函式库纳入的程序都需要重新编译！
			动态函式库的特色：
				扩展名：(扩展名为 .so) 这类函式库通常扩展名为 libxxx.so 的类型；
				编译行为： 动态函式库与静态函式库的编译行为差异挺大的。 与静态凼式库被整个捉到程序中不同的，动态函式库在编译的时候，在程序里面只有一个『指向 (Pointer)』的位置而已。也就是说，动态函式库的内容并没有被整合到执行档当中，而是当执行档要使用到函式库的机制时， 程序才会去读取函式库来使用。由于执行文件当中仅具有指向动态函式库所在的指标而已， 并不包含函式库的内容，所以他的档案会比较小一点。
				独立执行的状态： 这类型的函式库所编译出来的程序不能被独立执行， 因为当我们使用到函式库的机制时，程序才会去读取函式库，所以函式库档案『必须要存在』才行，而且，函式库的『所在目录也不能改变』，因为我们的可执行文件里面仅有『指标』亦即当要取用该动态函式库时， 程序会主动去某个路径下读取，呵呵！所以动态函式库可不能随意移动或删除，会影响很多相依的程序软件喔！
				升级难易度： 虽然这类型的执行档无法独立运作，然而由于是具有指向的功能， 所以，当函式库升级后，执行档根本不需要进行重新编译的行为，因为执行档会直接指向新的函式库档案 (前提是函式库新旧版本的档名相同喔！)。
			绝大多数的函式库都放置在：/usr/lib, /lib 目录下！ 此外，Linux 系统里面很多的函式库其实 kernel 就提供了，那么 kernel 的函式库放在哪里？呵呵！就是在 /lib/modules 里面啦
		ldconfig 与 /etc/ld.so.conf
			如何将动态函式库加载高速缓存当中呢？
				1. 首先，我们必须要在 /etc/ld.so.conf 里面写下『 想要读入高速缓存当中的动态函式库所在的目录』，注意喔， 是目录而不是档案；
				2. 接下来则是利用 ldconfig 这个执行档将 /etc/ld.so.conf 的资料读入快取当中；
				3. 同时也将数据记录一份在 /etc/ld.so.cache 这个档案当中吶！
			[root@www ~]# ldconfig [-f conf] [ -C cache] 
			[root@www ~]# ldconfig [-p] 
			选项与参数： 
				-f conf ：那个 conf 指的是某个文件名，也就是说，使用 conf 作为 libarary 函式库的取得路径，而不以 /etc/ld.so.conf 为默认值 
				-C cache：那个 cache 指的是某个文件名，也就是说，使用 cache 作为快取暂存 的函式库资料，而不以 /etc/ld.so.cache 为默认值 
				-p ：列出目前有的所有函式库资料内容 (在 /etc/ld.so.cache 内的资料！)
		程序的动态函式库解析： ldd
			如何判断某个可执行的 binary 档案含有什么动态函式库呢？很简单，利用 ldd 就可以晓得了
				[root@www ~]# ldd [-vdr] [filename] 
				选项与参数： 
					-v ：列出所有内容信息； 
					-d ：重新将资料有遗失的 link 点秀出来！ 
					-r ：将 ELF 有关的错误内容秀出来！
	检验软件正确性		
		md5sum / sha1sum
			[root@www ~]# md5sum/sha1sum [-bct] filename 
			[root@www ~]# md5sum/sha1sum [--status|--warn] --check filename 
			选项与参数： 
				-b ：使用 binary 的读档方式，默认为 Windows/DOS 档案型态的读取方式； 
				-c ：检验档案指纹； 
				-t ：以文字型态来读取档案指纹。
			
			
			
第二十三章、软件安装： RPM, SRPM 与 YUM 功能			
	软件管理员简介		
		Linux 界的两大主流: RPM 与 DPKG
		什么是 RPM 与 SRPM
			RPM 是以一种数据库记录的方式来将你所需要的软件安装到你的 Linux 系统的一套管理机制.他最大的特点就是将你要安装的软件先编译过， 并且打包成为 RPM 机制的包装档案，透过包装好的软件里头默认的数据库记录， 记录这个软件要安装的时候必须具备的相依属性软件，当安装在你的 Linux 主机时， RPM 会先依照软件里头的数据查询 Linux 主机的相依属性软件是否满足， 若满足则予以安装，若不满足则不予安装。那么安装的时候就将该软件的信息整个写入 RPM 的数据库中，以便未来的查询、验证与反安装！这样一来的优点是：
				1. 由于已经编译完成并且打包完毕，所以软件传输与安装上很方便 (不需要再重新编译)；
				2. 由于软件的信息都已经记录在 Linux 主机的数据库上，很方便查询、升级与反安装
			这些软件管理机制的问题是：
				1. 软件档案安装的环境必须与打包时的环境需求一致或相当；
				2. 需要满足软件的相依属性需求；
				3. 反安装时需要特别小心，最底层的软件不可先移除，否则可能造成整个系统的问题！
			既然 SRPM 提供的是原始码，那么为什么我们不使用 Tarball 直接来安装就好了？这是因为 SRPM 虽然内容是原始码， 但是他含有该软件所需要的相依性软件说明、以及所有 RPM 档案所提供的数据。同时，他与 RPM 不同的是，他也提供了参数配置文件 (就是 configure 与 makefile)。所以，如果我们下载的是 SRPM ，那么要安装该软件时，你就必须要：
				先将该软件以 RPM 管理的方式编译，此时 SRPM 会被编译成为 RPM 档案；
				然后将编译完成的 RPM 档案安装到 Linux 系统当中
		什么是 i386, i586, i686, noarch, x86_64
			例如 rp-pppoe-3.1-5.i386.rpm 这的档案的意义为：
				rp-pppoe - 3.1 - 5 .i386 .rpm 
				软件名称 软件的版本信息 释出的次数 适合的硬件平台 扩展名
				除了后面适合的硬件平台与扩展名外，主要是以『-』来隔开各个部分，这样子可以很清楚的发现该软件的名称、 版本信息、打包次数与操作的硬件平台
			平台名称 	适合平台说明 
			i386 		几乎适用于所有的 x86 平台，不论是旧的 pentum 或者是新的 Intel Core 2 与 K8 系列的 CPU 等等，都可以正常的工作！那个 i 指的是 Intel 兼容的 CPU 的意思，至于 386 不用说，就是 CPU 的等级啦！ 
			i586 		就是针对 586 等级的计算机进行优化编译。那是哪些 CPU 呢？包括 pentum 第一代 MMX CPU， AMD 的 K5, K6 系列 CPU (socket 7 插脚) 等等的 CPU 都算是这个等级； 
			i686 		在 pentun II 以后的 Intel 系列 CPU ，及 K7 以后等级的 CPU 都属于这个 686 等级！ 由于目前市面上几乎仅剩 P-II 以后等级的硬件平台，因此很多 distributions 都直接释出这种等级的 RPM 档案。 
			x86_64 		针对 64 位的 CPU 进行优化编译设定，包括 Intel 的 Core 2 以上等级 CPU ，以及 AMD 的 Athlon64 以后等级的 CPU ，都属于这一类型的硬件平台。 
			noarch 		就是没有任何硬件等级上的限制。一般来说，这种类型的 RPM 档案，里面应该没有 binary program 存在， 较常出现的就是属于 shell script 方面的软件。
		RPM 的优点
			RPM 有以下的优点：
				RPM 内含已经编译过的程序与配置文件等数据，可以让用户克除重新编译的困扰；
				RPM 在被安装之前，会先检查系统的硬盘容量、操作系统版本等，可避克档案被错误安装；
				RPM 档案本身提供软件版本信息、相依属性软件名称、软件用途说明、软件所含档案等信息，便于了解软件；
				RPM 管理的方式使用数据库记录 RPM 档案的相关参数，便于升级、移除、查询与验证。
			当你要安装某个以 RPM 型态提供的软件时，在安装的过程中， RPM 会去检验一下数据库里面是否已经存在相关的软件了， 如果数据库显示不存在，那么这个 RPM 档案『预设』就不能安装
		RPM 属性相依的克服方式： YUM 在线升级
			目前的 distributions 在释出软件时， 都会将软件的内容分为一般使用与开发使用 (development) 两大类。所以你才会常常看到有类似 pam-x.x.rpm 与 pam-devel-x.x.rpm 之类的档名啊
			CentOS 先将释出的软件放置到 YUM 服务器内，然后分析这些软件的相依属性问题，将软件内的记录信息写下来 (header)。 然后再将这些信息分析后记录成软件相关性的列表列表。这些列表数据与软件所在的位置可以称呼为容器 (repository)。 当客户端有软件安装的需求时，客户端主机会主动的向网络上面的 yum 服务器的容器网址下载清单列表， 然后透过列表列表的数据与本机 RPM 数据库已存在的软件数据相比较，就能够一口气安装所有需要的具有相依属性的软件了。
	RPM 软件管理程序： rpm
		RPM 默认安装的路径
			一般来说，RPM 类型的档案在安装的时候，会先去读取档案内记载的设定参数内容，然后将该数据用来比对 Linux 系统的环境，以找出是否有属性相依的软件尚未安装的问题。
			若环境检查合格了，那么 RPM 档案就开始被安装到你的 Linux 系统上。安装完毕后，该软件相关的信息就会被写入 /var/lib/rpm/ 目录下的数据库档案中了。
			目前的 RPM 也提供数字签名信息， 这些数字签名也是在这个目录内记录的呢！
			软件内的档案到底是放置到哪里去啊？
				/etc 			一些配置文件放置的目录，例如 /etc/crontab 
				/usr/bin 		一些可执行文件案 
				/usr/lib 		一些程序使用的动态函式库 
				/usr/share/doc 	一些基本的软件使用手册与说明文件 
				/usr/share/man 	一些 man page 档案
		RPM 安装 (install)
			[root@www ~]# rpm -ivh package_name 
			选项与参数： 
				-i ：install 的意思 
				-v ：察看更细部的安装信息画面 
				-h ：以安装信息列显示安装进度
			rpm 安装时常用的选项与参数说明 
				可下达的选项 		代表意义 
				--nodeps 			使用时机：当发生软件属性相依问题而无法安装，但你执意安装时 危险性： 软件会有相依性的原因是因为彼此会使用到对方的机制或功能，如果强制安装而不考虑软件的属性相依， 则可能会造成该软件的无法正常使用！ 
				--replacefiles 		使用时机： 如果在安装的过程当中出现了『某个档案已经被安装在你的系统上面』的信息，又或许出现版本不合的讯息 (confilcting files) 时，可以使用这个参数来直接覆盖档案。 危险性： 覆盖的动作是无法复原的！所以，你必须要很清楚的知道被覆盖的档案是真的可以被覆盖喔！否则会欲哭无泪！ 
				--replacepkgs 		使用时机： 重新安装某个已经安装过的软件！如果你要安装一堆 RPM 软件档案时，可以使用 rpm -ivh *.rpm ，但若某些软件已经安装过了， 此时系统会出现『某软件已安装』的信息，导致无法继续安装。此时可使用这个选项来重复安装喔！ 
				--force 			使用时机：这个参数其实就是 --replacefiles 与 --replacepkgs 的综合体！ 
				--test 				使用时机： 想要测试一下该软件是否可以被安装到使用者的 Linux 环境当中，可找出是否有属性相依的问题。范例为： rpm -ivh pkgname.i386.rpm --test 
				--justdb 			使用时机： 由于 RPM 数据库破损或者是某些缘故产生错误时，可使用这个选项来更新软件在数据库内的相关信息。 
				--nosignature 		使用时机： 想要略过数字签名的检查时，可以使用这个选项。 
				--prefix 			新路径 使用时机： 要将软件安装到其他非正规目录时。举例来说，你想要将某软件安装到 /usr/local 而非正规的 /bin, /etc 等目录， 就可以使用『 --prefix /usr/local 』来处理了。 
				--noscripts 		使用时机：不想让该软件在安装过程中自行执行某些系统指令。 说明： RPM 的优点除了可以将档案放置到定位之外，还可以自动执行一些前置作业的指令，例如数据库的初始化。 如果你不想要让 RPM 帮你自动执行这一类型的指令，就加上他吧！
		RPM 升级与更新 (upgrade/freshen)
			-Uvh 后面接的软件即使没有安装过，则系统将予以直接安装； 若后面接的软件有安装过旧版，则系统自动更新至新版； 
			-Fvh 如果后面接的软件并未安装到你的 Linux 系统上，则该软件不会被安装；亦即只有已安装至你 Linux 系统内的软件会被『升级』！
		RPM 查询 (query)
			[root@www ~]# rpm -qa <==已安装软件 
			[root@www ~]# rpm -q[licdR] 已安装的软件名称 <==已安装软件 
			[root@www ~]# rpm -qf 存在于系统上面的某个文件名 <==已安装软件 
			[root@www ~]# rpm -qp[licdR] 未安装的某个文件名 <==查阅RPM档案 
			选项与参数： 
				查询已安装软件的信息： 
				-q ：仅查询，后面接的软件名称是否有安装； 
				-qa ：列出所有的，已经安装在本机 Linux 系统上面的所有软件名称； 
				-qi ：列出该软件的详细信息 (information)，包含开发商、版本与说明等； 
				-ql ：列出该软件所有的档案与目录所在完整文件名 (list)； 
				-qc ：列出该软件的所有配置文件 (找出在 /etc/ 底下的檔名而已) 
				-qd ：列出该软件的所有说明文件 (找出与 man 有关的档案而已) 
				-qR ：列出与该软件有关的相依软件所含的档案 (Required 的意思) 
				-qf ：由后面接的文件名，找出该档案属于哪一个已安装的软件； 查询某个 RPM 档案内含有的信息： 
				-qp[icdlR]：注意 -qp 后面接的所有参数以上面的说明一致。但用途仅在于找出 某个 RPM 档案内的信息，而非已安装的软件信息！注意！
			在查询的部分，所有的参数之前都需要加上 -q 才是所谓的查询！查询主要分为两部分， 一个是查已安装到系统上面的的软件信息，这部份的信息都是由 /var/lib/rpm/ 所提供。另一个则是查某个 rpm 档案内容， 等于是由 RPM 档案内找出一些要写入数据库内的信息就是了，这部份就得要使用 -qp (p 是 package 的意思)。
		RPM 验证与数字签名 (Verify/signature)
			[root@www ~]# rpm -Va [root@www ~]# rpm -V 已安装的软件名称 
			[root@www ~]# rpm -Vp 某个 RPM 档案的档名 
			[root@www ~]# rpm -Vf 在系统上面的某个档案
			选项与参数： 
				-V ：后面加的是软件名称，若该软件所含的档案被更动过，才会列出来； 
				-Va ：列出目前系统上面所有可能被更动过的档案； 
				-Vp ：后面加的是文件名，列出该软件内可能被更动过的档案； 
				-Vf ：列出某个档案是否被更动过～
			[root@www ~]# rpm -V logrotate ..5....T c /etc/logrotate.conf
				最前面的八个信息是：
					S ：(file Size differs) 档案的容量大小是否被改变
					M ：(Mode differs) 档案的类型或档案的属性 (rwx) 是否被改变？如是否可执行等参数已被改变
					5 ：(MD5 sum differs) MD5 这一种指纹码的内容已经不同
					D ：(Device major/minor number mis-match) 装置的主/次代码已经改变
					L ：(readLink(2) path mis-match) Link 路径已被改变
					U ：(User ownership differs) 档案的所属人已被改变
					G ：(Group ownership differs) 档案的所属群组已被改变
					T ：(mTime differs) 档案的建立时间已被改变
				至于那个 c 代表的是『 Config file 』的意思，也就是档案的类型，文件类型有底下这几类：
					c ：配置文件 (config file)
					d ：文件数据文件 (documentation)
					g ：鬼档案～通常是该档案不被某个软件所包含，较少发生！(ghost file)
					l ：许可证文件 (license file)
					r ：自述文件 (read me)
			就像你自己的签名一样，我们的软件开发商原厂所推出的软件也会有一个厂商自己的签章系统！ 只是这个签章被数字化了而已。厂商可以数字签名系统产生一个与属于该软件的签章，并将该签章的公钥 (public key) 释出。 当你要安装一个 RPM 档案时：
				1. 首先你必须要先安装原厂释出的公钥档案；
				2. 实际安装原厂的 RPM 软件时， rpm 指令会去读取 RPM 档案的签章信息，与本机系统内的签章信息比对，
				3. 若签章相同则予以安装，若找不到相关的签章信息时，则给予警告并且停止安装喔。
		RPM 反安装与重建数据库 (erase/rebuilddb)
			移除的选项很简单，就透过 -e 即可移除。
			可以使用 --rebuilddb 这个选项来重建一下数据库喔
				[root@www ~]# rpm --rebuilddb <==重建数据库
	SRPM 的使用 ： rpmbuild
		新版的 rpm 已经将 RPM 与 SRPM 的指令分开了，SRPM 使用的是 rpmbuild 这个指令，而不是 rpm 喔
		利用默认值安装 SRPM 档案 (--rebuid/--recompile)		
			--rebuild 这个选项会将后面的 SRPM 进行『编译』与『打包』的动作，最后会产生 RPM 的档案，但是产生的 RPM 档案并没有安装到系统上。当你使用 --rebuild 的时候，最后通常会发现一行字体： Wrote: /usr/src/redhat/RPMS/i386/pkgname.i386.rpm 这个就是编译完成的 RPM 档案啰！这个档案就可以用来安装啦！安装的时候请加绝对路径来安装即可！ --recompile 这个动作会直接的『编译』『打包』并且『安装』啰！请注意， rebuild 仅『编译并打包』而已，而 recompile 不但进行编译跟打包，还同时进行『安装』了！
		SRPM 使用的路径与需要的软件
			SRPM 在进行编译的时候会使用到哪些目录呢？
				/usr/src/redhat/SPECS 		这个目录当中放置的是该软件的配置文件，例如这个软件的信息参数、设定项目等等都放置在这里； 
				/usr/src/redhat/SOURCES 	这个目录当中放置的是该软件的原始文件 (*.tar.gz 的档案) 以及 config 这个配置文件； 
				/usr/src/redhat/BUILD 		在编译的过程中，有些暂存的数据都会放置在这个目录当中； /usr/src/redhat/RPMS 经过编译之后，并且顺利的编译成功之后，将打包完成的档案放置在这个目录当中。里头有包含了 i386, i586, i686, noarch.... 等等的次目录。
				/usr/src/redhat/SRPMS 		与 RPMS 内相似的，这里放置的就是 SRPM 封装的档案啰！有时候你想要将你的软件用 SRPM 的方式释出时， 你的 SRPM 档案就会放置在这个目录中了。
		配置文件的主要内容 (*.spec)
			除了使用 SRPM 内预设的参数来进行编译之外，我们还可以修改这些参数后再重新编译.我们的设定参数档，亦即是在 /usr/src/redhat/SPECS 内的 *.spec 档案啰
		SRPM 的编译指令 (-ba/-bb)	
			要将在 /usr/src/redhat 底下的数据编译或者是单纯的打包成为 RPM 或 SRPM 时，就需要 rpmbuild 指令与相关选项的帮忙了！我们只介绍两个常用的选项给您了解一下： 
				[root@www ~]# rpmbuild -ba rp-pppoe.spec <==编译并同时产生 RPM 与 SRPM 档案 
				[root@www ~]# rpmbuild -bb rp-pppoe.spec <==仅编译成 RPM 档案
			这个时候系统就会这样做：
				1. 先进入到 BUILD 这个目录中，亦即是： /usr/src/redhat/BUILD 这个目录；
				2. 依照 *.spec 档案内的 Name 与 Version 定义出工作的目录名称，以我们上面的例子为例，那么系统就会在 BUILD 目录中先删除 rp-pppoe-3.5 的目录，再重新建立一个 rp-pppoe-3.5 的目录，并进入该目录；
				3. 在新建的目录里面，针对 SOURCES 目录下的来源档案，也就是 *.spec 里面的 Source 设定的那个档案，以 tar 进行解压缩，以我们这个例子来说，则会在 /usr/src/redhat/BUILD/rp-pppoe-3.5 当中，将 /usr/src/redhat/SOURCES/rp-pppoe-3.5.tar.gz 进行解压缩啦！
				4. 再来开始 %build 及 %install 的设定与编译！
				5. 最后将完成打包的档案给他放置到该放置的地方去，如果你的规定的硬件是在 i386 的系统，那么最后编译成功的 *.i386.rpm档案就会被放置在 /usr/src/redhat/RPMS/i386 里面啰！如果是 i686 那么自然就是 /usr/src/redhat/RPMS/i686 目录下啰！
	YUM 在线升级机制
		利用 yum 进行查询、安装、升级与移除功能
			查询功能：yum [list|info|search|provides|whatprovides] 参数
				[root@www ~]# yum [option] [查询工作项目] [相关参数] 
				选项与参数： 
					[option]：主要的选项，包括有： 
						-y ：当 yum 要等待用户输入时，这个选项可以自动提供 yes 的响应； 
						--installroot=/some/path ：将该软件安装在 /some/path 而且使用默认路径 
					[查询工作项目] [相关参数]：这方面的参数有： 
						search ：搜寻某个软件名称或者是描述 (description) 的重要关键字； 
						list ：列出目前 yum 所管理的所有的软件名称与版本，有点类似 rpm -qa；
						info ：同上，不过有点类似 rpm -qai 的执行结果； 
						provides：依档案去搜寻软件！类似 rpm -qf 的功能！
			安装/升级功能：yum [install|update] 软件
				[root@www ~]# yum [option] [查询工作项目] [相关参数] 
				选项与参数： 
					install ：后面接要安装的软件！ 
					update ：后面接要升级的软件，若要整个系统都升级，就直接 update 即可
			移除功能：yum [remove] 软件	
		yum 的配置文件
			yum服务器的地址http://ftp.twaren.net/Linux/CentOS/5/os/i386/， 有什么在上述的网址内呢？有什么特色！最重要的特色就是那个『 repodata 』的目录！该目录就是分析 RPM 软件后所产生的软件属性相依数据放置处！因此，当你要找容器所在网址时， 最重要的就是该网址底下一定要有个名为 repodata 的目录存在！那就是容器的网址了！
			[root@www ~]# vi /etc/yum.repos.d/CentOS-Base.repo 
			[base] name=CentOS-$releasever 
			- Base mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=os 
			#baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/ 
			gpgcheck=1 
			gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-5
				如上所示，鸟哥仅列出 base 这个容器内容而已，其他的容器内容请自行查阅啰！上面的数据需要注意的是：
				 [base]：代表容器的名字！中刮号一定要存在，里面的名称则可以随意取。但是不能有两个相同的容器名称， 否则 yum 会不晓得该到哪里去找容器相关软件列表档案。
				 name：只是说明一下这个容器的意义而已，重要性不高！
				 mirrorlist=：列出这个容器可以使用的映射站台，如果不想使用，可以批注到这行；
				 baseurl=：这个最重要，因为后面接的就是容器的实际网址！ mirrorlist 是由 yum 程序自行去捉映像站台， baseurl 则是指定固定的一个容器网址！我们刚刚找到的网址放到这里来啦！
				 enable=1：就是让这个容器被启动。如果不想启动可以使用 enable=0 喔！
				 gpgcheck=1：还记得 RPM 的数字签名吗？这就是指定是否需要查阅 RPM 档案内的数字签名！
				 gpgkey=：就是数字签名的公钥文件所在位置！使用默认值即可
			范例一：列出目前 yum server 所使用的容器有哪些？ 
				[root@www ~]# yum repolist all
			由于我们是修改系统默认的配置文件，事实上，我们应该要在 /etc/yum.repos.d/ 底下新建一个档案， 该扩展名必须是 .repo 才行！但因为我们使用的是指定特定的映射站台，而不是其他软件开发生提供的容器， 因此才修改系统默认配置文件。但是可能由于使用的容器版本有新旧之分，你得要知道， yum 会先下载容器的清单到本机的 /var/cache/yum 里面去！那我们修改了网址却没有修改容器名称 (中刮号内的文字)， 可能就会造成本机的列表与 yum 服务器的列表不同步，此时就会出现无法更新的问题了！ 那怎么办啊？很简单，就清除掉本机上面的旧数据即可！需要手动处理吗？不需要的， 透过 yum 的 clean 项目来处理即可！ 
				[root@www ~]# yum clean [packages|headers|all] 
				选项与参数： 
					packages：将已下载的软件档案删除 
					headers ：将下载的软件文件头删除 
					all ：将所有容器数据都删除！ 
				范例一：删除已下载过的所有容器的相关数据 (含软件本身与列表) [root@www ~]# yum clean all
		yum 的软件群组功能
			[root@www ~]# yum [群组功能] [软件群组] 
			选项与参数： 
				grouplist ：列出所有可使用的『套件组』，例如 Development Tools 之类的； 
				groupinfo ：后面接 group_name，则可了解该 group 内含的所有套件名； 
				groupinstall：这个好用！可以安装一整组的套件群组，相当的不错用！ 
				groupremove ：移除某个套件群组；
		全系统自动升级
			透过『 yum -y update 』来自动升级，那个 -y 很重要，因为可以自动回答 yes 来开始下载与安装！ 然后再透过 crontab 的功能来处理即可！
			此外，你还是得要分析登录档与收集 root 的信件的， 因为如果升级的是核心软件 (kernel)，那么你还是得要重新启动才会让安装的软件顺利运作的！ 所以还是得分析登录档，若有新核心安装，就重新启劢，否则就让系统自劢维持在最新较安全的环境吧！
	管理的抉择：RPM 还是 Tarball
		优先选择原厂的 RPM 功能：
		选择软件官网释出的 RPM 或者是提供的容器网址：
		利用 Tarball 安装特殊软件：
			些特殊用途的软件并不会特别帮你制作 RPM 档案的，此时建议你也不要妄想自行制作 SRPM 来转成 RPM 啦！ 因为你只有区区一部主机而已，若是你要管理相同的 100 部主机，那么将原始码转制作成 RPM 就有价值！ 单机版的特殊软件，例如学术网络常会用到的 MPICH/PVM 等平行运算函式库，这种软件建议使用 tarball 来安装即可， 不需要特别去搜寻 RPM 啰！
		用 Tarball 测试新版软件：
		如果你曾经修改过 yum 配置文件内的容器设定 (/etc/yum.repos.d/*.repo) ，导致下次使用 yum 进行安装时老是发现错误， 此时你该如何是好？
			先确认你的配置文件确实是正确的，如果没问题，可以将 yum 的快取清除，使用『yum clean all』即可。 事实上， yum 的所有快取、下载软件、下载软件的表头数据，都放置于 /var/cache/yum/ 目录下。
			
			
			
第二十四章、 X Window 设定介绍
	在 Linux 上头的图形接口我们称之为 X Window System，简称为 X 或 X11 啰！ 为何称之为系统呢？这是因为 X 窗口系统又分为 X server 与 X client ，既然是 Server/Client (主从架构) 这就表示其实 X 窗口系统是可以跨网绚且跨平台的！
	什么是 X Window System
		X Window 的发展简史
			在 Unix Like 上面的图形用户接口 (GUI) 被称为 X 或 X11；
			X11 是一个『软件』而不是一个操作系统；
			X11 是利用网络架构来进行图形接口的执行与绘制；
			较著名的 X 版本为 X11R6 这一版，目前大部分的 X 都是这一版演化出来的 (包括 X11R7)；
			现在大部分的 distribution 使用的 X 都是由 Xorg 基金会所提供的 X11 软件；
			X11 使用的是 MIT 授权，为类似 GPL 的自由软件授权方式。
		主要组件： X Server/X Client/Window Manager/Display Manager
			X Window system 是个利用网络架构的图形用户接口软件，基本上是分成 X Server 与 X Client 两个组件而已喔！其中 X Server 在管理硬件，而 X Client 则是应用程序。 在运作上，X Client 应用程序会将所想要呈现的画面告知 X Server ，最终由 X server 来将结果透过他所管理的硬件绘制出来！
			X Server：硬件管理、屏幕绘制与提供字型功能：
				每部客户端主机都需要安装 X Server，而服务器端则是提供 X Client 软件， 以提供客户端绘图所需要的数据数据
				显示适配器、屏幕以及键盘鼠标的设定，不是在开机的时候 Linux 系统以 /etc/sysconfig 目录下的 keyboard/mouse 等配置文件就设好了吗？为何 X Server 还要重新设定啊？这是因为 X Window 在 Linux 里面仅能算是『一套很棒的软件』， 所以 X Window 有自己的配置文件，你必须要针对他的配置文件设定妥当才行。也就是说， Linux 的设定与 X Server 的设定不一定要相同的！因此，你在 Linux 的 run level 3 想要玩图形接口时，就得要加轲 X Window 需要的驱动程序才行
			X Client：负责 X Server 要求的『事件』之处理：
				X Client 最重要的工作就是处理来自 X Server 的动作，将该动作处理成为绘图数据， 再将这些绘图数据传回给 X Server 啰！由于 X Client 的目的在产生绘图的数据，因此我们也称呼 X Client 为 X Application (X 应用程序)。
			X Window Manager：特殊的 X Client ，负责管理所有的 X client 软件
				Window Manager (WM, 窗口管理员) 也是 X client ，只是他主要在负责全部 X client 的控管，还包括提供某些特殊的功能，例如：
					提供许多的控制元素，包括任务栏、背景桌面的设定等等；
					管理虚拟桌面 (virtual desktop)；
					提供窗口控制参数，这包括窗口的大小、窗口的重迭显示、窗口的移动、窗口的最小化等等。
			Display Manager：提供登入需求
				在本机的文字接口底下你可以输入 startx 来启动 X 系统，此时由于你已经登入系统了，因此不需要重新登入即可取得 X 环境。但如果是 runlevel 5 的环境呢？你会发现在 tty7 的地方有个可以让你使用图形接口登入 (输入账号密码) 的咚咚，那个是啥？ 是 X Server/X client 还是什么的？其实那是个 Display Manager 啦！这个 display manager 最大的任务就是提供登入的环境， 并且加载使用者选择的 Window Manager 与语系等数据喔！
			X Window 的启动流程
				现在我们知道要启动 X Window System 时，必须要先启动管理硬件与绘图的 X Server ，然后才加载 X Client 。
				目前都是使用 Window Manager 来管理窗口接口风格的。那么如何取得这样的窗口系统呢？ 你可以透过登入本机的文字接口后，输入 startx 来启动 X 窗口；也能够透过 display manager (如果有启动 runlevel 5) 提供的登入画面，输入你的账号密码来登入与取得 X 窗口的！
				startx 其实是一个 shell script ，startx 最重要的任务就是找出用户或者是系统默认的 X server 与 X client 的配置文件，而使用者也能够使用 startx 外接参数来取代配置文件的内容。这个意思是说：startx 可以直接启动，也能够外接参数，例如底下格式的启动方式： 
					[root@www ~]# startx [X client 参数] -- [X server 参数] # 
					范例：以颜色深度为 16 bit 启动 X 
					[root@www ~]# startx -- -depth 16
				startx 找到的设定值可用顺序为何呢？基本上是这样的：
					X server 癿参数方面：
						1. 使用 startx 后面接的参数；
						2. 若无参数，则找寻用户家目录的档案，亦即 ~/.xserverrc
						3. 若无上述两者，则以 /etc/X11/xinit/xserverrc
						4. 若无上述三者，则单纯执行 /usr/bin/X (此即 X server 执行档)
					X client 的参数方面：
						1. 使用 startx 后面接的参数；
						2. 若无参数，则找寻用户家目录的档案，亦即 ~/.xinitrc
						3. 若无上述两者，则以 /etc/X11/xinit/xinitrc
						4. 若无上述三者，则单纯执行 xterm (此为 X 底下的终端机软件)
				事实上，当 startx 找到需要的设定值后，就呼叫 xinit 实际启动 X 的。他的语法是： 
					[root@www ~]# xinit [client option] -- [server or display option]
				在预设的情况下 (使用者尚未有 ~/.xinitrc 等档案时)，你输入 startx ， 就等于进行 
					xinit /etc/X11/xinit/xinitrc -- /etc/X11/xinit/xserverrc 
					这个指令一般！但由于 xserverrc 也不存在，参考上一小节的参数搜寻顺序， 因此实际上的指令是：xinit /etc/X11/xinit/xinitrc -- /usr/bin/X
				那为什么不要直接执行 xinit 而是使用 startx 来呼叫 xinit 呢？这是因为我们必须要取得一些参数嘛！ startx 可以帮我们快速的找到这些参数而不必手动输入的。因为单纯只是执行 xinit 的时候，系统的默认 X Client 与 X Server 的内容是这样的：(注3) xinit xterm -geometry +1+1 -n login -display :0 -- X :0
				在 X client 方面：那个 xterm 是 X 窗口底下的虚拟终端机，后面接的参数则是这个织端机的位置与登入与否。 最后面会接一个『 -display :0 』表示这个虚拟终端机是启动在『第 :0 号的 X 显示接口』的意思。至于 X Server 方面， 而我们启动的 X server 程序就是 X 啦！其实 X 就是 Xorg 的连结档，亦即是 X Server 的主程序啰！ 所以我们启动 X 还挺简单的～直接执行 X 而已，同时还指定 X 启动在第 :0 个 X 显示接口。 如果单纯以上面的内容来启动你的 X 系统时，你就会发现 tty7 有画面了！只是.....很丑～因为我们还没有启动 window manager 啊！
				X 窗口最先需要启动的就是 X server 啊，那 X server 启动癿脚本与参数是透过 /etc/X11/xinit/ 里面的 xserverrc 。不过我们的 CentOS 5.x 根本就没有 xserverrc 这个档案啊！ 那用户家目录目前也没有 ~/.xserverrc ，这个时候系统会怎么做呢？其实就是执行 /usr/bin/X 这个指令啊！ 这个指令也是系统最原始的 X server 执行档啰。
				在启动 X Server 时，Xorg 会去读取 /etc/X11/xorg.conf 这个配置文件。针对这个配置文件的内容， 我们会在下个小节介绍。如果一切顺利，那么 X 就会顺利的在 tty7 的环境中启动了 X 。 单纯的 X 启动时，你只会看到画面一片漆黑，然后中心有个鼠标的光标而已～
				发现到其实 X 启动的时候还可以指定启动的接口喔！那就是 :0 这个参数，这是啥？ 事实上我们的 Linux 可以『同时启动多个 X』喔！第一个 X 的画面会在 :0 亦即是 tty7 ，第二个 X 则是 :1 亦即是 tty8 。 后续还可以有其他的 X 存在的。因此，上一小节我们也有发现， xterm 在加载时，也必须要使用 -display 来说明， 这个 X 应用程序是需要在哪个 X 加载的才行呢！其中比较有趣的是， X server 未注明加载的接口时，默认是使用 :0 ～ 但是 X client 未注明时，则无法执行喔！
				假设你的家目录并没有 ~/.xinitrc ，则此时 X Client 会以 /etc/X11/xinit/xinitrc 来作为启动 X Client 的预设脚本。xinitrc 这个档案会将很多其他的档案参数引进来， 包括 /etc/X11/xinit/xinitrc-common 与 /etc/X11/xinit/Xclients 还有 /etc/sysconfig/desktop 。
				可以发现最终在 XClient 档案当中会有两个指令的搜寻， 包括 startkde 与 gnome-session 这两个，这也是 CentOS 预设会提供的两个主要的 Window Manager 啰。 而你也可以透过修改 /etc/sysconfig/desktop 内的 DESKTOP=GNOME 或 DESKTOP=KDE 来决定默认使用哪个窗口管理员的。
				如果有特殊需求，你当然可以自定义 X client 的参数！这就得要修改你家目录下的 ~/.xinitrc 这个档案啰。
				如果你的 .xinitrc 配置文件里面有启动的 x client 很多的时候，千万注意将除了最后一个 window manager 或 X Client 之外，都放到背景里面去执行啊！
				在文字接口底下启动 X 时，直接使用 startx 来找到 X server 与 X client 的参数或配置文件， 然后再呼叫 xinit 来启动 X 窗口系统。xinit 先载入 X server 到预设的 :0 这个显示接口 (默认在 tty7)，然后再加轲 X client 到这个 X 显示接口上。而 X client 通常就是 GNOME 或 KDE ，这两个设定也能够在 /etc/sysconfig/desktop 里面作好设定。
				CentOS 由于考虑 X 窗口是在本机上面运作，因此将埠口改为插槽档 (socket) 了，因此你无法观察到 X 启动的埠口的。事实上， X server 应该是要启动一个 port 6000 来与 X client 进行沟通的！由于系统上面也可能有多个 X 存在，因此我们就会有 port 6001, port 6002... 等等。
		X 启动流程测试
			1. 先来启动第一个 X 在 :1 画面中： [root@www ~]# X :1 &
			2. 输入数个可以在 X 当中执行的虚拟终端机 
				[root@www ~]# xterm -display :1 & 
				[root@www ~]# xterm -display :1 &
				那个 xterm 是必须要在 X 底下才能够执行的终端机接口。加入的参数 -display 则是指出这个 xterm 要在那个 display 使用的。这两个指令请不要一次下完！先执行一次，然后按下 [ctrl]+[alt]+[F8] 去到 X 画面中，你会发现多了一个终端机啰～ 不过，可惜的是，你无法看到终端机的标题、也无法移动到端机，当然也无法调整织端机的大小啊！我们回到刚刚的 tty1 然后再次下达 xterm 指令，理论上应该多一个终端机，去到 tty8 查阅一下。唉～没有多出一个终端机啊？ 这是因为两个织端机重迭了～我们又无法移劢终端机，所以只看到一个。
			3. 在输入不同的 X client 观察观察，分别去到 tty8 观察喔！ [root@www ~]# xclock -display :1 &
				跟前面一样的，我们又多执行了两个 X client ，其中 xclock 会显示时钟，而 xeyes 则是会出现一双大眼睛来盯着光标！
			4. 输入可以管理的 window manager 
				[root@www ~]# twm -display :1 &
				回到 tty1 后，用最简单的 twm 这个窗口管理员来管理我们的 X 吧！输入之后，去到 tty8 看看，用鼠标移动一下终端机看看？可以移动了吧？也可以缩小放大窗口啰～同时也出现了标题提示啰～也看到两个终端机啦！ 现在终于知道窗口管理员的重要性了吧？
		我是否需要启用 X Window System	
	X Server 配置文件解析与设定
		基本上，X server 的配置文件都是预设放置在 /etc/X11 目录下，而相关的显示模块或上面提到的总总模块，则主要放置在 /usr/lib/xorg/modules 底下。比较重要的是字型文件与芯片组，她们主要放置在:
			提供的屏幕字体: /usr/share/X11/fonts/
			显示适配器的芯片组: /usr/lib/xorg/modules/drivers/
		在 CentOS 底下，我们可以透过 chkfontpath 这个指令来取得目前系统有的字型档案目录。 这些都要透过一个统一的配置文件来规范，那就是 X server 的配置文件啦。这个配置文件的档名就是 /etc/X11/xorg.conf 喔！
		解析 xorg.conf 设定
			如果你想要知道到底你用的 X Server 版本是第几版，可以使用 X 指令来检查喔！
				[root@www ~]# X -version
			因为是 Xorg 这个 X server ，因此我们的配置文件档名为 /etc/X11/xorg.conf 这一个哩。这个档案的内容是分成数个段落的，每个段落以 Section 开始，以 EndSection 结束， 里面含有该 Section (段落) 的相关设定值.
			至于常见的 section name 主要有:
				1. Module: 被加载到 X Server 当中的模块 (某些功能的驱动程序)；
				2. InputDevice: 包括输入的 1. 键盘的格式 2. 鼠标的格式，以及其他相关输入设备；
				3. Files: 设定字型所在的目录位置等；
				4. Monitor: 监规器的格式， 主要是设定水平、垂直的更新频率，与硬件有关；
				5. Device: 这个重要，就是显示适配器芯片组的相关设定了；
				6. Screen: 这个是在屏幕上显示的相关分辨率与颜色深度的设定项目，与显示的行为有关；
				7. ServerLayout: 上述的每个项目都可以重复设定，这里则是此一 X server 要取用的哪个项目值的设定啰。	
		X Font Server (XFS) 与加入额外中文字形
			与 X 有关的配置文件主要是 /etc/X11/xorg.conf 这个主配置文件，但是刚刚上头解析这个档案时，在 Files 的部分我们还提到了 X Font Server (XFS) 这个服务喔！这个是啥咚咚？这个服务的目的在提供 X server 字型库啦！ 也就是说， X server 所使用的字型其实是 XFS 这个服务所提供的，因此没有启动 XFS 服务时，你的 X server 是无法顺利启动的喔！
			这个 XFS 的主配置文件在 /etc/X11/fs/config ，而字型文件则在 /usr/share/X11/fonts/ ，这里再次给他强调一下。 至于启动的脚本则在 /etc/init.d/xfs 啰
			可以使用 chkfontpath 这个指令来列出目前支持的字型档案，也可以直接修改呢！
		配置文件重建与显示器参数微调			
			你可以使用 root 的身份这样执行： [root@www ~]# Xorg -configure :1
			此时 X 会主动的以内建的模块进行系统硬件的探索，并将硬件与字型的侦测结果写入 /root/xorg.conf.new 这个档案里面去，这就是 xorg.conf 的重制结果。不过，这个新建的档案不见得真的能够启动 X server ， 所以我们必须要使用底下的指令来测试一下这个新的配置文件是否能够顺利的运作： [root@www ~]# X -config /root/xorg.conf.new :1
			关于屏幕分辨率与更新率
				[root@www ~]# gtf 水平像素 垂直像素 更新频率 [-xv] 
				选项与参数： 
					水平像素：就是分辨率的 X 轰 
					垂直像素：就是分辨率癿 Y 轰 
					更新频率：与显示器有关，一般可以选择 60, 75, 80, 85 等频率 
					-x ：使用 Xorg 配置文件的模式输出，这是默认值 
					-v ：显示侦测的过程
				可以将该指令的输出结果拷贝到/etc/X11/xorg.conf中的Monitor部分
		如何重新启动 X
			最简单在 X Window System 下，直接按下 [alt]+[ctrl]+[backspace<--] 即可， 也可以 init 3 再 init 5，也可以关闭 X 后，再 startx 启动等等。
				
			
	
第二十五章、 Linux 备份策略
	备份要点
		备份资料的考虑
			造成系统损毁的问题-硬件问题
			造成系统损毁的问题-软件问题
			主机角色不同，备份任务也不同
			备份因素考虑
				备份哪些档案：
				选择什么备份的媒介：
				考虑备份的方式：
				备份的频率：
				备份使用的工具为何：
		哪些 Linux 数据具有备份的意义
			具有备份意义的档案通常可以粗分为两大类，一类是系统基本设定信息、一类则是类似网络服务的内容数据。
			操作系统本身需要备份的档案
				/etc/ 整个目录
				/home 整个目录
				/var/spool/mail
				/boot
				/root
				如果你自行安装过其他的套件，那么 /usr/local/ 或 /opt 也最好备份一下！
			网络服务的数据库方面
				软件本身的配置文件案，例如：/etc/ 整个目录，/usr/local/ 整个目录
				软件服务提供的数据，以 WWW 及 MySQL 为例： WWW 资料：/var/www 整个目录或 /srv/www 整个目录，及系统的用户家目录 MySQL ： /var/lib/mysql 整个目录
				其他在 Linux 主机上面提供的服务之数据库档案！
			推荐需要备份的目录：
				/boot
				/etc
				/home
				/root
				/usr/local(或者是 /opt 及 /srv 等)
				/var(注：这个目录当中有些暂存目录则可以不备份！)
			不需要备份的目录：
				/dev ：这个随便你要不要备份
				/proc：这个真的不需要备份啦！
				/mnt 与 /media：如果你没有在这个目录内放置你自己系统的东西，也不需要备份
				/tmp ：干嘛存暂存档！不需要备份！
		备份用储存媒体的选择
			异地备援系统
			储存媒体的考虑
			备份速度要求 -- 思考硬盘用途：
			储存容量 -- 磁带备份考虑：
			经费与数据可靠性 -- DVD 的使用，可保存 10 年左右：
	备份的种类、频率与工具的选择
		完整备份之累积备份 (Incremental backup)
			还原的考虑
			累积备份的原则
				所谓的累积备份，指的是在系统在进行完第一次完整备份后，经过一段时间的运作， 比较系统与备份文件之间的差异，仅备份有差异的档案而已。而第二次累积备份则与第一次累积备份的数据比较， 也是仅备份有差异的数据而已。
			累积备份使用的备份软件
				完整备份常用的工具有 dd, cpio, dump/restore 等等。因为这些工具都能够备份装置与特殊档案！ dd 可以直接读取磁盘的扇区 (sector) 而不理会文件系统，是相当良好的备份工具！不过缺点就是慢很多！ cpio 是能够备份所有档名，不过，得要配合 find 或其他找文件名的指令才能够处理妥当。以上两个都能够进行完整备份， 但累积备份就得要额外使用脚本程序来处理。可以直接进行累积备份的就是 dump 这个指令啰！
		完整备份之差异备份 (Differential backup)
			差异备份与累积备份有点类似，也是需要进行第一次的完整备份后才能够进行。只是差异备份指的是：每次的备份都是与原始的完整备份比较的结果。所以系统运作的越久，离完整备份时间越长， 那么该次的差异备份数据可能就会越大
			差异备份常用的工具与累积备份差不多！因为都需要完整备份嘛！如果使用 dump 来备份的话，那么每次备份的等级 (level) 就都会是 level 1 的意思啦！当然啦，你也可以透过 tar 的 -N 选项来备份喔！
			也可以透过 rsync 来进行镜像备份喔！ 这个 rsync 可以对两个目录进行镜像 (mirror) ，算是一个非常快速的备份工具
		关键数据备份
			备份关键数据鸟哥最爱使用 tar 来处理了！
	鸟哥的备份策略
		鸟哥就将我的备份分为两大部分，一个是每日备份经常性变动的重要数据， 一个则是每周备份就不常变动的信息。这个时候我就写了两个简单的 scripts ，分别来储存这些数据。 所以针对鸟哥的『鸟站』来说，我的备份策略是这样的：
			1. 主机硬件：使用一个独立的 filesystem 来储存备份数据，此 filesystem 挂载到 /backup 当中；
			2. 每日进行：目前仅备份 MySQL 数据库；
			3. 每周进行：包括 /home, /var, /etc, /boot, /usr/local 等目录与特殊服务的目录；
			4. 自动处理：这方面利用 /etc/crontab 来自动提供备份的进行；
			5. 异地备援：每月定期的将数据分别 (a)刻录到光盘上面 (b)使用网络传输到另一部机器上面。
		每周系统备份的 script
		每日备份资料的 script
		远程备援的 script		
			使用 FTP 上传备份数据
			使用 rsync 上传备份数据
	灾难复原的考虑
		硬件损毁，且具有完整备份的数据时
		由于软件的问题产生的被攻破资安事件

	
			
第二十六章、Linux 核心编译与管理
	编译前的任务：认识核心与取得核心原始码
		什么是核心 (Kernel)
			Kernel
				当系统读完 BIOS 并加载 MBR 内的开机管理程序后，就能够加载核心到内存当中。然后核心开始侦测硬件， 挂载根目彔并取得核心模块来驱动所有的硬件，之后呼叫 /sbin/init 就能够依序启动所有系统所需要的服务了！
				这个核心档案通常被放置成 /boot/vmlinuz ，不过也不见得， 因为一部主机上面可以拥有多个核心档案，只是开机的时候仅能选择一个来加载而已。
			核心模块 (kernel module) 的用途
				将一些不常用的类似驱动程序的咚咚独立出核心，编译成为模块，然后， 核心可以在系统正常运作的过程当中加载这个模块到核心的支持。如此一来， 我在不需要更动核心的前提之下，只要编译出适当的核心模块，并且加载他，呵呵！我的 Linux 就可以使用这个硬件啦！简单又方便！
		更新核心的目的
			核心编译的可能目的
				新功能的需求：
				原本核心太过臃肿：
				与硬件搭配的稳定性：
				其他需求 (如嵌入式系统)：
		核心的版本
			我们要使用最新的核心来重新编译核心时，大多就是使用那种偶数的核心版本啦！不过这里还是要再提一遍！就是『 2.4.x 与 2.6.x 是两个具有相当大差异的核心版本， 两者之间使用到的函式库基本上已经不相同了，所以在升级之前，如果你的核心原本是 2.4.xx 版，那么就升级到 2.4.xx 版本的最新版，不要由 2.4.xx 直接升级到 2.6.xx 版，否则到时可能会欲哭无泪～～』
			2.4.xx 与 2.6.xx 的比较中，并不是 2.6.xx 就一定比 2.4.xx 还要新，因为这两种版本同时在进行维护与升级的工作
		核心原始码的取得方式
			每个核心的 patch 仅有针对前一版的核心来分析而已， 所以，万一你想要由 2.6.27 升级到 2.6.30 的话，那么你就得要下载 patch-2.6.28, patch-2.6.29, patch-2.6.30 等档案，然后『依序』一个一个的去进行 patch 的动作后， 才能够升级到 2.6.30 喔！
			但是，如果你想要升级 2.6.30 的修改版本到 2.6.30.3 时，由于修改版本是针对 2.6.30 来制作的， 因此你只要下载 patch-2.6.30.3 来直接将 2.6.30 升级至 2.6.30.3 即可。但反过来说，如果你要从 2.6.30.2 升级到 2.6.30.3 呢？很抱歉的是，并没有 2.6.30.2 到 2.6.30.3 的补丁档案，所以你必须要将 2.6.30.2 还原至 2.6.30， 然后才能使用 patch-2.6.30.3 来升级 2.6.30 喔！注意这个差异！
		核心原始码的解压缩/安装/观察
			2.6.x 核心原始码一般建议放置于 /usr/src/kernels/ 目录底下
			核心原始码下的次目录
				arch ：与硬件平台有关的项目，大部分指的是 CPU 的类别，例如 x86, x86_64, Xen 虚拟支持等；
				block ：与成组训备较相关的设定数据，区块数据通常指的是大量储存媒体！还包括类似 ext3 等文件系统的支持是否允许等。
				crypto ：核心所支持的加密的技术，例如 md5 或者是 des 等等；
				Documentation ：与核心有关的一堆说明文件，若对核心有极大的兴趣，要瞧瞧这里！
				drivers ：一些硬件的驱动程序，例如显示适配器、网络卡、PCI 相关硬件等等；
				firmware ：一些旧式硬件的微脚本 (韧体) 数据；
				fs ：核心所支持的 filesystems ，例如 vfat, reiserfs, nfs 等等；
				include ：一些可让其他过程调用的标头 (header) 定义数据；
				init ：一些核心初始化的定义功能，包括挂载与 init 程序的呼叫等；
				ipc ：定义 Linux 操作系统内各程序的沟通；
				kernel ：定义核心的程序、核心状态、线程、程序的排程 (schedule)、程序的讯号 (signle) 等
				lib ：一些函式库；
				mm ：与内存单元有关的各项数据，包括 swap 与虚拟内存等；
				net ：与网络有关的各项协议数据，还有防火墙模块 (net/ipv4/netfilter/*) 等等；
				security ：包括 selinux 等在内的安全性设定；
				sound ：与音效有关的各项模块；
				virt ：与虚拟化机器有关的信息，目前核心支持的是 KVM (Kernel base Virtual Machine)
	核心编译的前处理与核心功能选择
		硬件环境检视与核心功能要求
		保持干净原始码： make mrproper
			我们可以透过底下的方式来处理掉这些编译过程的目标档案以及配置文件： 
				[root@www linux-2.6.30.3]# make mrproper
			请注意，这个动作会将你以前进行过的核心功能选择档案也删除掉， 所以几乎只有第一次执行核心编译前才进行这个动作，其余的时刻，你想要删除前一次编译过程的残留数据， 只要下达： [root@www linux-2.6.30.3]# make clean
			因为 make clean 仅会删除类似目标文件之类的编译过程产生的中间档案，而不会删除配置文件！
		开始挑选核心功能： make XXconfig
			不知道你有没有发现 /boot/ 底下存在一个名为 config-xxx 的档案？那个档案其实就是核心功能列表文件！ 我们底下要进行的动作，其实就是作出该档案！而我们后续小节所要进行的编译动作，其实也就是透过这个档案来处理的！ 核心功能的挑选，最后会在 /usr/src/kernels/linux-2.6.30.3/ 底下产生一个名为 .config 的隐藏档， 这个档案就是 /boot/config-xxx 的档案啦！那么这个档案如何建立呢？你可以透过非常多的方法来建立这个档案！ 常见的方法有：(注1)
				make menuconfig 最常使用的，是文本模式底下可以显示类似图形接口的方式，不需要启劢 X Window 就能够挑选核心功能选单！
				make oldconfig 透过使用已存在的 ./.config 档案内容，使用该档案内的设定值为默认值，只将新版本核心内的新功能选项列出让用户选择， 可以简化核心功能的挑选过程！对于作为升级核心原始码后的功能挑选来说，是非常好用的一个项目！
				make xconfig 透过以 Qt 为图形接口基础功能的图形化接口显示，需要具有 X window 的支持。例如 KDE 就是透过 Qt 来设计的 X Window，因此你如果在 KDE 画面中，可以使用此一项目。
				make gconfig 透过以 Gtk 为图形接口基础功能的图形化接口显示，需要具有 X window 的支持。例如 GNOME 就是透过 Gtk 来设计的 X Window，因此你如果在 GNOME 画面中，可以使用此一项目。
				make config 最旧式的功能挑选方法，每个项目都以条列式一条一条的列出让你选择，如果设定错误只能够再次选择，很不人性化啊！
			关于整个核心功能的选择上面，建议你可以这样思考：
				『肯定』核心一定要的功能，直接编译进核心内；
				『可能在未来会用到』的功能，那么尽量编译成为模块；
				『不知道那个东西要干嘛的，看 help 也看不懂』的话，那么就保留默认值，或者将他编译成为模块；
		核心功能细项选择
			General setup
				与 Linux 最相关的程序互动、核心版本说明、是否使用发展中程序代码等信息都在这里设定的。 这里的项目主要都是针对核心与程序之间的相关性来设计的，基本上，保留默认值即可！
					loadable module + block layer
					CPU 的类型与功能选择			
					电源管理功能
					一些总线 (bus) 的选项
					编译后执行档的格式
					核心的网络功能
					各项装置的驱动程序
					文件系统的支援
					核心黑客、信息安全、密码应用
					虚拟化与函式库
				Linux 核心已经主动的纳入虚拟化功能喔！而 Linux 认可的虚拟化使用的机制为 KVM (Kernel base Virtual Machine)
			事实上，刚刚我们所做的设定只要在离开时选择 SAVE ，那么这些项目 通通会记录到目前这个目录下的 .config 档案内。 而我们也可以使用上面提到的 Save Configuration 这个项目来将刚刚做完的设定储存成另外的档案， 做成这个档案的好处是，你可以在下次在其他版本的核心作选择时，直接以 Load 来将这个档案的设定项目读入，这样可以减少你还要重新挑选一遍的困境啊！
	核心的编译与安装
		编译核心与核心模块
			核心与核心模块需要先编译起来，而编译的过程其实非常简单，你可以先使用『 make help 』去查阅一下所有可用编译参数， 就会知道有底下这些基本功能： 
				[root@www linux-2.6.30.3]# make vmlinux <==未经压缩的核心 
				[root@www linux-2.6.30.3]# make modules <==仅核心模块 
				[root@www linux-2.6.30.3]# make bzImage <==经压缩过的核心(预设) 
				[root@www linux-2.6.30.3]# make all <==进行上述的三个动作
			我们常见的在 /boot/ 底下的核心档案，都是经过压缩过的核心档案，因此，上述的动作中比较常用的是 modules 于 bzImage 这两个
		实际安装模块
			我们知道模块是放置到 /lib/modules/$(uname -r) 目录下的，那如果同一个版本的模块被反复编译后来安装时，会不会产生冲突呢？举例来说，鸟哥这个 2.6.30.3 的版本第一次编译完成且安装妥当后，发现有个小细节想要重新处理，因此又重新编译过一次，那两个版本一模一样时， 模块放置的目录会一样，此时就会产生冲突了！如何是好？有两个解决方法啦：
				先将旧的模块目录更名，然后才安装核心模块到目标目录去；
				在 make menuconfig 时，那个 General setup 内的 Local version 修改成新的名称。
			鸟哥建议使用第二个方式，因为如此一来，你的模块放置的目录名称就不会相同，这样也就能略过上述的目录同名问题啰！
		开始安装新核心与多重核心选单 (grub)
			我们将同时保留旧版的核心，并且新增新版的核心在我们的主机上面。
			移动核心到 /boot 且保留旧核心档案
			建立相对应的 Initial Ram Disk (initrd)
				由于鸟哥的系统使用 SATA 磁盘，加上刚刚 SATA 磁盘支持的功能并没有直接编译到核心去，所以当然要使用 initrd 来加载才行！ 使用如下的方法来建立 initrd 吧！让得搭配正确的核心版本喔！ 
					[root@www ~]# mkinitrd -v /boot/initrd-2.6.30.3vbird.img 2.6.30.3vbird
			编辑开机选单 (grub)
			重新以新核心开机、测试、修改
	额外(单一)核心模块编译
		核心模块依据不同的版本，被分别放置到 /lib/modules/$(uname -r)/kernel/ 目录中，各个硬件的驱动程序则是放置到 /lib/modules/$(uname -r)/kernel/drivers/ 当中
		编译前注意事项
			由于我们的核心原本就有提供很多的核心工具给硬件开发商来使用， 而硬件开发商也需要针对核心所提供的功能来设计他们的驱动程序模块，因此， 我们如果想要自行使用硬件开发商所提供的模块来进行编译时，就需要使用到核心所提供的原始档当中， 所谓的头文件案 (header include file) 来取得驱动模块所需要的一些函式库或标头的定义啦！ 也因此我们常常会发现到，如果想要自行编译核心模块时，就得要拥有核心原始码嘛！
		单一模块编译
			硬件开发商提供的额外模块
				如果你的硬件开发商有提供驱动程序的话，那么真的很好解决，直接下载该原始码，重新编译， 将他放置到核心模块该放置的地方后就能够使用了
			利用旧有的核心原始码进行编译
				我们先到目前的核心原始码所在目录下达 make menuconfig ， 然后将 NTFS 的选项设定成为模块，之后直接下达： make fs/ntfs/ 那么 ntfs 的模块 (ntfs.ko) 就会自动的被编译出来了！ 然后将该模块复制到 /lib/modules/2.6.30.3vbird/kernel/fs/ntsf/ 目录下， 再执行 depmod -a ，呵呵～就可以在原来的核心底下新增某个想要加入的模块功能啰～ ^_^
			当自行编译模块时， 若你的核心有更新 (例如利用自动更新机制进行在线更新) 时，则你必须要重新编译该模块一次， 重复上面的步骤才行！因为这个模块仅针对目前的核心来编译的啊！
	核心模块管理
		核心与核心模块是分不开的，至于驱劢程序模块在编译的时候，更与核心的原始码功能分不开～ 因此，你必须要先了解到：核心、核心模块、驱动程序模块、核心原始码与头文件案的相关性， 然后才有办法了解到为何编译驱动程序的时候老是需要找到核心的原始码才能够顺利编译！ 然后也才会知道，为何当核心更新之后，自己之前所编译的核心模块会失效～
		此外，与核心模块有相关的，还有那个很常被使用的 modprobe 指令， 以及开机的时候会读取到的模块定义数据文件 /etc/modprobe.conf
		简单说明核心编译的步骤为何？
			1. 先下载核心原始码，可以从 http://www.kernel.org 或者是 distributions 的 SRPM 来着手；
			2. 以下以 Tarball 来处理，解开原始码到 /usr/src/kernels 目录下；
			3. 先进行旧数据初除的动作：『make mrproper』；
			4. 开始挑选核心功能，可以利用『make menuconfig』、『make oldconfig』、『make gconfig』等等；
			5. 清除过去的中间暂存盘资料：『make clean』
			6. 开始核心档案与核心模块的编译：『make bzImage』、『make modules』
			7. 开始核心模块的安装：『make modules_install』
			8. 开始核心档案的安装，可以使用的方式有：『make install』或者是透过手动的方式复制核心档案到 /boot/grub 当中；
			9. 建立 initrd 档案；
			10.修改 /boot/grub/menu.lst 档案；
		如果你利用新编译的核心来操作系统，发现系统并不稳定，你想要移除这个自行编译的核心该如何处理？
			首先，可以将原始码初除：rm -rf /usr/src/kernels/linux-2.6.30 
			再者，删除掉核心模块的目录： rm -rf /lib/modules/2.6.30 
			最后删除掉 /boot/ 内的核心档案与 initrd 档案，以及 /boot/grub/menu.lst 内的 title 设定即可。
	
	
	
	
		
