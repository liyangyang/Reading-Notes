前言
	这本书的组织结构
		第一章，基本网络概念。详细解释了一个程序员需要知道的关于网络和Internet的工作方式。包括Internet的一些底层协议，比如TCP/IP和UDP/IP。
		接下来的两章介绍了java编程中，对于几乎所有网络编程都至关重要的，并且很容易被误解和无用的两个部分：I/O和线程。第二章，流，研究了java的传统I/O，没有涉及新的I/O，它在短期内不会被丢弃，并且在大多数客户端应用中仍然是处理输入和输出的首选。在总体上理解java如何处理I/O是理解java如何处理网络I/O这种特殊情况的先决条件。第三章，线程，研究了多线程和同步，特殊强调了他们如何被用于同步I/O和网络服务器。
		有经验的java程序员或许可以跳过这两章，然而，第四章，Internet地址，也是至关重要的。它展示了java程序如何通过InetAddress类来和DNS服务器交互，这个类基本被所有网络程序需要。
		第五章，URIs和URLs，研究了java的URL类，一个强大的，抽象的，用于从各种不同类型的网络服务器上下载信息和文件的类。这个URL类允许你在不需要知道服务器通信所使用的协议的详细信息的情况下，连接到一个网络服务器，并下载文件或文档。它允许你使用和连接到HTTP服务器相同的代码连接到FTP服务器，或从本地磁盘读取一个文件。你也将学到更新的URI类，一个更遵循标准的，用来唯一标识资源而不是获取资源的类。
		第六章，HTTP，深度钻研了HTTP协议。主题覆盖了包括REST，HTTP头，Cookies。第七章，URLConnections，展示了如何使用URLConnection和HttpURLConnection类来不只是为了下载数据，还用来上传文档和配置连接。
		第八章到第十章讨论了java底层的用于网络访问的socket类。第八章，客户端socket，介绍了java的socket API，特别是Socket这个类。它展示了如何编写网络客户端，来和各种各样的TCP服务器交互，包括whois，dict和HTTP。第九章，服务器端socket，展示了如何使用ServerSocket来为各种各样的协议编写服务器端。最后，第十章，安全的socket，展示了如何使用SSL（Secure Socket Layer）和JSSE（Java Secure Socket Extension）来保护你的客户端-服务器端交互。
		第十一章，非阻塞I/O，介绍了新的I/O API，特别被设计用于网络服务。这些API允许程序在socket上读或写之前，断定该连接是否准备好了。这个允许一个单一的线程同时管理很多不同的连接，从而较小虚拟机的压力。新的I/O API对于不会同时打开很多连接的小型的服务器端和客户端不会有很大帮助。但是他们对于那些想要尽网络能够处理的能力和传递速度，来尽可能多的和快的传递信息的大型的服务端来说，能够提供性能改进。
		第十二章，UDP，介绍了UDP（User Datagram Protocol）和相关的用来提供快速的，不可靠的通信的DatagramPacket和DatagramSocket类。第十三章，IP广播，展示了如何使用UDP来同时和多个主机交互。


第一章 基本网络概念
	事实上，使用java来编写网络程序要比大多数其他语言简单。你必须知道的一件事是即使在一个功能完全的应用程序中，负责网络的代码也只有很小一部分。
	网络
		一个网络是一组计算机或其他设备的集合，他们之间彼此可以相互发送数据或接受数据，或多或少是实时的。
		网络中的每一个机器称为一个节点（node）。完全功能化的计算机节点也被成为主机（host）。 
		网络中的每一个节点都有一个地址，它是用来唯一标识该节点的一串字节序列。
		一个组织能够给它的计算机选择的地址是由ISP（Internet service provider）机构分发的。ISP会从四个地区性的Internet注册机构获取IP地址（北美的注册机构是ARIN（the American Regristry for Internet Numbers）），四个地区性的Internet注册机构又由ICANN（Internet Corporation for Assigned Names and Numbers）来为其分发IP地址。
		所有的现代网络都是包交换的网络，在网络上传送的数据被分割成称为包的块，并且每个包都被独立的处理。每个包都包含谁发送的它以及它要去哪的信息。
		把数据切换成独立的带有地址的报文的主要优点是很多来自不同交换设备的报文可以共用一条线路，使得构建一个网络的代价更低。使用报文的另一个好处是它可以使用校验和来检查在传输的过程中，报文是否被损坏。
		一个协议是一组精确的规则，它定义了计算机如何通信：地址的格式，数据如何切分成报文，等等。
	网络中的层
		为了向应用开发者和终端用户屏蔽网络的复杂性，网络通信的不同方面被分开到了多个层中。每个层都展示了从硬件到要传输的信息的不同程度的抽象。理论上，每一层都只和紧挨着它的上层或下层交互。将网络分层允许你修改或替换某一层中的软件而不会影响其他层，只要层之间的接口保持不变。
		标准的TCP/IP四层协议模型是：应用层，传输层（TCP/UDP），网络层（IP），主机-网络层。
		然而，在90%的情况下，你的java代码将工作在应用层，并且只需要和传输层打交道。其他的10%的情况，你将会在传输层，和应用层或网络层打交道。对于你来说，主机-网络层的复杂性被隐藏起来，这就是分层模型的关键。
		OSI（Open system interconnection）制定的7层参考模型和4层模型的不同是，它将主机-网络层分成数据链路层和物理层，在应用层和传输层中新增了表示层和会话层。对于java中的网络编程来说，OSI模型是过度的。在任何情况下，java的网络类只工作在TCP/IP网络中，并且只工作在应用层或传输层。
		主机-网络层
			主机-网络层定义了一个特定的网络接口，比如一个以太网卡或wifi天线，在它的物理连接上传送IP数据包到网络中。
			有连接不同计算机的硬件组成的主机-网络层有时候被称为网络的物理层。换句话说，java将永远看不到物理层。
			当你需要考虑主机-网络层或物理层的一个主要原因是性能。你需要根据物理环境来设计你的协议和应用，比如考虑到延迟情况等。
		网络层
			网络层协议定义了数据的位或字节如何被组织成更大的被成为报文的组，以及不同机器用来找到其他人的寻址模式。IP（Internet Protocol）是世界上最被广泛应用的网络层协议，也是java唯一理解的网络层协议。
			事实上，该层有两个协议：IPV4，使用32位地址；IPV6，使用64位地址，并且添加了一些用来辅助路由的技术功能。虽然这是两个不同的协议，同一网络中，他们在没有特别网关或/和隧道协议的情况下，不能相互操作，java为你屏蔽了基本所有的不同。
			在IPV4和IPV6中，用来传输数据的包被称为数据报。每个IPV4数据报包含一个20-60字节长度的头和最大65515字节的数据。IPV4数据报中的所有的位和字节都是big-endian的，最高位到最低位是从左到右。
			除了路由和寻址，Internet层的第二个目的是允许不同类型的主机-网络层相互通信。Internet路由器在WiFi和Ethernet，Ethernet和DSL，DSL和光纤之间翻译。如果没有互联层或其他像他一样的东西，每个计算机将只能和那些和他们共享特定类型网络的计算机通信。互联层的职责是连接那些使用多样化的协议的多样化的网络。
		传输层
			原生的数据报有些不足。最值得提起的是，没有保证他们将会被交付。即使被交付，他们也可能在传输的过程中出错。头部校验和只能检测到头部的损坏，而不能检测到数据部分的损坏。即使数据报无损的到达，也不能保证他们到达的顺序是他们发送的顺序，不同的数据报可能会按着源到目的地的不同的路由传递。数据报A在数据报B之前发送并不意味着数据报A会比数据报B提前到达。
			传输层的职责是确保包被按照他们发送的顺序接受，并且没有数据丢失和损坏。如果一个包丢失了，传输层将要求发送者重新发送这个包。在这一层有两个主要的协议：第一个，TCP（Transmission control protocol），允许丢失或损坏数据的重传，并且按数据发送的顺序传送字节。第二个协议，UDP（User datagram protocol），允许接收者检测损坏的包，但不保证包被按正确的顺序交付。然而，UDP通常要比TCP快。TCP被称为可靠的协议，UDP被称为不可靠的协议。
		应用层
			负责交付数据给用户的层被称为应用层。应用层决定在数据传输之后如何处理它。
	IP，TCP和UDP
		IP，Internet协议。首先，它必须是健壮的，因此，IP允许在两个点之间有多个路由，以便路由数据包在有路由损坏的环境中。其次，IP需要是开放的和平台独立的。
		因为两个点之间有多个路由路径，并且两个点之间的最快路径可能随时间改变，由于网络交通或其他因素的原因，组成特定数据流的包可能使用不同的路由路径。更进一步，如果他们最终能够到达，他们可能不是按他们被发送的顺序到达。为了在基本模式上的改进，TCP被放置在IP的上层，来允许连接的两端能够通知包的接受，和请求丢失的或损坏的包的重传。更进一步，TCP允许所有的包在接受端按照他们被发送的顺序重新组合起来。
		TCP承担了相当大的工作。因此，如果数据的顺序不是很重要，并且如果个别包的丢失不会损坏数据流，包有时候可以使用UDP来传送，它将没有TCP提供的那些保证。UDP是一个不可靠的协议，它将不保证包会到达目的地或保证他们将会按照他们发送的顺序到达。更进一步，在应用层，错误纠正代码将是UDP数据流的一部分，来解决数据丢失。
		有很多其他协议可以运行在IP之上。最常用的是ICMP（Internet control manage protocol），它使用原生的IP数据报来在主机之间回复错误消息。这个协议最有名的应用是ping协议。java不支持ICMP，也不支持发送原生的IP数据包。java唯一支持的协议是TCP和UDP，以及基于这两个协议的应用层协议。其他的传输层，互联层和更底层的协议，比如ICMP，IGMP，ARP，RARP，RSVP和其他的，只能通过连接本地代码来在java程序中实现。
		IP地址和域名
			IPV4使用4个字节来表示地址。IPV6使用16个字节来表示地址。IPV6地址通常被写成8个由冒号分割的4个16进制数字，比如FEDC:BA98:7654:3210:FEDC:BA98:7654:3210。开头的0可以被省略。两个连续的冒号，在任何一个地址中只能出现一次，标识多个全为0的块，比如FEDC:0000:0000:0000:00DC:0000:7076:0010可以被写成更压缩的形式FEDC::DC:0:7076:10。在IPV4和IPV6混合使用的网络中，IPV6的最后4个字节可以被写成IPV4形式的由点分割的4部分地址，比如FEDC:BA98:7654:3210:FEDC:BA98:7654:3210可以被写成FEDC:BA98:7654:3210:FEDC:BA98:118.84.50.16.
			当java程序访问网络时，他们需要同时处理数字地址和他们相应的主机名。用来完成这个的方法是由类java.net.InetAddress提供的。
			一些计算机，特别是服务器，有固定的地址。其他的，特别是本地网络和无线连接中的客户端，每次启动时获取一个不同的地址，通常由DHCP服务提供。多数时候，你可能只需要记住IP地址会随着时间改变，并且不要编写那些以来某个系统有一个固定的IP地址的代码。比如，当保存一个应用状态时，不要保存本地IP地址。相替代的，每次程序启动时去查询它。IP地址在程序正在运行时也会改变（比如DHCP租赁过期），这个很少会发生，但是有这个可能，所以你可能想要在每次需要时都检测当前的IP地址，而不是缓存它。
			很多地址块和模式是特殊的。所有以10.，172.16.到172.31.，192.168.开头的IPV4地址都是未分配的。他们被用在内部网络中，没有使用这些块的地址的主机被允许出现在全局的Internet上。这些不可被路由的地址用来构建不会被Internet看到的私有网络是很有用的。以127开头的（通常是127.0.0.1）IPV4地址通常是本地回环地址。这些地址通常指向本地计算机，不管他们在哪个计算机上运行。这个地址对应的主机名通常是localhost。在IPV6中，0：0：0：0：0：0：0：1（：：1）是回环地址。地址0.0.0.0通常指向起始主机，可以仅被用来在作为源地址，而不能作为目的地址。相似的，任何以0.开头的IPV4地址被假定为指向相同本地网络中的一个主机。
			IPV4地址中，4个字节都是用相同数字的地址（比如255.255.255.255），是广播地址。发送到这个地址的包被本地网络中的所有节点都接收，他们不会被路由到本地网络之外。这通常被用来发现。比如，当一个短暂的客户端，比如笔记本，启动时，它发送一个特定的消息到255.255.255.255来查找本地的DHCP服务。本地网络中的所有节点都收到这个包，但是只有DHCP服务器回复。特别的，它将本地网络的配置信息发送给笔记本，包括这个笔记本将要使用的IP地址和DNS服务器的地址。
		端口
			如果每台计算机都最多只做一件事情，那么地址就足够了，但是，现代计算机可以同时做不同的事情，这个通过端口来实现。每一个有一个IP地址的计算机都有数千个逻辑地址（精确的说，对于每一个传输层协议有65535个端口）。他们完全是计算机内存中的抽象，而不是以像USB接口那样，以物理形式表示。每个端口以一个从1到65535之间的数字表示。每个端口能被分配给一个特定的服务。
			从1到1023之间的端口号为那些知名的服务保留，比如finger，FTP，HTTP，IMAP。在Unix系统中，包括linux和max os x，只有以root运行的程序才能从这些端口接收数据，但是所有的程序都能像这些端口发送数据。在windows中，任何使用这些端口的程序不需要特殊的权限。在Unix系统中，一个已经分配了的，相当完整的列表被存储在文件/etc/services中。
	Internet
		Internet是世界上最大的基于Ip的网络。
		Internet不只是基于IP的网络，而且是最大的一个。其他的基于IP的网络称为internet，它使用小写的i：比如一个高度安全的，没有连接到全局的Internet的内部网络。Intranet松散的描述了一个共同的实践，即将很多的数据放在内部web服务器上，这些数据不会被本地网络之外的用户看到。
		除非你正在工作于一个高度安全的，物理上没有连接到更广阔的网络的环境，那么很可能你正在使用的internet就是Internet。
		Internet地址块
			每个地址块有个固定的前缀来表示网络地址。
		网络地址转换
			由于原生ip地址的短缺和需求的增加，今天的大多数网络都使用NAT（Network address translate）。在基于NAT的网络中，大多数的节点只使用本地的，不可路由的地址，他们选取自10.x.x.x，172.16.x.x到172.16.x.x，或192.168.x.x。将本地网络连接到ISP的路由器将这些本地地址转换为一个更小的集合的可路由的地址。
			其实，如何跟踪每个连接来自哪里或要到哪里去，对于一个java程序员不是特别重要。只要你的机器被恰当的配置，这些过程基本是透明的。你只需要知道内部地址和外部地址可能是不同的。
			最终，IPV6会将这些都废弃掉。NAT将会是没有意义的，虽然防火墙仍然是有用的。子网仍然存在来用于路由，但是他们可能将会变得更大。
		防火墙	
			位于Internet和本地网络之间，用来检查所有进来或出去的数据，以确保他们是干净的软件和硬件，称为防火墙。
			防火墙通常是连接本地网络和外部Internet的路由器的一部分，并且可能执行一些其他的任务，比如网络地址转换。防火墙也可能是一个单独的机器。现代操作系统，像Mac os x和Red hat linux通常都有内置的个人防火墙，仅用来检测发往那台机器的流量。不管那种方式，防火墙的职责就是检测通过其网络接口发进来或出去的每个包，通过一个规则集来决定接受它或拒绝它。
			过滤通常是基于网络地址和端口。比如，出去的ssh连接是允许的，但进来的ssh连接是不被允许的。更智能的防火墙可能会查看每个包的内容来决定是否接受或拒绝他们。
		代理服务器
			代理服务器是和防火墙相关的。如果防火墙是禁止本地网络的主机直接连接到外部的世界，那么代理服务器就是作为一个中间人。因此，一个被防火墙禁止连接到外部网络的机器，可以通过发送一个获取web页面的请求到一个本地的代理服务器，来代替直接向远程web服务器请求该web页面。代理服务器将向远程web服务器请求该web页面，然后将回复转发给原来的请求者。使用代理服务器的一个安全方面的优点是外部的主机只能找到代理服务器。他们不知道内部机器的名字和ip地址。
			然而防火墙通常在网络层或互联层进行处理，代理服务器则通常在应用层进行处理。一个代理服务器会对一些应用层协议有一个详细的理解，比如HTTP和FTP。一个值得注意的意外是SOCKS代理服务器，它在传输层进行处理。能代理所有的TCP和UDP连接，而不管应用层协议。通过代理服务器的包能被检测来确保他们包含和他们类型相适应的数据。比如，FTP包被看起来包含Telnet数据将会被拒绝。
			只要所有对Internet的访问都是通过代理服务器转发的，访问就能被仅仅的控制。
			代理服务器也能被用来实现本地缓存。
			代理服务器的一个最大的问题是他们不能和所有的协议合作，只能和一部分协议合作。一般的建立起来的协议，像HTTP，FTP和SMTP被允许通过，但是新的协议，像BitTorrent不被允许。在快速改变的Internet的世界中，这是一个明显的缺点。对于java程序员来说，这也是一个明显的缺点，因为它限制了自定义协议的效用。因此，一些开发人员通过使用HTTP来调整他们的协议，最显著的是使用SOAP。然而，这将在安全方面有一个明显的副作用。防火墙在那就是为了这个原因，而不仅仅是为了麻烦程序员。
			运行在web浏览器内部Applet应用通常使用web浏览器的代理服务器，虽然他们可以在Java Control Panel中覆盖它。独立的java应用可以指明他们使用的代理服务器，通过设置socksProxyHost和socksProxyPort属性（如果你正在使用一个SOCKS代理服务器），或者通过设置http.proxySet, http.proxyHost, http.proxyPort, https.proxySet, https.proxyHost, https.proxyPort, ftpProxySet, ftpProxyHost, ftpProxyPort, gopherProxySet, gopherProxyHost, 和gopherProxyPort系统属性（如果你正在使用一个特定协议的代理）。你可以使用-D选项来在命令行设置系统属性。
	客户端/服务器端模型
		一个更有说服力的区别是客户端初始化一个会话，服务器端等待客户端向它初始化一个会话。
		并不是所有的应用都很容易的符合客户端/服务器端模型。比如，一个网络游戏中的两个玩家对等的发送和接受数据。这种类型的连接称为对等网络（peer to peer）。电话系统是对等网络的经典例子。
		在java的核心网络API中没有显式的对等通信。然而，应用可以很容易的通过多种方法来提供对等通信，最常用的方式是同时扮演服务器端和客户端。另一种方法，对等的点之间可以通过一个中间服务程序来相互通信，该中间服务程序将在对等的点之间转发数据。这个方法灵巧的解决了两个对等的点如何找到对方的问题。
	Internet标准
		虽然这个世界上有很多标准组织，但是有两个生产和应用层网络编程和协议相关的标准的两个组织是IETF（Internet Engineering Task Force）和W3C（World Wide Web Consortium）。IETF是相对的非正式的，民主的和任何有兴趣的第三方合作。它的标准是基于“粗糙的一致和可运行的代码”，并且倾向于遵循而不是引领实现。IETF标准包括TCP/IP，MIME，和SMTP。W3C，相反的，是一个卖方组织，被付费成员组织所控制，并且明确的排除个人的参与。在很多地方，W3C倾向于定义标准先于实现。W3C标准包括HTTP，HTML，和XML。
		IETF RFCs
			IETF标准和近似标准被以RFC（Requests for Comments）的形式发布。不管名字，一个发布的RFC是一个完成的工作。它可能会被一个新的RFC废弃或替代，但是它将不会被改变。IETF用于修订和向开发人员开放的工作文档称为“Internet drafts”。
			RFC是标准Internet协议，比如FTP，的从基本想法到详细规范的范围内的信息化的文档。在很多情况下，RFC，尤其是面向标准的RFC，是很技术性的，浮夸的和近乎不可理解的。虽然如此，他们仍然是一个特定协议的，唯一的，完整的，可信赖的信息来源。
			大多数RFC的提议起始于一个人或组织有一个好主意，并且建立了一个原型。这个原型难以置信的重要。在一些东西成为IETF标准之前，它必须确实存在，并且可以工作。这个需求确保了IETF标准至少是可行的。
			IETF通常工作在幕后，来编纂和标准化一些已经存在的实践。
		W3C推荐
			虽然W3C的标准化进程（大量的邮件列表中的工作草稿产生一个最终的规范）和IETF进程很相似。
			W3C标准有5个基本的等级：
				笔记
				工作草稿
				候选推荐
				建议推荐
				推荐


第二章 流
	java的I/O是构建在流之上的。输入流读取数据，输出流写出数据。不同的流类，像java.io.FileInputStream和sun.net.TelnetOutputStream，从特定的数据源读取或写出数据。然而，所有的输出流都有相同的基本方法来写出数据，所有的输入流都有相同的基本方法来读入数据。当一个流被创建以后，你就可以忽略你正在读取或写入的东西的细节了。
	过滤流能够被串联在一个输入流或一个输出流上。过滤器能够修改它读取或写出的数据，比如，加密或压缩它，或这是简单的提供额外的方法来将他们读取或写出的数据转换成其他格式。比如，java.io.DataOutputStream类提供了一个方法来将int转换成4个字节，并且将这4个字节输出到它底层的输出流。
	Reader和Writer能够被串联在输入流或输出流上，来允许程序读取或写出文本（比如字符）而不是字节。如果使用恰当，reader和writer能够处理很大范围内的字符编码，包括多字节字符集，比如UTF-8。
	流是同步的，那就是，当程序请求流来读取或写出一段数据时，它在做其他事情之前，需要等待数据被读取或写出完成。java也通过channel和buffer来提供非阻塞I/O。非阻塞I/O有些复杂，但是可以使大容量的应用，比如web服务器，更快。
	输出流
		java最基本的输出类是java.io.OutputStream。这个类提供了写出数据需要的基础的方法，他们是：
			public abstract void write(int b) throws IOException
			public void write(byte[] data) throws IOException
			public void write(byte[] data, int offset, int length) throws IOException
			public void flush() throws IOException
			public void close() throws IOException
		OutputStream的子类使用这些方法写出数据到特定的媒介上。
		OutputStream的基础方法是write（int b）。这个方法使用一个0到255之间的int值作为参数，将其相应的字节写出到输出流中去。这个方法声明为抽象的，是因为子类需要改变它来处理相应的媒介。比如，ByteArrayOutputStream实现这个方法来用java代码拷贝字节到它的数组中。
		需要注意的是，虽然这个方法使用int类型的参数，它实际上是写出一个无符号的byte。java没有无符号的字节数据类型，所以使用int来代替。无符号字节和有符号字节的唯一区别是如何被解释。他们都是由8位组成，当你使用write（int b）来向一个网络连接写出数据时，只有8个字节被写出。如果传递给write（int b）的参数超出了0-255的范围，那么只有最低位的8位被写出，剩下的3个字节被忽略。
		一次写出一个单一字节通常是低效的。比如每一个tcp分组至少包含40个字节的负载来用于路由和错误纠正。如果每次发送一个字节，那么你需要填充网路41次，增加了主机-网络层协议的负担，这将会更糟。因此，大多数TCP/IP实现都会缓存数据。那就是他们在内存中累积数据，只有当累积到指定数量或当指定的时间过去时，一次将这些数据发送到他们的目的地。使用write(byte[] data)或write(byte[] data, int offset, int length)，通常要比一个字节一个字节发送数据要快。
		流能够通过网络硬件的方式来实现缓冲，也可以通过软件的方式来实现，比如直接在java代码里。典型的，这个可以通过在底层的流上串联一个BufferedOutput
Stream或BufferedWriter来实现。最后，如果你完成了数据的写出，对输出流进行flush是很重要的。
		不管你认为是需要还是不需要，flush一个流都是很重要的。依赖于你如何获得一个指向流的引用，你可能知道或者不知道它是否有缓冲。（比如，System.out是缓冲的，不管你想要它是或者不是）。产生一个推论，你应该在关闭一个流之前，对其进行flush，否则，在流关闭时，存在于缓冲区中的数据可能会丢失。
		最后，当你使用完一个流，你可以调用它的close（）方法来关闭它。这将释放所有和流相关的资源，比如文件句柄或端口。如果流来自于一个网络连接，那么关闭流将中止该连接。一旦一个输出流被关闭了，后续的向它的写操作将抛出IOExceptions。然而，一些流在关闭之后，仍然允许你对它做一些事情，比如，一个关闭的ByteArrayOutputStream仍然能被转换成一个实际的字节数组，一个关闭的DigestOutputStream仍然能返回它的签名。
		在一个长时间运行的程序中，失败的关闭一个流可能会导致文件句柄，网络端口和其他资源的泄漏。因此，在java6和之前的版本中，聪明的做法是在finally块中关闭流。为了获得正确的变量范围，你需要在try块之外声明流变量，但是在try块中初始化它。更进一步，为了避免空指针异常，在流变量关闭之前，你需要检查它是否是null。最后，在关闭流时，你可能通常想要忽略或最多log任何的异常。
		OutputStream out = null;
		try {
			out = new FileOutputStream("/tmp/data.txt");
			// work with the output stream...
		} catch (IOException ex) {
			System.err.println(ex.getMessage());
		} finally {
			if (out != null) {
				try {
					out.close();
				} catch (IOException ex) {
				// ignore
				}
			}
		}
		这种技术有时被称为诊断模式，它对于那些在垃圾回收之前需要清理的对象是通用的。你将看到它不仅可以用来处理流，而且可以用来处理channel，socket，jdbc连接和statement等。
		java7引入的try with resources使得这种清理更整洁。替代了在try块之外声明流变量，你可以在try块的参数列表中声明它。比如，之前的代码片段现在将变得更简单：
			try (OutputStream out = new FileOutputStream("/tmp/data.txt")) {
				// work with the output stream...
			} catch (IOException ex) {
				System.err.println(ex.getMessage());
			}
		finally语句将不再被需要，java自动在声明在try块的参数列表中的AutoCloseable对象调用其close（）方法。
		try with resources能够被用于任何实现了Closeable接口的对象，这就基本包括了所有你需要处理的对象。目前为止，JavaMailTransport对象是我遇到的唯一的例外，你仍然需要显式的处理它。
	输入流
		java基本的输入类是java.io.InputStream。这个类提供了以原生字节的方式读取数据的方法，他们是：
			public abstract int read() throws IOException
			public int read(byte[] input) throws IOException
			public int read(byte[] input, int offset, int length) throws IOException
			public long skip(long n) throws IOException
			public int available() throws IOException
			public void close() throws IOException
		InputStream的特定子类使用这些方法从特定的媒介读取数据。比如，FileInputStream从一个文件读取数据。不管你从哪个来源读取数据，你大多数时候都只使用这6个方法。有时候你不会准确知道你正在从哪种流读取数据。比如，TelnetInputStream是一个隐藏在sun.net包中的未文档化的类，它的实例被java.net包中的很多方法返回（比如，java.net.URL的openStream()）。然而，这些方法只声明为返回InputStream，而不是更具体的TelnetInputStream。子类的实例能够被透明的当作它的超类的实例使用。不许要知道子类的特定知识。
		InputStream的基本方法是没有参数的read()方法。这个方法从输入流读取一个字节的数据，并且以0-255范围内的int类型将其返回。通过返回-1来标识到了流的尽头。read()方法会等待，并阻塞其后的任何代码的执行，直到有一个字节的数据可用，并且准备好被读取。
		read()方法被声明为抽象的，因为子类需要改变它来处理他们特定的媒介。比如，ByteArrayInputStream实现这个方法来使用java代码从它的数组中拷贝字节。
		虽然read()方法只读取了一个字节，但是它以int形式返回。因此，转化是需要的。当然，这个将产生一个有符号的，从-128到127范围的字节，而不是一个从0-255的无符号的字节。然而，只要你清楚你正在处理哪个，这个不是一个主要问题。你可以像这样一样，将一个有符号的字节转换为一个无符号的字节：int i = b >= 0 ？ b : 256 + b；
		一次读取一个字节是低效的，因此，有两个重载的read()方法，他们利用从流中读取的多个字节来填充一个特定的数组，他们是read(byte[] input)和read(byte[] input, int offset, int length)。
		注意我说的是这些方法尝试填充数组，而不是他们一定会成功。在很多情况下，这个尝试可能会失败。更通常的是，一个读取尝试将不会完全失败，也不会完全成功。请求的数据可能一部分已经被读取，但还没有完全读取。比如，你尝试从一个网络连接读取1024个字节，但是只有512个字节确实从服务端返回，剩下的仍然在传送。他们将最终会到达，但此刻他们是不可用的。为了解决这个问题，一次读取多个字节的方法将返回实际读取的字节数。
		这个技术对于网络流尤其重要。如果一个文件完全可用，这个文件的所有字节也是可用的。然而，由于网络要比cpu慢很多，因此程序会很容易在所有数据可用之前耗尽网络缓冲区。事实上，如果这两个方法中的任何一个尝试这从一个临时为空的，但是打开的网络缓冲区读取，它将返回0，表明没有数据可用，但是这个流还没有被关闭。这个相对于在相同情况下会阻塞当前线程执行的单字节读取方法read（）要好。
		所有的这三个方法通过返回-1来表明流的结束。如果在流结束时，仍然有数据没有被读取，多字节的read()方法将返回缓冲区中的所有数据。下一次对任意一个read()方法的调用都会返回-1。-1将不会被放到数组中，数组中只会存放实际的数据。
		如果你不想等待，知道你需要的所有字节立即变为可用，你可以使用available()方法来决定在不阻塞的情况下，你可以读取多少数据。这个方法返回你可以读取的最小的字节数。事实上，你可能可以读取更多，但是你至少可以读取available()返回的字节数。
		在很少的情况下，你可能想要在不读取数据的情况下跳过它。skip()方法能够完成这个任务。这个方法在网络连接中要比在文件读取时更没有用。网络连接是顺序的，并且通常很慢，因此读取数据比跳过数据不会消耗太多时间。文件是随机读取的，因此它可以简单的通过重新定位文件指针来实现跳过，而不用依次处理需要跳过的每个字节。
		就像输出流一样，一旦你的程序使用完一个输入流，你应该调用它的close()方法来关闭它。它将释放和这个流相关的任何资源，比如文件指针和端口。一旦数据流被关闭，任何后续的从它的读都将抛出IOException。然而，一些流在关闭之后，仍然允许你对它做一些操作。比如，你在所有数据被读取，并且流被关闭之前，将不会从java.security.DigestInputStream获得消息签名。
		标记和重置
			InputStream类还包括3个不太常用的方法，他们允许程序回退，并重新读取那些他们已经读取过的数据。他们是：
				public void mark(int readAheadLimit)
				public void reset() throws IOException
				public boolean markSupported()
			为了重新读取数据，可以使用mark()方法在流中标记当前的位置。在后续的一个点，你可以使用reset()方法来重置流到标记的位置。后续的读操作将会从标记的地方开始返回数据。然而，你可以reset的距离是有限制的，你从mark的地方开始，到调用reset时相差的字节数是由mark()方法的readAheadLimit参数决定的。如果你尝试在太远的距离进行reset，将会抛出IOException。更进一步，在一个流中，任何时候都只能有一个标记。标记第二个位置将会擦除第一个标记。
			标记和重置通常是通过使用一个内部的缓冲器来存储从标记位置开始读取的字节。然而，并不是所有的流都支持这个。在尝试使用标记和重置之前，检测markSupported()方法是不是返回true。如果返回true，那么该流支持标记和重置；否则，mark()方法将不做任何事情，reset()方法将抛出一个IOException。	
			java.io包中的输入流类中，总是支持标记的是BufferedInputStream和ByteArrayInputStream。然而，其他的输入流类，比如TelnetInputStream，只有在他们首先串联在一个缓冲的输入流时，才支持标记。
	过滤流
		InputStream和OutputStream是相当原生的类。他们单个的或成组的读取或写出数据，但也只是这些。决定这些字节代表什么-他们是整数，IEEE754规定的浮点数或者是Unicode文本-完全由上层的程序和代码决定。然而，只有特定的极其常用的数据格式才能从类库中的一个固定的实现中获益。比如，一些传递给网络协议的整数是32位，big-endian格式的整数。java提供了很多过滤类，你可以将他们附加到原生的流上来在原生字节和特定格式之间进行转换。
		过滤器来自于两个版本：过滤流，reader和writer。过滤流仍然主要是将原生数据以字节的形式来处理：比如压缩数据或将其解释为二进制数字。reader和writer以不同编码来处理特定情况的文本。
		在这个例子中，一个压缩的，加密的文本文件从本地的网络接口被接收，本地代码将其展示给未文档化的TelnetInputStream类，一个BufferedInputStream类用来缓冲数据来加速整个处理过程。一个CipherInputStream类被用来解密数据，一个GZIPInputStream类被用来解压解密过的数据，一个InputStreamReader类被用来将解压过的数据转化为Unicode格式的文本，最后，文本被读到应用中。
		每一个输出流过滤器都有和java.io.OutputStream相同的write(),close(), 和flush()方法。每一个输入流过滤器类都有和java.io.InputStream相同的read(), close(),和available()方法。在一些情况下，比如BufferedInputStream和BufferedOutputStream，这几个方法可能是过滤器仅有的几个方法。过滤完全是内部的，并且不会暴露任何新的公共的接口。然而，在大多数情况下，过滤流添加一些有额外目的的公共方法。有时候这些方法是打算让平常的read()和write()方法使用的，就像PushbackInputStream类的unread()方法。在有些时候，他们几乎完全替代了原有的接口。比如，很少使用PrintStream类的write()方法，而是替代的使用它的print()和println()方法。
		将过滤器串联在一起
			过滤器通过构造函数来连接到流上。大多数时候，你应该只使用链上的最后一个过滤器来进行实际的读或写。一个实现这个的很好的办法是覆盖指向底层的流的引用。比如：
				InputStream in = new FileInputStream("data.txt");
				in = new BufferedInputStream(in);
			连接是永久的，过滤器不能从一个流上断开连接。
			有些时候，你可能需要串联使用多个过滤器的方法。比如，如果你正在读取一个Unicode文本文件，你可能想要从开头的3个字节中判断文件是以big-endian UCS-2，little-endian UCS-2，或UTF-8编码的，然后再使用相匹配的Reader过滤器来解码。
		缓冲的流
			BufferedOutputStream类将写出的数据存储在一个缓冲器中，直到缓冲器被填满或流被flush。然后它一次性将数据写出到底层的输出流。一次写多个字节总是比多次写一个字节要快，这个在网络连接中尤其是正确的，因为每一个TCP分组或UDP包都会有一个有限的负载，通常是40个字节。这就意味着以每次一个字节的方式发送1kb实际上需要在网络上发送40kb的数据。大多数的网络卡和TCP实现都自己提供一定程度的缓冲。
			BufferedInputStream类也有一个受保护的，名为buf的字节数组来作为一个缓冲器。当一个流的read()方法被调用，它首次尝试从缓冲区中获取请求的数据。只有当缓冲区中的数据读取完，流才再次从底层源读取数据到缓冲区。这时，它读取尽可能多的数据从数据源到缓冲区中，不管它是否立即需要所有的数据。没有被立即使用的数据将对后续的对read()的调用可用。因此，缓冲区能显著的提高性能。这个性能提升在网络连接上不是很明显，因为网络连接的瓶颈通常是网络传送数据的速率，而不是网络接口传送数据到程序的速率或程序运行的速率。不管怎样，缓冲数据基本没有损害，并且将伴随这网络速率的提高变得更重要。
			BufferedInputStream和BufferedOutputStream一样都有两个构造函数：
				public BufferedInputStream(InputStream in)
				public BufferedInputStream(InputStream in, int bufferSize)
				public BufferedOutputStream(OutputStream out)
				public BufferedOutputStream(OutputStream out, int bufferSize)
			第一个参数是底层的流。第二个参数，如果提供了，指明了缓冲区的字节数大小。否则，对于输入流，缓冲区的大小被设置为2048字节，对于输出流，缓冲区的大小被设置为512个字节。缓冲区的理想大小依赖于他们缓冲的流的类型。对于网络连接，你想要缓冲区的大小比典型的包的大小大一点。然而，这个很难去预测，并且根据本地网络连接和协议的不同而不同。更快的，更高带宽的网络倾向于使用更大的包，虽然TCP分组通常不会大于1kb。
			BufferedInputStream自己没有声明任何新的方法。它只是重写了InputStream的方法。它支持标记和重置。这两个多字节的read()方法通过多次从底层输入流读取数据来尝试完全填充指定的数组或数组的一部分。他们只有在数组或子数组被完全填充，流到达了尽头，或底层的流将阻塞来进行更进一步的读取。大多数的输入流不会表现的像这样，在返回之前，他们只从底层流或数据源读取一次。
			BufferedOutputStream也没有声明任何它自己的方法。你调用它的方法和其他流的方法完全一样。不同的是，每次写将数据放到缓冲区，而不是直接放到底层输出流。因此，当你到达一个需要将数据发送出去的点时，flush流是很重要的。
		PrintStream
			PrintStream是大多数开发者碰到的第一个输出流过滤器，因为System.out是一个PrintStream。然而，其他的PrintStream也能串联到其他输出流上，使用下面的两个构造函数：
				public PrintStream(OutputStream out)
				public PrintStream(OutputStream out, boolean autoFlush)
			默认的，PrintStream应该被显式的flush。然而，如果autoFlush参数是true，在每次一个字节数组被写出，一个回车换行被写出，或一个println()方法被调用时，流都会被flush。
			就像平常的write(), flush(), 和close()方法，PrintStream有9个重载的print()方法和10个println()方法：
				public void print(boolean b)
				public void print(char c)
				public void print(int i)
				public void print(long l)
				public void print(float f)
				public void print(double d)
				public void print(char[] text)
				public void print(String s)
				public void print(Object o)
				public void println()
				public void println(boolean b)
				public void println(char c)
				public void println(int i)
				public void println(long l)
				public void println(float f)
				public void println(double d)
				public void println(char[] text)
				public void println(String s)
				public void println(Object o)
			每个print()方法都会按照可预测的形式将其参数转化为一个string，并且使用默认的编码方式将该字符串写出到底层的输出流。println()方法做了同样的事情，但是它会附加一个平台相关的行分割符到他们写出的行的末尾。在Unix中是换行符（\n），在max os 9中是回车符（\r），在windows中是回车换行符（\r\n）。
			PrintStream是有害的，因为它的结果和平台相关，所以应该在网络编程中避免使用它。
			第一个问题是println()的输出结果是平台相关的。大多数的网络协议，比如HTTP和Gnutella指明行必须以一个回车/换行对来结束。
			第二个问题是PrintStream假定了它正在运行的平台的默认编码方式。虽然，这个编码方式可能不是客户端和服务器端期望的那个。比如一个web浏览器获取到了一个xml文件，它期望该文件是以UTF-8或UTF-16编码的，除非服务器告诉它。然而，一个使用PrintStream的web服务器，会在U.S.-localized的windows系统上以CP1252编码来发送该文件，在Japanese-localized的系统上，以SJIS编码发送该文件，不管客户端是否期望或理解这些编码方式。PrintStream没有提供任何机制来改变默认的编码。这个问题可以通过使用替代的PrintWriter来修补。
			第三个问题是PrintStream会吞掉所有的异常。网络编程必须在数据流动的过程中准备好处理不可预期的中断，实现这个的方法是处理异常。注意PrintStream中的OutputStream中提供的5个基本方法都没有throws IOException声明。
			相替代的，PrintStream依赖一个过时的，不恰当的错误标志。如果底层的流抛出一个异常，内部的错误标记就被设置。程序员通过使用checkError()方法来检测该标记的值。
			为了实现对PrintStream的完全错误检测，代码必须显式的检测每一次调用。更进一步，一旦一个错误发生，将没有办法重置这个标志，以使后续的错误也能被检测。没有任何关于这个错误的附加信息可用。总的来说，PrintStream提供的错误通知，对于不可信赖的网络连接是完全不适当的。
		DataStream
			DataInputStream和DataOutputStream提供了以二进制形式来读取或写出java基本数据类型和字符串的方法。使用二进制形式主要是为了在不同的java程序之间交换信息，通过一个网络连接，一个数据文件，一个管道，或一些其他的中间媒介。data output stream输出了什么，data input stream都能读取。
			DataOutputStream提供了11个方法，用来写出特定的java数据类型。所有的数据都是以big-endian的格式被输出的。
			最后的三个方法有一点诡计。writeChars()方法简单的迭代String参数，依次以两个字节，big-endian
Unicode字符的格式写出每个字符。writeBytes()迭代String参数的每个字符，但只写出每个字符的最低位字节。因此对于那些范围超过Latin-1字符集的字符将会丢失信息。这个方法在那些指定使用ASCII编码的网络协议中很有用，但大多数时候应该避免使用它。
			writeChars()和writeBytes()都不会将字符串的长度编码到输出流中去，导致了你不能真正的区分组成一个字符串的原生字符。writeUTF()方法包含了字符串的长度。它使用Unicode字符集的UTF-8编码方式的一个变种来编码字符串。因为这个变种和大多数其他非java软件都不兼容，因此它只能用来和那些使用DataInputStream来读取数据的java程序来交换数据。为了和其他软件交换UTF-8编码的文本，你应该使用一个恰当编码的InputStreamReader。
			DataInputStream是DataOutputStream的一个互补。任何DataOutputStream写出的格式，DataInputStream都能读。
			有9个方法来读取二进制数据，来匹配DataOutputStream的11个方法（没有准确的和writeBytes()或writeChars()互补的方法，这些可以通过一次读取一个字节或一个字符来处理）。
			附加的，DataInputStream提供了两个方法来读取无符号的byte和无符号的short，并且返回相应的int。java中没有这两种数据类型，但是你在读取c程序写出的二进制数据时会碰到他们。
				public final int readUnsignedByte() throws IOException
				public final int readUnsignedShort() throws IOException
			DataInputStream有两个平常的多字节read()方法，他们读取数据到一个字节或字节的一个区域，并且返回读取的字节数。它也有两个readFully()方法，他会反复的从底层输入流读取数据到一个数组中，直到请求的字节数量已经被读取。如果没有足够的数据来被读取，一个IOException将会被抛出。这些方法在你知道将有多少字节将被读取时很有用。比如，当你已经读取到了HTTP头中的Content-length字段后，因此知道了有多少数据要被读取。
				public final int read(byte[] input) throws IOException
				public final int read(byte[] input, int offset, int length) throws IOException
				public final void readFully(byte[] input) throws IOException
				public final void readFully(byte[] input, int offset, int length) throws IOException
			最后，DataInputStream提供了流行的readLine()方法，它会读取以行终结符分割的一行文本，并且以字符串的形式返回：
				public final String readLine() throws IOException
			然而，这个方法不应该被使用在任何情况下，不仅因为它被弃用，而且因为它很容易导致bug。它被弃用是因为在大多数情况下，它不能恰当的将非ASCII字符转换成字节。这个任务目前被BufferedReader类的readLine()方法来处理。然而，这两个方法共享相同的隐藏bug：他们不能将一个单个的回车符当作行的结尾。readLine()只认识换行符或回车/换行符对。当一个回车符在流中被检测到，readLine()方法将等待来看下一个字符是否是换行符。如果是换行符，那么回车符和换行符都被丢弃，这行数据被以字符串的形式返回。如果不是换行符，回车符被丢弃，这行数据以字符串的形式被返回，被读取的额外的字符称为了下一行的一部分。然而，如果回车符是流的最后一个字符，那么readLine()将被挂起，等待下一个字符，然而它将不会到来。
			这个问题在读取文件时不是很明显，因为基本可以肯定有下一个字符：-1来作为流的结束。然而，在一个持续的网络连接中，比如FTP和HTTP，客户端和服务器端可能只是在最后一个字符后简单的在停止发送数据，并且在不关闭流的情况下等待回复。如果你幸运，连接的某一端最终会超时，你将得到一个IOException，虽然这个将耗费一段时间。如果你不幸运，程序将会被无限期挂起。
		Reader和Writer
			很多程序员都有一个坏习惯，他们编写代码的时候以为好像所有的文本都是ASCII或至少是平台的本地编码。虽然很多旧的简单的网络协议，比如daytime，chargen，确实是ASCII编码的，但这对于HTTP或其他更现代的协议却不是这样，他们允许一个很大范围内的本地编码。java的本地字符集是使用UTF-16编码的Unicode字符集。java提供了一个基本是输入流和输出流的镜像的类的层级结构，他们工作在字符上，而不是字节上。
			两个抽象的超级类定义了读取和写出字符的基本的API。java.io.Reader类指定了读取字符的API，java.io.Writer指定了写出字符的API。输入和输出流使用字节，reader和writer使用Unicode字符。Reader和Writer的特定子类允许从特定的源读取或向特定的目标写出。reader和writer的过滤器可以被附加到其他的reader和writer上来提供额外的服务或接口。
			Reader和Writer的最重要的子类是InputStreamReader和OutputStreamWriter。InputStreamReader包含了一个它从中读取原生字节的底层的输入流，它通过一个指定的编码方式将字节转换成Unicode字符。OutputStreamWriter从运行的程序中获取Unicode字符，它使用特定的编码方式将字符转换成字节，并写出到底层的输出流。
			在这两个类之外，java.io包提供了很多原生的reader和writer类，他们读取字符，而不需要直接需要一个底层的输入流。包括：
				• FileReader
				• FileWriter
				• StringReader
				• StringWriter
				• CharArrayReader
				• CharArrayWriter
			前两个类是基于文件的，后四个工作在java的内部，所以他们对于网络编程不是很有用。然而，除了构造函数不同，这些类和其他reader和writer有相同的公共接口。
			Writer
				Writer类是java.io.OutputStream的镜像，它是抽象的，并且有两个受保护的构造函数。就像OutputStream，Writer类不会被直接使用。相替代的，它以多态的形式被使用，通过它的某一个子类。它有5个write()方法和flush()和close()方法。
				write(char[] text, int offset, int
length)方法是最基本的方法，其他4个write方法都是在它的基础上实现的。一个子类必须至少覆盖这个方法和flush()和close()方法，虽然有时候也会覆盖其他的write()方法，以提供更有效的实现。
				Writer可能是缓冲的，或者是通过串联到一个BufferedWriter来直接缓冲，或者是非直接的，因为他们的底层输出流是缓冲的。为了强制写出被提交到输出媒介，调用flush()方法。close()方法和OutputStream的close()方法表现的很相似。close()先flush该writer，然后关闭底层的输出流，并且释放和它相关的资源。当一个writer被关闭后，后续对它的写出将抛出IOException。
			OutputStreamWriter
				OutputStreamWriter是Writer类最重要的特定子类，一个OutputStreamWriter从java程序接受字符。它通过指定的编码将这些转化为字节，并写出到底层的输出流中。它的构造函数指明了要写出到的输出流和要使用的编码：
					public OutputStreamWriter(OutputStream out, String encoding) throws UnsupportedEncodingException
				有效的编码列出在，包含在JDK中的Sun的native2ascii工具的文档中。如果没有编码被指定，平台默认的编码将被使用。在2013年，Max上的默认编码是UTF-8，在Linux上通常也是。然而，在Linux上它可能是不同的，要根据本地操作系统被配置使用的是哪一个。在windows上，它根据国家和配置而不同。默认的字符集会在不同的不可预测的时间产生不可预测的问题。通常你最好显式的指定字符集，而不是让java来为你选一个。
				除了构造函数，OutputStreamWriter只有和其他普通Writer类相同的方法（他们的用法基本相同），并且有一个返回这个对象使用的编码的方法：public String getEncoding()
			Reader
				Reader类是java.io.InputStream的映像。它是有两个受保护的构造函数的抽象类。就像InputStream和Writer，Reader也不会被直接使用，而是通过它的某一个子类。它有3个read()方法，和skip(),close(), ready(), mark(), reset(), 和markSupported()方法：
					protected Reader()
					protected Reader(Object lock)
					public abstract int read(char[] text, int offset, int length)
					throws IOException
					public int read() throws IOException
					public int read(char[] text) throws IOException
					public long skip(long n) throws IOException
					public boolean ready()
					public boolean markSupported()
					public void mark(int readAheadLimit) throws IOException
					public void reset() throws IOException
					public abstract void close() throws IOException
				read(char[] text, int offset, int length)方法是其他两个read()方法实现的基础。某一个子类必须覆盖至少这个方法和close()方法，虽然某些子类也会覆盖其他方法，来提供更有效的实现。
				这些方法中的大多数可以和InputStream中的对照物进行类比来理解。read()方法以0-65535范围内的整数来返回一个单一的Unicode字符，或者是-1，当流结束时。（技术上，它返回的是一个UTF-16的代码点，相当于是一个Unicode字符）。read(char[] text)尝试用读取的字符填满text字符数组，并且返回实际读取的字符数，或者是-1当流结束时。read(char[] text, int offset, int length)尝试读取length个字符到text数组的以offset开始，持续length个字符的字数组中。它返回实际读取的字符数或-1（当流结束时）。skip(long n)方法跳过n个字符。mark()和reset()允许某些reader回退到字符序列的一个标记点。markSupported()来指明该reader是否支持标记和重置。close()方法关闭reader和任何底层的输入流，以使后续的从它的读取都会抛出IOException。
				这些相似性规则的一个例外是read()。它和available()方法在大体意图上相同，但是在语义上不是很相同，即使考虑上字节到字符的转换。available()返回以个int来表明在不需要阻塞的情况下可以读取的最小字节数，read()只返回一个boolean来指明在不阻塞的情况下，reader是否可以读。问题是由于一些字符编码，比如UTF-8，对不同的字符使用不同的字节数。因此很难判断还有多少字符在网络或文件的缓冲区中，在不将他们从缓冲区读出来的前提下。
				InputStreamReader是Reader的一个最重要的子类。InputStreamReader从底层的输入流读取字节，比如FileInputStream或TelnetInputStream。它根据指定的编码方式，将这些字节转换成字符，并将他们返回。它的构造函数指明了使用的输入流和编码：
					public InputStreamReader(InputStream in)
					public InputStreamReader(InputStream in, String encoding) throws UnsupportedEncodingException
				如果没有编码方式被指定，平台使用的默认编码方式将被使用。如果一个未知的编码被指定，那么UnsupportedEncodingException将会被抛出。
			Reader和Writer类的过滤器
				inputStreamReader和OutputStreamWriter扮演的是输入流和输出流上的装饰器，将面向字节的接口变成面向字符的接口。相应的，额外的面向字符的过滤器也能被放置在reader或writer之上，通过使用java.io.FilterReader和java.io.FilterWriter。和流的过滤器一样，有很多子类来执行特定的过滤，包括：
					• BufferedReader
					• BufferedWriter
					• LineNumberReader
					• PushbackReader
					• PrintWriter
				BufferedReader和BufferedWriter是基于字符的，相当于面向字节中的BufferedInputStream和BufferedOutputStream。BufferedInputStream和BufferedOutputStream内部使用一个字节数组来作为缓冲区，BufferedReader和BufferedWriter内部使用一个字符数组来作为缓冲区。
				当一个程序从BufferedReader中读取时，文本是从缓冲区来获取，而不是之间从底层的输入流或其他文本源。但缓冲区空时，会用尽可能多的可用的文本来填充它，即使并不是所有都会被立即使用，使得后续的读取更快。当一个程序向BufferedWriter写时，文本被放置在缓冲区，当缓冲区填满或writer被显式flush时，文本被写出到底层的输出流或其他的目标，这将使writer更快。
				BufferedReader和BufferedWriter有reader和writer相关的普通的方法，像read(),ready(), write(), 和close().他们都有两个构造函数，来将他们串联到底层的reader和writer，并且设置缓冲区的大小。如果缓冲区大小没指定，那么默认的8,192个字符将被使用。
				BufferedReader类还有一个readLine()方法，它读取一行文本，并且以字符串的形式返回：public String readLine() throws IOException
				这个方法替代了DataInputStream中的废弃的readLine()方法，它和那个方法有几乎相同的行为。最大的不同是，通过将BufferedReader串联到一个InputStreamReader上，你可以正确的读取字符集中的行，除了平台默认的编码之外。
				BufferedWriter类添加了一个不包含在超类中的新方法，叫做newLine()，专门用来写出一行：public void newLine() throws IOException
				这个方法插入一个平台相关的行分割符到输出流中。line.separator系统属性决定了这个行分割符具体是什么。由于网络协议一般都指定了需要的行分割符，所以你不应该在网络编程中使用这个方法。相替代的，显式的写出协议需要的行分割符。通常，需要的行分割符是回车/换行对。
			PrintWriter
				PrintWriter类是java 1.0中的PrintStream类的一个替代，它恰当的处理了多字节字符集和国际化文本。Sun起初打算废弃PrintStream，换而使用PrintWriter，但是又放弃了，因为它意识到这将会使很多已经存在的代码无效，特别是那些依赖于System.out的代码。不管怎样，新代码都应该使用PrintWriter来替代PrintStream。
				除了构造函数，PrintWriter类有基本和PrintStream一样的方法集合，包括：
					public PrintWriter(Writer out)
					public PrintWriter(Writer out, boolean autoFlush)
					public PrintWriter(OutputStream out)
					public PrintWriter(OutputStream out, boolean autoFlush)
					public void flush()
					public void close()
					public boolean checkError()
					public void write(int c)
					public void write(char[] text, int offset, int length)
					public void write(char[] text)
					public void write(String s, int offset, int length)
					public void write(String s)
					public void print(boolean b)
					public void print(char c)
					public void print(int i)
					public void print(long l)
					public void print(float f)
					public void print(double d)
					public void print(char[] text)
					public void print(String s)
					public void print(Object o)
					public void println()
					public void println(boolean b)
					public void println(char c)
					public void println(int i)
					public void println(long l)
					public void println(float f)
					public void println(double d)
					public void println(char[] text)
					public void println(String s)
					public void println(Object o)
				PrintWriter中的这些大多数方法都和PrintStream中的表现相同。不同的是4个write方法，他们写出字符，而不是字节。PrintWriter中的所有方法都恰当的处理了字符集转化的问题，这是在非国际化的PrintStream类上的一个改进，但是它对于网络编程来说仍不够好。不幸的，PrintWriter也有和PrintStream一样的平台依赖和最小化错误报告的问题。
				

第三章 线程
	运行线程
		为了给一个线程一些事情来做，可以通过继承Thread类，并实现它的run方法；或者实现Runnable接口，并把这个Runnable对象传递给Thread的构造函数。
		一个单线程的程序会在它的main()方法返回时退出。一个多线程的程序会在main()方法和所有用户线程（non-daemon）的run方法返回后退出。（守护线程执行后台任务，比如垃圾收集，它不会组织java虚拟机退出）
		继承Thread
			因为run()方法的签名是不变的，你不能向它传递参数或从它里边返回值。你需要使用不同的方法来向线程传递信息或从线程中获得信息，向线程传递参数的最简单的方法是通过Thread子类的构造函数的参数，它将用来设置线程子类的字段。
		实现Runnable接口
	从线程返回信息
		条件竞争
		拉(polling)
		回调
		Futures, Callables, and Executors
			Callable接口只定义了一个call()方法，它基本上能返回任何类型。虽然你可以直接调用call()方法，但这不是它的本意。相替代的，你可以提交一个Callable对象到一个Executor。
	同步
		同步块
		同步方法
		同步的替代方法
			第一个是在可能的地方使用本地变量来代替字段。
			构造函数通常不需要担心线程安全的问题。在构造函数返回之前，没有线程会有指向该对象的引用。
			第二个方法是使用不可变性。
			第三个方法是使用一个非线程安全的类，但是只用该类作为一个类的私有字段，这样做是线程安全的。只要包含类只通过线程安全的方式来访问非线程安全的类，并且，只要它不让对私有字段的引用泄漏到其他对象中，这个类是安全的。
			 Collections.synchronizedSet(foo)，Collections.synchronizedList(foo)，Collections.synchronizedMap(foo)，为了使这个起作用，你必须强制只通过Collections.synchronizedSet/List/Map返回的视图来操作集合。
	死锁
	线程调度
		优先级
			在java中10是最高的优先级，0是最低的优先级，默认的优先级是5.这三个优先级通常由三个命名常量来指定：
				public static final int MIN_PRIORITY = 1;
				public static final int NORM_PRIORITY = 5;
				public static final int MAX_PRIORITY = 10;
	                你可以使用setPriority()来改变线程的优先级：public final void setPriority(int newPriority)。尝试设置一个超出范围的优先级将抛出一个IllegalArgumentException。
		抢占
			两种主要的线程调度策略：抢占式和合作式。抢占式线程调度会在一个线程消耗完它的时间片后，停止该线程，并将cpu的控制权交给其他线程。合作的线程调度器在将cpu的控制权交给其他线程之前会等待正在执行的线程暂停。
			所有的java虚拟机保证根据优先级使用抢占式的调度策略。那就是，当一个高优先级的线程准备好了运行，但有一个低优先级的线程正在运行，虚拟机迟早会暂停低优先级的线程来允许高优先级的线程运行。高优先级的线程抢占了低优先级的线程。
			当多个具有相同优先级的线程都准备好运行的情况是机警的（trickier）。一个抢占式调度器将随机的暂停其中的一个线程，来允许同一条线上的其他线程能获取一些cpu时间。然而，一个合作式调度器不会这样，它会等待正在运行的线程显式放弃控制权或到达了一个停止点。如果正在运行的线程一直没有放弃控制权，或一直没有到达一个停止点，或没有更高优先级的线程抢占正在运行的线程，所有其他的线程都将饥饿。因此周期性的使你的线程暂停它自己来让其他线程有机会可以运行是很重要的。
			有10个方法可以暂停一个线程：
				阻塞在I/O上
				阻塞在同步对象上
				yield
				sleep
				join
				wait
				执行完
				被更高优先级的线程抢占
				suspend
				stop
			最后两个方法被废弃了，因为它有使线程处于不一致状态的潜在危险。
			阻塞：
				不管是阻塞在I/O上还是阻塞在锁上，被阻塞的线程都将释放它已经拥有的所有的锁。
			yield：
				一些虚拟机，尤其是在一些实时操作系统上，可能会忽略这个暗示。
				在yield之前，一个线程应该确保它或它相关的Runnable对象处在一个能被其他对象使用的一致的状态。yield不会释放该线程持有的任何锁。
			sleep：
				sleep是一种更强形式的yield。yield只指明一个线程将会暂停，并且允许其他相同优先级的线程执行。sleep的线程将会被暂停，而不论是否有其他线程准备好运行。这不仅给同优先级的线程执行的机会，而且也给低优先级的线程执行的机会。一个sleep的线程将会仍然持有它已经拥有的锁。因此，其他请求相同锁的线程都将阻塞，即使cpu是可用的。因此，要尽量避免在同步块或同步方法中sleep一个线程。
				虽然大多数现代处理器的时钟都有接近于毫秒的精度，纳秒精度的很少。因此休眠的时间不会精确到纳秒，甚至在一些虚拟机上也可能不会精确到毫秒。如果本地硬件不支持精确的等级，休眠的时间会被简单的约等于到最近的能被测量的值。
				其他线程可以唤醒正在休眠的线程，通常是通过调用休眠的线程的interrupt()方法来实现：public void interrupt()
				java提供了join方法来允许一个线程在继续执行前等待另一个线程执行完成。join可能没有它在java 5.0之前那么重要了，在实践中，那些需要join的设计能够通过替代的使用Executor和Future来实现。
			执行完成
		线程池和Executor


第四章 Internet地址
	IPv4有4个字节，IPV6有16个字节，这16个字节由8组16进制的数字组成。每组中开头的0可以不用写，两个连续的冒号，在每一个地址中只能出现一次，指明多个全是0的块。在混合网络中，IPV6地址的最后4个字节也可以用IPV4地址的点分10进制形式表示。
	有时，一个主机名会映射到多个IP地址。DNS服务器的责任是随机的选择一个机器来相应请求。
	InetAddress类
		java.net.InetAddress类是IP地址在java中的表示，即是IPV4，也是IPV6。它经常被大多数的网络类使用，比如Socket,ServerSocket, URL, DatagramSocket, DatagramPacket，还有其他的。通常，它包括主机名和IP地址。
		创建一个InetAddress对象
			InetAddress类没有公共的构造函数。相替代的，它有一个工厂方法，可以连接到一个DNS服务器，来解析主机名。最常用的是InetAddress.getByName()
，比如InetAddress address = InetAddress.getByName("www.oreilly.com");。这个方法不只是在InetAddress中设置了一个私有的String字段，它实际上会建立一个连接到本地DNS服务器，来查找主机名和IP地址。如果你以前查找过某个主机，它的信息会被缓存到本地，在这种情况下网络连接就不需要了。如果DNS服务器找不到地址，这个方法将抛出一个UnknownHostException，它是IOException的一个子类。
			你也可以通过IP地址来做一个反向查询，比如，InetAddress address = InetAddress.getByName("208.201.239.100");System.out.println(address.getHostName());。如果你查找的地址没有主机名，getHostName()将简单的返回你原来提供的点分地址。如果一个主机对应多个地址，那么可以通过getAllByName()来返回他们，比如，InetAddress[] addresses = InetAddress.getAllByName("www.oreilly.com");。最后，getLocalHost()方法返回一个你的代码当前正在运行的主机的InetAddress对象，比如，InetAddress me = InetAddress.getLocalHost();。这个方法将尝试着连接到DNS来获取一个真实的主机名和IP地址，比如，“elharo.laptop.corp.com”和“192.1.254.68”，但是如果失败了，它将相替代的返回一个回环地址，这个地址的主机名是“localhost”，点分4组地址是“127.0.0.1”。
			如果你不知道一个数字的地址，你可以通过使用InetAddress.getByAddress()来创建一个InetAddress对象，而不用和DNS交互，这个方法能用来为那些不存在或不能被解析的主机创建地址。
				public static InetAddress getByAddress(byte[] addr) throws UnknownHostException
				public static InetAddress getByAddress(String hostname, byte[] addr) throws UnknownHostException
			第一个方法返回的InetAddress对象只有IP地址，没有主机名。第二个方法返回的InetAddress对象既有IP地址，又有主机名。
			不像其他工厂方法，这两个方法不保证有这么一个主机存在，或主机名和IP地址的映射是对的，它只有当作为地址参数的字节数组的大小是非法的时，才抛出UnknownHostException。这个在DNS不可用或有一些不精确的信息时是有用的。比如，我本地网络的计算机，打印机，路由器都没有注册在任何DNS服务器上。因为我从来不记为哪个设备分配了什么地址，我写了一个简单的程序，尝试着轮流连接到本地的254个可能的本地地址，来查看哪个是活动的。
			缓存
				因为DNS查找的代价是相对昂贵的，所以InetAddress会缓存查找的结果。一旦它有了给定主机的地址，它将不再会再次查找，即使你为相同的主机创建了一个新的InetAddress对象。只要在你程序运行的过程中IP地址没有改变，这就没有问题。
				负面的结果（主机没有找到的错误）通常更容易出问题。第一次解析一个主机错误，但是紧接着成功的情况不常见。当信息在从远程DNS服务器传送时，第一次请求超时，当地址到达了本地主机，并且立即对下一次请求可用。因为这个原因，java只缓存未成功的DNS请求10秒。
				这些时间能够被系统属性networkaddress.cache.ttl和networkaddress.cache.negative.ttl来控制。networkaddress.cache.ttl，指明了成功的DNS请求保持的时间，networkaddress.cache.negative.ttl指明了不成功的DNS请求保持的时间。在时间范围内，尝试查找相同的主机，将只是返回相同的值。-1被解释为从不过期。
				除了InetAddress内的本地缓存，本地主机，本地DNS服务器和Internet上的其他DNS服务器，都会缓存不同请求的结果。java没有提供方法来控制这个。导致了一个结果，将一个IP地址改变的信息传播到Internet上可能需要花费多个小时。同时，你的程序将不同的异常，包括UnknownHostException, NoRouteToHostException, and ConnectException，这依赖于DNS服务器上的改变具体是什么。
			通过IP地址查找
				当你使用一个IP地址字符串来调用getByName()，它为你请求的IP地址创建一个InetAddress，而不去向DNS核对。这就意味着你可能创建了一个InetAddress，它代表的主机其实不存在或你连接不上。InetAddress对象的主机名被初始设置为创建该对象的IP地址，对于确实的主机名的DNS查找，只有在主机名被请求时才会发生，比如，当getHostName()被调用时。当主机名被请求，DNS查找被执行，但是这个IP指定的主机不能被找到，主机名将仍保持原来的IP地址的形式，不会有UnknownHostException被抛出。
				主机名要比IP地址稳定。在主机名和IP地址之间选择时，将总是选择使用主机名。只有在主机名不可用的情况下，才使用IP地址。
			安全问题
				从一个主机名创建一个InetAddress被认为是一个有潜在危险的操作，因为它请求一次DNS查询。一个在默认的安全管理器控制之下的，不受信任的applet将只被允许查找它来自的那个主机的IP地址，可能也可以查找本地主机。非信任的将不被允许从其他主机名来创建一个InetAddress。这对于InetAddress.getByName()，InetAddress.getAllByName()，InetAddress.getLocalHost()，或其他方法都是真的。非信任的代码会从IP地址的形式来构造一个InetAddress对象，但它将不会为这个地址执行DNS查找。
				非信任的代码不被允许执行任何针对第三方主机的DNS查找，因为禁止和代码来源之外的主机建立网络连接。任意的DNS查找将打开一个可以和第三方主机通话的转换的频道。比如，一个从www.bigisp.com下载的applet想要向crackersinc.com发送一个消息。它所要做的是向DNS请求关于crackersinc.com的信息。为了解析这个主机名，applet将会联系本地的DNS服务器，本地的DNS服务器将会联系crackersinc.com的DNS服务器。即使这个主机不存在，黑客也可以从关于crackersinc.com的错误日志中获取一些信息。任意的DNS查找是不被允许的，因为它会泄漏信息。
				非信任的代码允许调用InetAddress.getLocalHost()。然而，在这样一个环境中，getLocalHost()将总是返回一个localhost/127.0.0.1的主机名。禁止applet查找真实的主机名和地址的原因是applet正在运行的主机可能被精心隐藏在防火墙之后。
				就像所有的安全检查，关于DNS解析的禁止可以向信任的代码放开。SecurityManager中用来测试一个主机是否可以被解析的特定的方法是checkConnect():public void checkConnect(String hostname, int port)。当端口参数是-1时，这个方法来检查是否DNS可以被调用来解析特定的主机。如果端口参数大于-1，这个方法检查是否允许向该命名的主机的特定端口建立一个连接。hostname参数可以是主机名，也可以是IP地址。
		Getter方法
			InetAddress类有4个getter方法，他们以字符串的形式返回主机名，以字符串或字节数组的形式返回IP地址：
				public String getHostName()
				public String getCanonicalHostName()
				public byte[] getAddress()
				public String getHostAddress()
               地址类型
			一些IP地址和地址模式有特殊的意思。比如，127.0.0.1是一个本地回环地址，224.0.0.0到239.255.255.255之间的IPV4地址是多播地址，它会一次发送请求到多个订阅的主机。java包含10个方法来测试一个InetAddress对象是否满足这些标准：
				public boolean isAnyLocalAddress()
				public boolean isLoopbackAddress()
				public boolean isLinkLocalAddress()
				public boolean isSiteLocalAddress()
				public boolean isMulticastAddress()
				public boolean isMCGlobal()
				public boolean isMCNodeLocal()
				public boolean isMCLinkLocal()
				public boolean isMCSiteLocal()
				public boolean isMCOrgLocal()
			如果一个地址是通配符地址（wildcard address），那么isAnyLocalAddress()将返回true，否则，返回false。一个通配符地址将匹配本地系统的任何地址。这个在一个系统有多个网络接口的情况下很重要，就像可能在一个系统上有多个以太网卡或有一个以太网卡和一个802.11 wifi接口。在IPV4中，通配符地址是0.0.0.0，在IPV6中，该地址是0.0.0.0.0.0.0.0（又名::）。
			如果地址是一个回环地址，那么isLoopbackAddress()将返回true，否则，返回false。回环地址在IP层直接连接到相同的计算机，而不会涉及到物理硬件。因此，连接到回环地址允许测试绕过容易出错的或不存在的以太网，PPP和其他驱动设备，帮助我们隔离问题。连接到回环地址和连接到系统的普通的IP地址是不同的。在IP地址中，该地址是127.0.0.1；在IPV6中，该地址是0.0.0.0.0.0.0.1（又名::1）。
			如果一个地址是IPV6的本地链路地址，那么isLinkLocalAddress()将返回true，否则，返回false。这个地址通常用于IPV6网络进行自我配置，很想IPV4中的DHCP，但它不需要使用一个服务器。路由器不会将那些地址是本地链路地址的包转发到本地子网之外。所有的本地链路地址都起始于FE80:0000:0000:0000这8个字节，剩下的8个字节使用本地地址来填充，通常拷贝于分配给以太网卡制造商的MAC地址。
			如果一个地址是IPV6的站点本地地址（site-local address），那么isSiteLocalAddress()将返回true，否则，返回false。这个地址和link-local地址很像，除了它可以被路由器在本站点或校园之内转发，但不能转发到站点之外。站点本地地址起始于FEC0:0000:0000:0000这8个字节，剩下的8个字节通过本地地址来填充，通常拷贝于分配给以太网卡制造商的MAC地址。
			如果地址是一个多播地址，那么isMulticastAddress()将返回true，否则，返回false。多播地址连接到多个订阅的计算机，而不是某个特定的计算机。在IPV4中，多播地址都落在224.0.0.0到239.255.255.255的范围内。在IPV6中，他们都以字节FF开头。			                                  
			如果地址是一个全局的多播地址，那么isMCGlobal()将返回true，否则，返回false。一个全局的多播地址可以在世界范围内有订阅者。所有的多播地址都以FF字节开头。在IPV6中，全局多播地址以FF0E或FF1E开头，这取决于该多播地址是有名的固定分配的地址还是临时地址。IPV4使用TTL（time-to-live）来控制范围，而不是使用地址。
			如果地址是一个组织范围内的（organization-wide）多播地址，那么isMCOrgLocal()返回true，否则，返回false。一个组织范围内的多播地址可以在组织内的所有站点中拥有订阅者，但是不能在组织之外。组织内的多播地址以FF08或FF18开头，这依赖于该多播地址是一个有名的固定分配的地址还是一个临时地址。
			如果地址是一个站点范围内的（site-wide）多播地址，那么isMCSiteLocal()返回true，否则，返回false。目的地址为站点范围内的包将只被在本地站点范围内传输。站点范围内的多播地址起始于FF05或FF15，这取决于该多播地址是有名的固定分配的地址还是临时地址。
			如果地址是一个子网范围内的（subnet-wide）多播地址时，isMCLinkLocal()将返回true，否则，返回false。目的地址为本地链路地址的包将只被在他们所属的子网范围内传输。本地链路多播地址起始于FF02或FF12，依赖于该多播地址是有名的固定分配的地址还是临时地址。
			如果地址是一个本地接口的（interface-local）多播地址，那么isMCNodeLocal()返回true，否则，返回false。目的地址是本地接口地址的包不会被发送到它起源的网络接口之外，即使是同一节点的不同网络接口。这个主要在网络调试和测试中很有用。本地接口多播地址起始于FF01或FF11，这取决于该多播地址是有名的固定分配的地址还是临时地址。
		可达性测试
			InetAddress类有两个isReachable()来测试指定的节点是否可达，从本地主机。连接将会因为很多原因被阻塞，包括防火墙，代理服务器，路由器的不当行为，线路损坏，或简单的因为在你尝试连接时，远程主机没有启动。
				public boolean isReachable(int timeout) throws IOException
				public boolean isReachable(NetworkInterface interface, int ttl, int timeout) throws IOException
			这些方法尝试使用路由跟踪（更具体一些，是ICMP的echo请求）来查找指定的地址是否可达。如果远程主机在timeout毫秒之内回复，方法将返回true，否则，返回false。如果有网络错误，IOException将会被抛出。第二个变种也允许你指定用来发起连接的本地网络接口，以及time-to-live（在被丢弃之前，该网络连接将尝试的最大的网络跳跃数）。
		Object方法
			java.net.InetAddress类重写了java.lang.Object类的这三个方法，来提供更特殊的行为：
				public boolean equals(Object o)
				public int hashCode()
				public String toString()
			一个对象equal to一个InetAddress对象，只有当该对象也是一个InetAddress对象，且具有相同的IP地址时，并不需要有相同的主机名。
			hashCode()方法和equals()方法是一致的。hashCode()方法返回的hash值只是通过IP地址计算出来的，它没有考虑主机名。
			java.net.InetAddress的toString()返回的字符串的格式为：hostname/dotted quad address
			并不是所有的InetAddress对象都有主机名。如果没有，在java 1.3或以前，使用以点分割的，由4部分组成的地址来代替；在java 1.4或以后，主机名被设置为空字符串。
	Inet4Address和Inet6Address
		java使用Inet4Address和Inet6Address来区分IPV4地址和IPV6地址。
			public final class Inet4Address extends InetAddress
			public final class Inet6Address extends InetAddress
		很多时候，你不需要关心一个地址是IPV4地址还是IPV6地址。在java程序处于的应用层，你不需要知道这个（即使你需要知道，检查getAddress()返回的字节数组的大小要比使用instanceof来检查你拥有的子类的类型要快）。Inet4Address重写了InetAddress的很多方法，但是并不会改变任何公共方法的行为。Inet6Address是相似的，但它提供了一个超类中没有的方法，isIPv4CompatibleAddress(): public boolean isIPv4CompatibleAddress()。这个方法只有在地址本质上是一个装载在IPV6容器内的IPV4时才返回true。这就意味这只有地址的最后4个字节不是0。也就是说，地址的格式是0:0:0:0:0:0:0:xxxx。如果是这种情况，你可以从getBytes()返回的字节数组中，将最后4个字节拉出来，并且使用这个数据来创建一个替代的Inet4Address。然而，你基本不需要这么做。
	NetworkInterface类
		NetworkInterface代表一个本地的IP地址。这既可以是一个物理接口，比如，一个额外的以太网卡（通常是在防火墙或路由器上），或者是绑定在同一物理硬件上的虚拟接口来作为机器的其他IP地址。NetworkInterface类提供了方法来枚举所有的本地地址，不考虑接口，为他们创建相应的InetAddress对象。这些InetAddress可以用来创建socket，server socket等等。
		工厂方法
			因为NetworkInterface对象代表物理硬件和虚拟地址，他们不能被任意的构造。就像InetAddress类一样，有静态的工厂方法来返回和特定的网络接口相关的NetworkInterface对象。你可以通过IP地址，名字或枚举来获取一个NetworkInterface。
			public static NetworkInterface getByName(String name) throws SocketException
				getByName()返回一个NetworkInterface对象，它代表具有指定名字的网络接口。如果没有该指定名字的网络接口，它将返回null。如果在定位相关的网络接口时，底层的网络栈遭遇到了问题，那么将抛出一个SocketException，但这几乎不可能发生。
				名字的格式是平台相关的。在一个典型的Unix系统上，以太网接口的名字的格式是eth0,eth1等等。本地回环地址可能命名为像“lo”。在windows上，名字会是一些像“CE31”或“ELX100”的字符串，这些字符串是从特定网络接口的卖家的名字或硬件的型号中提取出来的。
			public static NetworkInterface getByInetAddress(InetAddress address) throws SocketException
				getByInetAddress()方法返回一个NetworkInterface对象，它代表绑定到指定IP地址的网络接口。如果在本地主机上，没有网络接口绑定到哪个IP地址，它将返回null。如果任何事情出错，它将抛出SocketException。
			public static Enumeration getNetworkInterfaces() throws SocketException
				getNetworkInterfaces()方法返回一个java.util.Enumeration，它列出了本地主机的所有网络接口。
		Getter方法
			一旦你有一个NetworkInterface对象，你可以查询它的IP地址和名字。这也可能是你唯一可以对它做的事情了。
			public Enumeration getInetAddresses()
				一个网络接口可能绑定到多个IP地址。getInetAddresses()方法返回一个java.util.Enumeration，它列举了绑定在接口上的所有IP地址的InetAddress对象。
			public String getName()
				该方法返回特定的NetworkInterface对象的名字，比如eth0或lo。
			public String getDisplayName()
				该方法为特定的NetworkInterface返回一个更人性化的名字，比如“Ethernet Card 0.”之类的。
	一些有用的程序
		


第5章 URL和URI
	URL是URI（uniform resource identifier）最普通的一种类型。URI能够像URL那样通过网络地址来定位一个资源，或者通过它的名字，数字或其他字符。
	URL类是java程序用来从网络上定位和获取数据的最简单的方法。你不需要担心使用到的协议的细节，或如何和服务器交互，你只需要告诉java URL是什么，它会帮你获取到数据。
	URI
		Uniform Resource Identifier(URI)是一个用来标识资源的，具有特定语法的字符串。
		URI的语法由一个模式和一个模式特定的部分，通过一个冒号分割，像这样：scheme:scheme-specific-part。模式特定部分的语法依赖于被使用的模式，当前的模式包括：
			data
				Base64-encoded data included directly in a link; see RFC 2397
			file
				A file on a local disk
			ftp
				An FTP server
			http
				A World Wide Web server using the Hypertext Transfer Protocol
			mailto
				An email address
			magnet
				A resource available for download via peer-to-peer networks such as BitTorrent
			telnet
				A connection to a Telnet-based service
			urn
				A Uniform Resource Name
		另外，java大量使用了非标准的自定义协议，比如rmi，jar，jndi，doc，为了各种目的。
		对于所有URI中的模式特定的部分，没有指定的语法。然而，很多会有一个层级的格式，像这样：//authority/path?query。URI中的authority部分指明了负责解析URI剩下的部分的当局。比如，URI http://www.ietf.org/rfc/rfc3986.txt的scheme为http，authority为www.ietf.org，path为/rfc/rfc3986.txt（包括初始的斜线）。这就意味着www.ietf.org的服务器负责映射路径/rfc/rfc3986.txt到一个资源。这个URI不包含一个查询部分。URI http://www.powells.com/cgi-bin/biblio?inkey=62-1565928709-0的scheme为http，authority为www.po‐
wells.com，path为/cgi-bin/biblio，查询为inkey=62-1565928709-0。URI urn:isbn:156592870的scheme为urn，但是在模式特定的部分并没有遵循//authority/path?query的层级格式。
		虽然当前的大多数的URI的例子都使用一个Internet主机来作为authority，将来可能不是这样。然而，如果authority是一个Internet主机，可选的用户和端口信息可以被提供来使authority更指定。比如URI ftp://mp3:mp3@ci43198-a.ashvil1.nc.home.com:33/VanHalen-Jump.mp3的authority为mp3:mp3@ci43198-a.ashvil1.nc.home.com:33，该authority包含用户名mp3，密码mp3，主机ci43198-a.ashvil1.nc.home.com，以及端口33，scheme位ftp，path为/VanHalen-Jump.mp3。在很多情况下，将密码包含在URI中是一个很大的安全漏洞。
		path是一个字符串，authority使用它来决定哪个资源被标识。不同的authority可能会将相同的path解释为指向不同的资源。path可能是层级的，在这种情况下，单独的部分以前斜线分割，并且.和..操作符被用来在层级见进行导航。这些是从web和URL被发明的Unix操作系统的路径语法中得来的。他们可以很便利的映射到一个Unix
web服务器的文件系统上，但是不保证任何特定路径的组成部分实际上都和任何特定文件系统的文件或目录一致。
		schema部分是由小写字母，数字，加号，句号和连字符号组成。典型的URI的其他三个部分（authority,path,query），每一部分都应该由ASCII的字母，数字字符组成（比如，a-z,A-Z,0-9）。另外，标点符号字符-,_,.,!,~也可以被使用。分割符，比如，/？&和=将会被以他们预先定义的目的被使用。所有其他的字符，包括非ASCII字母数字字符，比如ζ，不被当作分割符使用的分割符字符，应该被以%加上该字符以UTF-8编码后的16进制的代码来表示。比如，在UTF-8中，á是两个字节0xC3 0xA1，因此它将被编码为%c3%a1。中文字符“木”的Unicode code point是0x6728，在UTF-8中，它被编码为3个字节E6, 9C,和A8，因此，它在URI中将被编码为%E6%9C%A8。
		如果你没有像这样以16进制的格式编码一个非ASCII字符，而是直接使用他们，那么你得到的是一个IRI（Internationalized Resource Identifier），而不是URI。IRI更容易被输入和读取，但大多数软件和协议只期待和支持ASCII格式的URI。
		标点符号字符，比如/和@，如果在特定的URI的scheme特定部分中，不是以他们指定的角色来被使用，就应该以%的形式被转义。
		URL
			URL是一个URI，也能标识一个资源，为资源提供一个特定的网络地址，客户端能够使用它来获取资源。相比之下，一般性的URI告诉你资源是什么，但是不会实际告诉你在哪儿或如何获取这个资源。在java中，java.net.URI类只能标识资源，java.net.URL类既能标识资源，又能获取资源。
			URL的语法是：protocol://userInfo@host:port/path?query#fragment。
			path指向特定服务器上的特定资源。它通常看起来像一个文件系统路径，比如/forum/index.php，然而，实际上，它可能会，也可能不会映射到一个服务器的文件系统。如果它确实映射到一个文件系统，路径也是相对于服务器的document root，而不是服务器的文件系统的根目录。有一个规则，一个向公众开放的服务器，不会完全将他们的文件系统展示给客户端，他们只展示指定目录的内容。这个目录被称为document root，所有的目录和文件名都是相对于它的。因此，在一个unix服务器上，所有对公共可用的文件可能在/var/public/html中，但是对于从远程机器连接的人来说，这个目录看起来就像文件系统的根目录。
		相对URL
			URL如果是不完整的，并且会从他们的祖先继承部分片段的URL称为相对URL。相对来说，一个完全指定的URL称为绝对URL。在一个相对URL中，缺失掉的任何片段都被认为和该URL被发现的文档的URL的相应的片段相同。比如，假设当浏览http://www.ibiblio.org/javafaq/java‐tutorial.html时，你点击了连接<a href="javafaq.html">，浏览器将http://www.ibiblio.org/javafaq/java‐tutorial.html结尾的javatutorial.html砍掉，得到http://www.ibiblio.org/javafaq/。然后，它附加javafaq.html到http://www.ibiblio.org/javafaq/的结尾，来得到http://www.ibiblio.org/javafaq/java‐faq.html。最终，它加载那个文档。
			如果相对连接起始于/，那么它就是相对于document root，而不是当前文件，因此，当你在浏览http://www.ibiblio.org/javafaq/javatutorial.html时，在下面的连接上点击<a href="/projects/ipv6/">时，浏览器将会丢掉/javafaq/javatutorial.html，并且附加/projects/ipv6/到http://www.ibiblio.org的结尾，来得到http://www.ibiblio.org/projects/ipv6/。
			相对URL有一些优点，首先，最不重要的是他们节省了输入。更重要的是，允许单一的文档树被使用多个协议来服务，比如，http和ftp。http可用来直接浏览，ftp能够被用来镜像站点。最重要的是，相对URL允许整个文档数被从一个站点一个站点移动或拷贝到另一个站点，而不会损坏任何内部的连接。
	URL类
		java.net.URL类是URL的一个抽象，它继承自java.lang.Object，它是一个final类，因此不能被继承。不是通过继承来配置不同类型的URL实例，它使用策略设计模式。协议处理器是策略，URL类自己组成了被选择的不同策略的上下文。
		虽然以字符串的形式来存储URL是不重要的，但是，将URL想成一个对象是很有用的，该对象包含scheme(a.k.a. the protocol), hostname, port, path, query string, and fragment identifier(a.k.a. the ref)这些字段，他们中的每一个都可以被独立的设置。事实上，这个基本就是java.net.URL类如何被组织的，虽然，不同版本的java中的细节会有一些不同。
		URL是不可变的，在URL对象被构造之后，它的字段不能被改变。这个的副作用是是它线程安全。
		创建新的URL
			不像InetAddress对象，你可以构造java.net.URL的实例。构造函数依据他们需要的信息而不同：
				public URL(String url) throws MalformedURLException
				public URL(String protocol, String hostname, String file) throws MalformedURLException
				public URL(String protocol, String host, int port, String file) throws MalformedURLException
				public URL(URL base, String relative) throws MalformedURLException
			使用哪个构造函数取决于你拥有的信息以及他们的格式。如果你尝试使用一个不支持的协议来创建一个URL，或者URL的语法是错误的，这些构造函数都会抛出一个MalformedURLException。
			具体的哪个协议被支持是实现相关的。对所有的虚拟机可用的协议只有http和file。后面的这个是臭名昭彰的。今天，java也支持https, jar, 和ftp协议，一些虚拟机也支持mailto和gopher，以及一些自定义的协议，比如doc, netdoc, systemresource, 和verbatim，他们都被java在内部使用。
			除了核查它是否认识URL模式，java不会检查它构造的URL的正确性，程序员来负责确保创建的URL是有效的。
			从一个String来构造一个URL
				最简单的URL构造函数只使用一个String格式的绝对URL来作为它的单一参数：public URL(String url) throws MalformedURLException
				就像所有的URL构造函数一样，它会抛出一个MalformedURLException异常。
			从它的组成部分来构造一个URL
				你也可以通过指明协议，主机名和文件来构造一个URL：
					public URL(String protocol, String hostname, String file) throws MalformedURLException
				这个构造函数将端口字段设置为-1，因此协议的默认端口将被使用。file参数应该起始于一个斜梗，并且包含路径，文件名，和可选的片段标识符。忘记起始的斜梗是常见的错误。就像所有的URL构造函数，它能抛出一个MalformedURLException。
			使用相对路径来构造URL
				这个构造函数从一个基本URL和一个相对URL来构造一个绝对的URL：
					public URL(URL base, String relative) throws MalformedURLException
				比如，你可能在解析一个http://www.ibiblio.org/javafaq/index.html指向的html文档，遇到了一个指向mailinglists.html文件的连接，没有更多的进一步的信息。在这种情况下，你使用包含这个连接的文档的URL来提供丢失的信息。构造函数计算得到的新的URL为http://www.ibiblio.org/javafaq/mailinglists.html。
				比如：
					try {
						URL u1 = new URL("http://www.ibiblio.org/javafaq/index.html");
						URL u2 = new URL (u1, "mailinglists.html");
					} catch (MalformedURLException ex) {
						System.err.println(ex);
					}
				这个构造函数在你想要循环某个目录内的一个文件列表时尤其有用。你可以为第一个文件构造一个URL，然后通过这个初始的URL来为其他的文件构造URL，通过替代他们的文件名。
			URL对象的其他来源
				除了这里讨论的构造函数，java类库中有一些其他方法也会返回URL对象。在applet中，getDocumentBase()返回包含该applet的页面的URL，getCodeBase()返回该applet.class文件的URL。java.io.File类有一个toURL()方法返回一个符合给定文件的file类型的URL。这个方法返回的URL的精确格式是平台相关的。比如，在windows上，它返回的可能是file:/D:/JAVA/JNP4/05/ToURLTest.java，在Linux或其他类Unix上，它返回的可能是file:/home/elharo/books/JNP4/05/ToURLTest.java。在实践中，file类型的URL是严重的平台和程序依赖的。
				类加载器不只可以用来加载类，也可以用来加载资源，比如图片或声音文件。静态的ClassLoader.getSystemResource(String name)方法返回一个URL，通过它，一个单一的文件能够被读取。ClassLoader.getSystemResources(String name)方法返回一个Enumeration，它包含一个URL的列表，通过他们，指定名字的资源可以被读取。最后，实例方法getResource(String name)查找参考的类加载器使用的路径来获得一个指向命名的资源的URL。这些方法返回的URL可能是文件URL，http URL，或一些其他的格式。资源的完整路径是一个包格式的java名字，并且使用斜线代替点，比如/com/macfaq/sounds/swale.au或com/macfaq/images/headshot.jpg。java虚拟机将尝试在classpath中查找请求的资源，潜在的可能存在于一个jar存档中。
		从URL对象中获取数据
			URL类有很多方法来从URL中获取数据：
				public InputStream openStream() throws IOException
				public URLConnection openConnection() throws IOException
				public URLConnection openConnection(Proxy proxy) throws IOException
				public Object getContent() throws IOException
				public Object getContent(Class[] classes) throws IOException
                       	这些方法中最基本也是最常用的方法是openStream()，它返回一个InputStream，你可以通过它来读取数据。如果你需要对下载过程有更多的控制，相应的调用openConnection()，它将返回一个URLConnection，你可以配置它，然后从它获取一个InputStream。最后，你可以通过getContent()来请求该URL的内容，它将给你返回一个更完整的对象，比如String或Image。其次，它可能无论如何都会给你返回一个InputStream。
			openStream()方法连接到该URL引用的资源，执行客户端和服务器端的任何必须的握手，并且返回一个InputStream，你可以从它里边读取数据。你从该InputStream读取的数据是URL指向的资源的原生的内容：如果你在读取ASCII文本，那么数据是ASCII字符；如果你在读取HTML文件，那么数据是原生的html；如果你在读取图片文件，那么数据将是二进制的图片数据，等等。它不会包含任何的http头或任何其他协议相关的信息。你可以像读其他InputStream一样，从该InputStream读取数据。
			openConnection()方法打开一个socket到一个指定的URL，并且返回一个URLConnection对象。一个URLConnection标识了到一个网络资源的打开的连接。如果调用失败，openConnection()将抛出一个IOException。
			当你像直接和服务器通信时，你应该使用这个方法。URLConnection可以让你访问将要发送到服务器的任何东西：除了原生格式的文档，你可以访问协议指定的所有metadata。比如，如果模式是http或https，URLConnection允许你访问http头和原生的html。URLConnection也允许你像从URL读取数据那样，写出数据。比如，为了发送数据到一个mailto的URL或提交表单数据。
			该方法的一个重载的变种是指明要来传送连接的代理服务器：
				public URLConnection openConnection(Proxy proxy) throws IOException
			这个将覆盖任何通过平常的socksProxyHost, socksProxyPort, http.proxyHost, http.proxyPort, http.nonProxyHosts，和相似的系统属性设置的代理服务器。如果协议处理器不支持代理，这个参数将被忽略，如果可能的话，连接将会被直接建立。
			getContent()方法是用来下载URL引用的数据的第三种方法，getContent()方法获取URL引用的数据，并且尝试将它转换成一些类型的对象。如果URL引用的是一些类型的文本，比如ASCII或HTML文件，返回的对象通常是一些类型的InputStream。如果URL引用的是一个图片，比如GIF或JPEG，getContent()通常返回一个java.awt.ImageProducer。
			getContent()通过查看从服务器获取的数据的头中的Content-type字段来操作。如果服务器没有使用MIME头，或发送了一个不熟悉的Content-type，那么getContent()将返回某种类型的InputStream，可以通过它来读取数据。如果对象不能被获取，一个IOException将会被抛出。
			使用getContent()的一个最大的问题是：很难预测你将得到那种类型的对象。你可能得到某些类型的InputStream，或者是一个ImageProducer，或者是一个AudioClip，很容易通过instanceof操作符来检测。这些信息应该足够让你读取一个文本文件或显式一个图片。
			public final Object getContent(Class[] classes) throws IOException
			一个URL的内容处理器可以提供统一个资源的不同视图。这个重载变种的getContent()方法允许你选择该方法返回的对象的类型。这个方法尝试以第一个可用的格式来返回URL的内容。
		将URL分成块
			URL由5个块组成：
				schema，也可以叫协议
				authority
				path
				fragment identifier
				query string
			authority可能被进一步分成用户信息，主机和端口。
			以只读的方式来访问URL的这些部分被通过9个公共方法来提供：get File(), getHost(), getPort(), getProtocol(), getRef(), getQuery(), getPath(),getUserInfo(), 和getAuthority().
			如果在URL中没有指明端口，getPort()将返回-1来表明URL没有显式的指明端口，此时，协议默认的端口将被使用。
			getDefaultPort()方法返回在URL没有指明端口时，该URL协议将使用的默认的端口。如果这个协议没有定义默认的端口，getDefaultPort()方法将返回-1。
			getFile()方法返回一个字符串，它包含一个URL中的path部分。记住，java不会将URL分割成单独的path和file部分。从主机名后的第一个斜线开始，直到代表一个fragment identifier的#号之前的字符都被认为是file的一部分。如果URL不包含一个file部分，java会设置file为空字符串。
			getPath()方法和getFile()很像，它也返回一个字符串，包含了一个URL的path和file的部分。然而，不像getFile()，在它返回的字符串中不包括query部分，只是path。
			如果一个URL不包括一个fragment identifier，getRef()方法将返回null。
			如果一个URL不包括一个query，getQuery()方法将返回null。
			如果一个URL不包括任何user info，getUserInfo()将返回null。
			mailto类型的URL可能表现的不像你期望的那样。在一个像mailto:elharo@ibiblio.org的URL中，“elharo@ibiblio.org”是path，而不是用户信息或主机。这是因为URL指明了远程消息的接受者，而不是消息要发送到的用户名和主机。
			处于URL的schema和path之间的部分就是authority了。
		相等性和比较
			URL类包含通常的equals()和hashCode()方法，他们的行为基本和你期望的一致。两个URL被认为相同，只有当这两个URL都指向相同的资源，在相同的host，port，path，以及相同的fragment identifier和query。然而，这没有什么奇怪的。equals()实际上会尝试通过DNS来解析主机，来判断两个主机是否相同。
			另一方面，equals()并不只是比较两个URL标识的资源。比如，http://www.oreilly.com/和http://www.oreilly.com/index.html是不相等的。
			URL没有实现Comparable接口。
			URL类还有一个sameFile()方法来检测是否两个URL指向相同的资源：public boolean sameFile(URL other)。它的比较本质上是和equals()相同的，也包括DNS查询，除了sameFile()不会考虑fragment identifier。当比较http://www.oreilly.com/index.html#p1和http://www.oreil‐ly.com/index.html#q2时，sameFile()将返回true，equals()将返回false。
		转换
			URL有三个方法来转换一个实例到其他的格式：toString(), toExternalForm(), and toURI().
			toString()方法返回的字符串总是一个绝对的URL。显式的调用toString()并不常见。在print块中toString()会被隐式的调用。在print块之外，更恰当的是替代的使用toExternalForm()。
			toExternalForm()会将URL对象转化成一个可以使用来作为HTML连接或web浏览器打开URL对话框中的字符串。它和toString()方法是一致的，实际上，所有的toString()都是返回toExternalForm()的值。
			最后，toURI()方法将一个URL对象转换成一个相当的URI对象：public URI toURI() throws URISyntaxException
			URI类会提供比URL类更精确，更规范一致行为。对于像绝对化和编码这类操作，在你可选的情况下，你应该选择URI类。在你想要将URL存储到hashtable或其他数据结构中时，你应该使用URI，因为它的equals()方法是非阻塞的。URL类应该被主要使用在当你想要从一个服务器下载内容时。
	URI类
		URI是URL的一般化，它不仅包括URL（Uniform Resource Locators），还包括URN（Uniform Resource Names）。在实践中用的最多的URI就是URL，但是很多规范和标准，比如XML，是依据URI来定义的。在java中，URI使用java.net.URI类来表示。这个类和java.net.URL类有三个重要的不同：
			URI类只是用来标识资源和URI的解析。它没有提供方法来获取该URI标识的资源
			URI类要比URL类和相关的规范更一致。
			URI对象可以表示一个相对的URI。URL类在存储所有的URI之前，会绝对化该URI。
		简单来说，URL对象是一个应用层协议的展示，它能被用来进行网络获取，然而，URI对象只是用来进行字符串的解析和操作，URI类没有网络获取能力。URL类有一些字符串解析方法，比如getFile()和getRef()，但是他们中的很多都是坏的，他们的行为不总是和相关的规范的定义完全一致。通常，当你想要下载一个URL的内容时，应该使用URL类，当你想要进行资源标识，而不是获取时，比如展示一个XML的命名空间，应该使用URI类。当你两个都需要时，你可以在使用URI的toURL()和URL的toURI()方法来在两个之间转换。
		构造一个URI
			URI从字符串构建而来，你可以给构造函数传递一个单一的字符串，也可以是单独的片段：
				public URI(String uri) throws URISyntaxException
				public URI(String scheme, String schemeSpecificPart, String fragment) throws URISyntaxException
				public URI(String scheme, String host, String path, String fragment) throws URISyntaxException
				public URI(String scheme, String authority, String path, String query, String fragment) throws URISyntaxException
				public URI(String scheme, String userInfo, String host, int port, String path, String query, String fragment) throws URISyntaxException
			不像URL类，URI类不会依赖底层的协议处理器。只要URI是语法正确的，在创建一个URI对象时，java不需要理解它的协议。因此，不像URL类，URI类能够用于新的或实验性的scheme。
			如果一个字符串参数没有遵循URI的语法规则，比如，如果URI起始于一个冒号，构造函数将抛出一个URISyntaxException。这是一个检测的异常，所以或者捕获它，或者声明调用该构造函数的方法抛出该异常。和URI规范矛盾的是，URI使用的字符没有限制为ASCII，他们可以包含其他Unicode字符。从语法上来说，URI有很少的限制，特别是当编码非ASCII字符的需求被移除后，以及相对URI也被允许的情况下。基本所有的字符串都能被解释为URI。
			第二个构造函数有一个指定scheme的部分，它大多数时候被用于非层级化的URI。这个scheme是URI的协议，比如http, urn, tel等等。它必须只能由ASCII字母，数字和+，-，.三个标点符号组成，并且必须以字母开头。给这个参数传递null代表省略了scheme，因此创建了一个相对的URI。
			由于URI类会用%转义的形式编码非法字符，因此实际上你不可能在这部分上产生语法错误。
			最后，第三个参数包含fragment identifier。同样，fragment identifier中的字符会被自动的强制转义。向该参数传递null，是简单的忽略这部分。
			第三个构造函数通常用于层级化的URI，比如http和ftp的URI。
			如果构造函数不能从提供的片段中构造一个合法的层级化的URI，比如，如果提供了scheme，所以该URI应该是绝对的，但如果path不是以/开头，那么将抛出一个URISyntaxException。
			第四个构造函数和第三个构造函数基本相同，只是多了一个query字符串
			像平常一样，任何不可转义的语法错误将导致一个URISyntaxException被抛出，可以通过传递null来省略任何参数。
			第五个构造函数是层级化的URI的构造函数，前面两个构造函数都会调用它。它将authority分割成user info，host，port部分，每一部分都有它自己的语法规则。
			如果你确定你的URI是合法的，并且不会违反任何的规则，你可以使用静态的URI.create()方法来替代。不像构造函数，它不会抛出URISyntaxException。如果URI被证明是畸形的，这个方法将抛出IllegalArgumentException异常。这是一个运行时异常，所以你不需要显式的声明它或捕获它。
		URI的组成部分
			URI会有至多3个部分：scheme，scheme-specific part和fragment identifier。大概的格式是：scheme:scheme-specific-part:fragment
			如果scheme被省略，URI就是相对的。如果fragment identifier被省略，URI是一个纯粹的URI。URI类有getter方法来返回这三个部分。getRawFoo()方法返回URI部分编码后的格式，相应的getFoo()会先解码任何%转义的字符，然后返回解码后的部分。
				public String getScheme()
				public String getSchemeSpecificPart()
				public String getRawSchemeSpecificPart()
				public String getFragment()
				public String getRawFragment()
			没有getRawScheme()方法是因为URI规范已经规定了scheme部分的组成。
			如果特定的URI对象没有相关的组成部分，这些方法都将返回null。
			有scheme部分的URI是绝对URI，没有scheme部分的URI是相对的URI。如果URI是绝对的，那么isAbsolute()将返回true，否则，返回false。
			scheme-specific part的细节依赖于scheme的类型。如果URI是层级的，那么isOpaque()将返回false，如果URI不是层级的，那么将返回true。	
			如果URI是不透明的，那么你可以得到的所有的东西是：scheme，scheme-specific part，fragment identifier。无论怎样，如果URI是层级的，它有针对层级的URI的不同部分的getter方法。
				public String getAuthority()
				public String getFragment()
				public String getHost()
				public String getPath()
				public String getPort()
				public String getQuery()
				public String getUserInfo()
                         所有的这些方法都返回解析后的部分，如果你想要URI中的原生的，未解析的部分，有5个getRaw_Foo_()方法：
				public String getRawAuthority()
				public String getRawFragment()
				public String getRawPath()
				public String getRawQuery()
				public String getRawUserInfo()
                         URI类和URI规范的不同之处在于：非ASCII字符起初并没有被转义，因此仍然能够在getRawFoo()返回的字符串中展示出来，除非你用来构造URI的字符串是已经经过转义的。
			没有getRawPort()和getRawHost()方法，是因为这些部分总是被保证由ASCII字符组成。
			当URI没有包含指定部分的信息时，相应的方法返回null。getPort()方法是个例外，因为它声明为返回一个int，它不能返回null。相替代的，它返回-1来表明端口被省略。
			由于很多没有实际影响的技术原因，java起初不能检测出authority部分的语法错误。这导致的最直接的问题就是不能返回authority中的单独的部分，比如user，host，port。在这种情况下，你可以调用parseServerAuthority()来强制authority被重新解析。原始的URI不会发生变化（URI对象是不可变的），但是这个方法返回的URI将会有独立的authority的部分：user，host，port。如果authority不能被解析，URISyntaxException将会被抛出。
		解析一个相对的URI
			URI类有3个方法来在相对和绝对URI之间进行转化：
				public URI resolve(URI uri)
				public URI resolve(String uri)
				public URI relativize(URI uri)
		        resolve()方法比较uri参数和自己的URI对象，来构造一个新的URI对象，它包含一个绝对的URI。如果调用方法的URI本身不是一个绝对的URI，resolve()方法将会进最大努力去解析，返回一个新的相对的URI对象。比如：
				URI top = new URI("javafaq/books/");
				URI resolved = top.resolve("jnp3/examples/07/index.html");
			在执行后，resolved包含的相对的URI是javafaq/books/jnp3/examples/07/index.html。
			也有可能反转这一过程，也就是从一个绝对的URI来获得一个相对的URI。relativize()方法创建一个新的URI对象，该对象是uri参数相对于调用该方法的URI对象的，相对的，新的URI对象。参数不会被改变。比如：
				URI absolute = new URI("http://www.example.com/images/logo.png");
				URI top = new URI("http://www.example.com/");
				URI relative = top.relativize(absolute);
			relative现在包含相对的URI：images/logo.png
		相等和比较
			URI测试相等的方式基本和你期望的一样。他不是直接的字符串比较。相等的URI必须要么都是层级的，要么都是不透明的。scheme和authority部分的比较是不区分大小写的。URI剩下的部分是大小写敏感的，除了用来转义非法字符的16进制字符。转义在比较时不会被解码，比如http://www.example.com/A和http://www.example.com/%41是不相等的。
			hashCode()方法和相等方法是一致的。
			URI实现了Comparable，因此它能被排序。排序是基于各个独立部分的字符串比较，顺序是这样的：
				1. 如果scheme不同，那么scheme以不区分大小写的方式来比较。
				2. 如果scheme相同，那么层级的URI会被认为小于不透明的URI。
  				3. 如果两个URI都是不透明的，那么他们的顺序依赖于他们的scheme-specific部分。
				4. 如果scheme和不透明的scheme-specific部分是相同的，再通过他们的frament部分进行比较。
				5. 如果两个URI都是层级的，他们的顺序依赖于authority部分，这部分的顺序又依赖于user info，host和port。host部分是不区分大小写的。
				6. 如果scheme和authority部分是相同的，在比较path。
				7. 如果path相同，再比较query。
				8. 如果query相同，再比较fragment。
			URI只能和URI类型的进行比较，把URI类和其他类做比较会抛出ClassCastException。
		字符串展示
			有两个方法用来将URI对象转化位字符串，toString()和toASCIIString()：
				public String toString()
				public String toASCIIString()
			toString()方法返回一个未编码格式的字符串。因此，调用这个方法的结果不保证是一个句法上正确的URI，虽然事实上，它是一个句法上正确的IRI。这种格式通常在展示给人时很有用，但在用来获取数据时不是很有用。
			toASCIIString()方法返回一个编码后格式的URI。大多数时候，应该使用这种格式的字符串。toASCIIString()总是返回一个句法上正确的URI。
	x-www-form-urlencoded
		web设计者面临的一个挑战就是操作系统之间的不同。为了解决这些问题，URL使用的字符必须来自于ASCII的一个固定的字符集。明确的：
			1. 大写字母A-Z
			2. 小写字母a-z
			3. 数字0-9
			4. 标点符号：-_.!~*',
		字符/ & ? @ # ; $ + = 和 %也可以被使用，但是只能用于他们特定的目的。如果这些字符出现在URI的某一个独立的部分中，这些字符应该被编码。
		编码很简单。需要编码的字符会被编码为一个%，跟上两个16进制的数字。空格是一个特殊的情况，它能被编码为一个+号。+号自己被编码为%2B。
		URL类不能自动的进行编码和解码。你可以使用非法ASCII字符，非ASCII字符和/或%转义符来构造一个URL对象。这些字符当通过输出方法，比如getPath()和toExternalForm()，输出时不会自动的编码或解码。确保用来构造URL对象的字符串中的所有字符都被恰当的编码是你自己的责任。
		幸运的是，java提供了URLEncoder和URLDecoder类来将字符串转换成这种格式
		URLEncoder
			为URL编码一个字符串，将字符串和字符集的名字（编码方式）传递给URLEncoder.encode()方法，比如：
				String encoded = URLEncoder.encode("This*string*has*asterisks", "UTF-8");
			URLEncoder.encode()返回一个做了一些改变的，输入字符串的改变。任何非字母数字字符都被转义为%转义的形式（除了空格，底杠，连字号，点号，星号）。它也编码所有非ASCII字符。空格被转换为一个+号。这个方法有点过于积极，它也转换波浪符，单引号，惊叹号，圆括号为%转义的形式，即使他们完全不需要这样做。不管怎样，这些改变都不是URL规范所强制的，所以web浏览器会合理的处理这些过分编码的URL。
			虽然这个方法可以允许你指定编码方式，但你应该使用的只有UTF-8这一种。相比于你可以选择的其他编码方式，UTF-8兼容于IRI规范，URI类，现代的web浏览器，以及很多额外的软件。
			当源码中包含非ASCII字符时，编码方式应该以参数的形式传递给编译器来解释源码中的非ASCII字符。比如：
				javac -encoding UTF8 EncoderTest
			注意，实际上这个方法会编码/，&，=和：。它不会尝试判断这些字符对URL意味着什么。导致的结果是，你应该一个片段一个片段的编码URL，而不是在一次方法调用中一次编码整个URL。这个很重要，因为URLEncoder最通常的用法是，在使用GET和服务器端通信时，准备查询字符串的。比如，你想要编码这个用于google查询的URL
				https://www.google.com/search?hl=en&as_q=Java&as_epq=I/O
			编码的代码片段为：
				String query = URLEncoder.encode("https://www.google.com/search?hl=en&as_q=Java&as_epq=I/O", "UTF-8");
				System.out.println(query);
			不幸的是，输出是这样的：
				https%3A%2F%2Fwww.google.com%2Fsearch%3Fhl%3Den%26as_q%3DJava%26as_epq%3DI%2FO
			问题在于URLEncoder.encode()是盲目的编码，它不能区分对URL有特殊意义的特殊字符和查询字符串。因此，URL需要被一个片段一个片段的被编码。
		URLDecoder
			相应的URLDecoder有一个静态的decode()方法，它用来解码以x-www-form-url-encoded格式编码的字符串。也就是，它会转换所有的+号为空格，以及所有的%转义符到他们相应的字符。如果你对编码方式有任何的顾虑，那就选择UTF-8，它相对于其他的来说，更可能是对的。
			如果字符串包含一个%，但并不是跟着两个16进制数字，或者被解码认为是非法的序列时，将抛出IllegalArgumentException。
			因为URLDecoder不会处理非转义字符，你可以传递整个URL，而不用首先将它分割成片段。
	代理
		有时候使用代理是出于安全原因，比如阻止远程主机知道关于本地网络配置的私有的细节。有时，他是通过过滤外出的请求，并限制哪些站点可以被查看来阻止本地用户访问禁止的站点。有时是处于性能的考虑，它允许多个用户从缓存里获取已经请求过的文档。
		基于URL的java程序能够和大多数的代理服务器和协议一起工作。这也是你可能想要选择URL类，而不是自己在原生socket的基础上处理HTTP或其他客户端的一个原因。
		系统属性
			对于基本的操作，你需要做的就是设置一些系统属性，来指定你的本地代理服务器的地址。如果你正在使用一个纯粹的HTTP代理，设置http.proxyHost
为域名或你的代理服务器的IP地址，设置http.proxyPort为代理服务器的端口（默认是80）。可以有很多方法来实现这个，包括在java代码中调用System.setProperty()或在启动程序时通过-D参数来指定。
			如果你的代理服务器需要一个用户名和密码，你将需要安装一个Authenticator。
			如果你不像某个站点被代理，而是直接进行连接，你可以设置http.nonProxyHosts为它的主机名或IP地址。如果要排除多个主机，可以用|来分割他们。
			你也可以使用*号作为通配符，来指明某个域或子域中的所有主机都应该不被代理。
			如果你正在使用FTP代理服务器，以相同的方式设置ftp.proxyHost, ftp.proxyPort, 和ftp.nonProxyHosts
			java不支持任何其他的应用层的代理，但如果你正在为所有的TCP连接使用一个传输层的SOCKS代理，你可以通过socksProxyHost和socksProxyPort系统属性来指定它。java不提供任何关于SOCKS的设置某些站点不使用代理的选项，它是要么所有的都代理，要么所有的都不代理。
		Proxy类
			Proxy类允许在java程序中对代理服务器进行更细粒度的控制。尤其是，它允许你针对不同的远程主机选择不同的代理服务器。代理是通过java.net.Proxy类的实例来展示的。它仍然是只有3中形式的代理：HTTP, SOCKS和直接连接（即不使用代理），通过Proxy.Type枚举的三个常量来表示：
				• Proxy.Type.DIRECT
				• Proxy.Type.HTTP
				• Proxy.Type.SOCKS
			除了它的类型，关于代理的其他重要的信息就是它的地址和端口，这个是通过一个SocketAddress对象来设置的。
			虽然只有三种类型的Proxy，允许有相同类型的多个proxy作为不同主机的不同的代理服务器。
		ProxySelector类
			每个运行的java虚拟机都只有一个java.net.ProxySelector对象，它被用来为不同的连接选择代理服务器。默认的ProxySelector仅仅检查不同的系统属性和URL的协议来决定如何连接到不同的主机。你可以安装自定义的ProxySelector的子类，使用它来选择不同的代理。
			这个类的关键是抽象的select()方法：
				public abstract List<Proxy> select(URI uri)
			java向该方法传递一个URI对象（不是一个URL对象），它标识了需要被连接到的主机。ProxySelector对象为这种类型的对象选择正确的代理，并以List<Proxy>的形式返回。
			这个类中的另一个你必须实现的抽象方法是connectFailed()：
				public void connectFailed(URI uri, SocketAddress address, IOException ex)
			这是一个回调方法，用来警示程序，代理服务不能建立连接。
			因为每个java虚拟机只能有一个ProxySelector，为了改变ProxySelector，将新的selector传递给静态的ProxySelector.setDefault()，比如：
				ProxySelector selector = new LocalProxySelector():
				ProxySelector.setDefault(selector);
			从这个方法调用开始，所有被这个虚拟机打开的连接都将向新的ProxySelector请求来获取正确的代理。通常，你不应该在运行在共享的环境中的代码中使用这个方法。比如，你不应该在一个sevlet中改变ProxySelector，因为那将改变运行在相同container中的所有sevlet的ProxySelector。
	通过GET来和服务器端程序通信
		URL使得java applet和应用很容易和服务器端程序进行沟通，比如CGI，servlet，PHP页面，和其他使用get方法的程序。你只需要知道程序期望得到的名字和值的组合，然后你就可以构造一个含有query的URL，提供需要的名字和值。所有的名字和值必须是x-www-form-url-encoded格式的。可以使用URLEncoder.encode()。
		许多程序被设计用来处理表单输入。这种情况下form元素的method属性应该是get，用来处理表单的url由form的action属性提供，注意这个可能是一个相对的url，在这种情况下你需要决定相应的绝对的url。最后，form中的表单元素就是name-value对。
	访问有密码保护的站点
		许多流行的站点在访问时都需要提供用户名和密码，有些站点通过http验证来实现，有些则通过cookie和html表单来实现。java URL类能访问那些使用http验证的站点，当然你需要提供要使用的用户名和密码
		支持那些使用非标准的，基于cookie的验证的站点更具挑战性，不只是因为每个站点都不同。实现cookie的验证难免要实现一个完整的具有完全的html表单和cookie支持的web浏览器。访问那些由标准http验证保护的站点要更容易。
		Authenticator类
			java.net包包括了一个Authenticator类，你可以使用它为那些使用http验证保护的站点提供用户名和密码：
				public abstract class Authenticator extends Object
			因为Authenticator类是一个抽象类，你必须继承它。不同的子类可能通过不同的方式来获取信息。
			为了让URL使用该子类，你需要通过将它传递给静态的Authenticator.setDefault()来将它安装为默认的authenticator：
				public static void setDefault(Authenticator a)
			从你调用这个方法的地方开始，当URL类需要一个用户名和密码时，它将通过使用静态的Authenticator.requestPasswordAuthentication()方法来请求Authenticator：
				public static PasswordAuthentication requestPasswordAuthentication(InetAddress address, int port, String protocol, String prompt, String scheme) throws SecurityException
			address参数是需要验证的主机，port参数是主机的端口，protocol参数是访问该主机时使用的协议。http服务器提供prompt，它通常是需要采用的验证的realm的名字，scheme是要使用的验证的scheme，这个和protocol的scheme不同。更进一步，它是一个http验证的scheme，典型的是basic。
			不被信任的applet不被允许向用户要求用户名和密码。信任的applet可以，但是只有当他们持有requestPasswordAuthentication的NetPermission时才可以。否则，Authenticator.requestPasswordAuthentication()将抛出一个SecurityException。
			Authenticator的子类必须覆盖getPasswordAuthentication()方法。在这个方法中，你向用户或其他来源收集用户名和密码信息，并且以一个java.net.PasswordAuthentication实例的形式来返回它：
				protected PasswordAuthentication getPasswordAuthentication()
			如果你不想验证某个请求，返回null，java将告诉服务器它不知道如何验证这个连接。如果你提交了一个错误的用户名和密码，java将再次调用getPasswordAuthentication()，来让你有机会提供正确的数据。你通常只能尝试5次来获得正确的用户名和密码，在那以后，openStream()将抛出一个ProtocolException。
			用户名和密码被缓存在同一虚拟机的session中。一旦你针对realm设置了正确的用户名和密码，你将不会再被请求来获取用户名和密码，除非你显式的将包含密码的字符数组置为0来显式的删除密码。
			你可以通过调用从Authenticator超类继承的这些方法来获取关于请求的更多的细节：
				protected final InetAddress getRequestingSite()
				protected final int getRequestingPort()
				protected final String getRequestingProtocol()
				protected final String getRequestingPrompt()
				protected final String getRequestingScheme()
				protected final String getRequestingHost()
				protected final String getRequestingURL()
				protected Authenticator.RequestorType getRequestorType()
                        这些方法要么返回提供给requestPasswordAuthentication()的信息，要么返回null，当这些信息不可用时。（如果端口不可用，getRequestingPort()）返回-1。
			getRequestingURL()方法返回请求需要被验证的完整的URL，如果一个站点对不同的文件使用不同的用户名和密码，这个是一个很重要的细节。getRequestorType()方法返回两个命名常量中的一个（Authenticator.RequestorType.PROXY或Authenticator.RequestorType.SERVER）来指明是服务器还是代理服务器需要验证。
		PasswordAuthentication类
			PasswordAuthentication类是一个很简单的final类，它提供两个只读的属性：用户名和密码。用户名是String类型，密码是char数组，以便密码在不再被需要时可以被擦除。String在擦出之前只能等待垃圾回收器收集它，因此它可能存在于本地系统内存的某个地方，也有可能在磁盘上，当包含它的内存块被换出到虚拟内存上。用户名和密码都可以在构造函数中被设置：
				public PasswordAuthentication(String userName, char[] password)
			每个都可以通过get方法访问：
				public String getUserName()
				public char[] getPassword()
		JPasswordField类



第6章 HTTP
	Hypertext Transfer Protocol(HTTP)是一个标准，它定义了web客户端如何请求服务器端，以及服务器端如何将数据回传给客户端。虽然HTTP通常被想成是用来传输HTML文件以及嵌入在它之中的图片，但是HTTP是数据格式不可知论者（agnostic）。
	协议
		HTTP是用来在web客户端和web服务器端进行通信的标准协议。HTTP指定了一个客户端和服务器端如何建立一个连接，客户端如何向服务器端请求数据，服务器端如何对请求进行响应，最后，连接如何被关闭。HTTP连接使用TCP/IP协议进行数据传输。对于每一个从客户端发往服务器端的请求，有4个步骤：
			1. 客户端向服务器端的80端口打开一个连接。80端口是默认的，也可以在URL中指定一个其他端口。
			2. 客户端向服务器端发送一个消息，来请求指定路径的资源。请求包含一个头，以及可选的（依赖于请求的性质）一个紧跟着一个空行的关于这个请求的数据。
			3. 服务器端发送一个响应到客户端。响应开头是一个响应码，紧跟着的是包含metadata的响应头，一个空行，以及请求的文档或错误消息。
			4. 服务器端关闭连接。
		这是基本的HTTP 1.0的步骤。在HTTP 1.1和以后，多个请求和回复能够在同一个HTTP连接上以串联的形式被发送。那就是，步骤2和3能够被重复多次。更进一步，在HTTP 1.1中，请求和回复能够以多个块的形式被发送。这个更具可扩展性。
			每个请求和回复都有相同的基本格式：一个头行，一个包含metadata的http头，一个空行，然后是消息主体。一个典型的客户端请求看起来像这样：
				GET /index.html HTTP/1.1
				User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.8; rv:20.0)
				Gecko/20100101 Firefox/20.0
				Host: en.wikipedia.org
				Connection: keep-alive
				Accept-Language: en-US,en;q=0.5
				Accept-Encoding: gzip, deflate
				Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
			像这样的GET请求不包含一个消息主题，因此请求终结于一个空行。
			第一行被称为request line，它包含一个方法，一个资源的路径，和HTTP的版本。
			虽然只有request line是必须的，客户端请求也包含其他的信息。每一行都是Keyword：Value的格式。Keyword是大小写不敏感的，Value有时候是，有时候不是。Keyword和Value都应该只是ASCII。如果一个Value太长，可以在下一行的开头包含一个空格或tab来继续它。
			头中的行以回车-换行对终结。
			User-Agent让服务器端知道客户端使用的浏览器，允许它以针对特定的浏览器类型进行过优化的方式来发送文件。
			除了第一代浏览器之外的所有浏览器都包含一个Host字段，来指明服务器的名字，它允许web服务器区分服务于统一个IP地址的不同的命名主机。
			Accept告诉服务器端，客户端可以处理的数据的类型（虽然服务器端通常忽略这个）。
			MIME类型被分类为两层，一个类型和一个子类行。类型指定了包含的数据的大概的类型：是一个图片，文本还是视频？子类型指明了数据的特定类型：GIF图片，JPEG图片，TIFF图片？目前定义的一级类型有8个：
				• text/* for human-readable words
				• image/* for pictures
				• model/* for 3D models such as VRML files
				• audio/* for sound
				• video/* for moving pictures, possibly including sound
				• application/* for binary data
				• message/* for protocol-specific envelopes such as email messages and HTTP responses
				• multipart/* for containers of multiple documents and resources
			每一个都有不同的子类型
			另外，非标准的自定义类型和子类型也可以被自由的定义，只要他们起始于x-。
			最后，请求终结于一个空行-那就是两个回车-换行对，\r\n\r\n。
			一旦服务端看到一个空行，它开始在同一个连接上向客户端发送响应。响应起始于一个状态行，紧跟着是像请求头中的name：value语法一样的，用来描述响应的头。接着是一个空行，以及被请求的资源。一个典型的成功的响应看起来像这样：
				HTTP/1.1 200 OK
				Date: Sun, 21 Apr 2013 15:12:46 GMT
				Server: Apache
				Connection: close
				Content-Type: text/html; charset=ISO-8859-1
				Content-length: 115
				<html>
				<head>
				<title>
				A Sample HTML file
				</title>
				</head>
				<body>
				The rest of the document goes here
				</body>
				</html>
			不管是什么版本，从100到199的响应码总是一个情报性的响应，从200到299总是指明成功，300到399总是指明重定向，400到499总是指明客户端错误，500到599总是指明服务器端错误。
			保持存活（keep alive）
				HTTP 1.0为每一个请求打开一个新连接。在实际中，在典型的web会话中，打开和关闭连接所用的时间会比传输数据用的时间长，特别是对于那些有很多小文档的会话。这个对于使用SSL或TLS加密的HTTPS连接更有问题，因为建立一个安全套接字进行的握手要比建立一个常规套接字做更多的工作。
				在HTTP 1.1和以后，服务器端在发送完它的响应后不许要关闭socket，它可以保持它的打开状态，在这同一个socket上等待客户端发送的新的请求。多个请求和响应可以在同一个TCP连接上以串行的形式被发送。不管怎样，一个服务器端响应紧跟着一个客户端请求的模式是不变的。
				一个客户端在它的HTTP请求头中包含一个Connection:Keep-Alive来表明它将要重用socket。
				URL类透明的支持HTTP的KEEP-ALIVE，除非显式的关闭它。那就是说，在服务器端关闭连接之前，你再次连接到相同的服务器，它将重用socket。你可以通过多个系统属性来控制java使用HTTP KEEP-ALIVE的情况：
					将http.keepAlive设置为true/false来允许/不允许HTTP KEEP-ALIVE。默认是允许的。
					将http.maxConnections设置为你想要保持的同时打开的socket的数量。默认是5
					将http.keepAlive.remainingData设置为true，允许java在连接被丢弃后执行一些清理操作（java 6及以后）。默认是false。
					将sun.net.http.errorstream.enableBuffering设置为true，尝试缓冲从400-到500-等级的响应码对应的相对短小的错误流，以便连接能够被空闲出来，用于过会的重用。默认是false。这个自己的理解是它将这些短小的流缓冲下来，过会用同一个keep alive的连接来发送。
					将sun.net.http.errorstream.bufferSize设置为使用多少个字节来缓冲错误流，默认是4096字节。
					将sun.net.http.errorstream.timeout设置为过期一个从错误流中的读之前要等待的毫秒数。默认是300毫秒。
				默认值是合理的，除了你可能想要将sun.net.http.errorstream.enableBuffering设为ture，除非你想要从失败的请求中读取错误流。
				HTTP 2.0主要是基于由Google发明的SPDY协议，进一步优化了HTTP传输，通过头压缩，管道化请求和响应，以及异步连接的多路传送。不管怎样，这些优化都是针对传输层的操作，向应用层程序员屏蔽了细节，所以你编写的代码将仍基本遵循前面的步骤中的1-4。java还不支持HTTP 2.0。但当这种能力被添加上时，你的程序不需要作出改变，只要你通过URL和URLConnection类来访问HTTP服务器。
		HTTP方法
			和HTTP服务器通信遵循请求-响应模式：一个无状态的请求，跟着一个无状态的响应。每个HTTP请求都有2个或3个部分：
				一个起始行，包含HTTP方法和这个方法应该执行的指向资源的路径
				name-value格式的头，用来提供meta信息
				请求主体（只有POST和PUT有）
			有四个主要的HTTP方法：
				• GET
				• POST
				• PUT
				• DELETE
			这四个方法不是任意的。他们有应用需要遵循的指定的语义。GET方法用来获取一个资源，GET方法是没有副作用的，它能够被重复而不用关心它是否失败。更进一步，它的输出通常被缓存，虽然它能使用正确的头来控制。在一个恰当架构的系统中，GET请求能够被书签，并且预先获取，而不需要担心。
			PUT方法上传资源到服务器端一个已知的URL。它不是无副作用的，但它是幂等的。那就是，它能够被重复，而不用担心它是否失败。
			DELETE从指定的URL删除一个资源，同样，它不是无副作用的，但它是幂等的。如果你不确定一个删除请求是否成功，就在发送一次该请求。删除一个相同的文件两次不会出问题。
			POST是最常用的方法。它也上传一个资源到服务器端一个已知的URL，但是它没有指定服务器对这个新提供的资源做什么。比如，服务器端不需要使资源在目标URL可用，但是可能相替代的将它移动到一个不同的URL。或者服务器端可能使用数据来更新一个或多个完全不同的资源的状态。POST应该用来做那些不能重复的非安全的操作，比如购买。
			因为GET请求包含所有必须的信息在URL中，它能够被书签，连接到，或爬取等等。POST，PUT和DELETE请求不能这样。这个是经过深思熟虑的。GET倾向于那些不负责任的操作，比如浏览一个静态的web页面。其他方法，特别是POST，倾向于那些提交一些东西的操作。比如，向购物卡中添加一项应该发送一个GET请求，因为这个操作没有提交，用户仍然可以放弃这个购物卡。不管怎样，下单应该发送一个POST，因为这个操作要做提交。这就是为什么当你回退到一个使用POST的页面时，浏览器会让你确认。
			实际上，在今天的WEB中，POST被过度的使用。任何不需要提交任何东西的安全的操作都应该使用GET，而不是POST。只有那些有提交的操作应该使用POST。
			一个过时的误解是，浏览器只能处理query字符串只有几百字节的情况。虽然这个在90年代中期是真的，所有的主流浏览器都能很好的处理至少2000个字符的URL长度。如果你有比那个更多的数据需要提交，你可能确实需要POST。但是对于非浏览器客户端，安全的操作应该优先选择GET。你通常只会在上传数据到服务器端来创建一个新的资源时才会超过这个限度，而不是仅仅定位服务器端一个已经存在的资源，在这种情况下，POST和PUT都是正确的做法，不管怎样。
			在这4个主要的方法之外，一些其他的方法被使用在一些特殊的环境中。最常用的这种方法是HEAD，它的动作很像GET，它只返回关于资源的HTTP的头部，不包含实际的数据。这通常用来检查一个文件的修改日期，来查看存储在本地缓存中的拷贝是否有效。
			JAVA支持的另外两个是：OPTIONS，它允许客户端询问服务器端它可以一个指定的资源做什么。TRACE，它写回客户端的请求，为了调试的目的，尤其是当代理服务器表现错误时。不同的服务器端认识其他的非标准的方法，比如COPY和MOVE，但java不能发送他们。
			URL类使用GET方法来和HTTP服务器交互。URLConnection类可以使用这四种方法。
		请求体
			GET方法用来获取由URL标识的资源。你想要从服务器端GET的资源是由path和query来确定的。如何将不同的path和query映射到不同的资源是由服务器端决定的。URL类不需要关心这个，只要它知道URL，就能下载它。
			PUT和POST更复杂。在这种情况下，客户端提供资源，除了path和query之外。资源是在请求的请求体中被发送的，在请求头之后。那就是，它按顺序发送下面的四个部分：
				一个起始行，包含HTTP method，path，query和HTTP version	
				HTTP头
				一个空行（两个连续的回车-换行对）
    				请求体
			比如，用来向服务器端发送表单数据的POST请求：
				POST /cgi-bin/register.pl HTTP 1.0
				Date: Sun, 27 Apr 2013 12:32:36
				Host: www.cafeaulait.org
				Content-type: application/x-www-form-urlencoded
				Content-length: 54
				username=Elliotte+Harold&email=elharo%40ibiblio.org
			在这个例子中，请求体中包含一个application/x-www-form-urlencoded的数据，但这只是一种可能。通常来说，请求体能包含任意的字节。不管怎样，请求头应包含两个字段来指明请求体的性质：
				Content-length字段指明请求体的字节数
				Content-type字段指明这些字节的MIME类型
		COOKIE
			许多站点使用被称为cookies的小的字符串来在连接之间存储持久的客户端状态。Cookie在请求和响应头中从服务器端发送到客户端，再从客户端发送回服务器端。Cookie能够被服务器端用来指明SESSION ID，购物车的内容，登录证书，用户的喜好等等。通常，cookie的值不包含数据，而只是用来指向服务器端的数据。
			Cookie被限制为非空白的ASCII文本，并且可能不包含逗号或冒号。
			为了在浏览器中设置一个cookie值，服务器端在响应头中包含一个Set-Cookie字段。比如，下面这个响应头设置cookie “cart”的值为“ATVPD‐KIKX0DER”：
				HTTP/1.1 200 OK
				Content-type: text/html
				Set-Cookie: cart=ATVPDKIKX0DER
			如果浏览器再次发送请求到相同的服务器端，它将在请求头的Cookie字段将该cookie发送给服务器端：
				GET /index.html HTTP/1.1
				Host: www.example.org
				Cookie: cart=ATVPDKIKX0DER
				Accept: text/html
			这个允许服务器端在多个无状态的HTTP连接之间跟踪单独的用户和会话。
			服务器端可以设置多个cookie。比如一个到Amazon的请求可能返回5个cookie：
				Set-Cookie:skin=noskin
				Set-Cookie:ubid-main=176-5578236-9590213
				Set-Cookie:session-token=Zg6afPNqbaMv2WmYFOv57zCU1O6Ktr
				Set-Cookie:session-id-time=2082787201l
				Set-Cookie:session-id=187-4969589-3049309
			除了简单的name=value对之外，cookie有很多的属性来控制他们的范围，包括expiration date，path，domain，port，version和security选项。
			比如，默认的，cooke适用于它所来自的那个服务器端。如果一个cookie最初是由www.foo.example.com设置，浏览器将只会将该cookie发送回www.foo.example.com。不管怎样，一个站点也可以指明一个cookie适用于一个完整的子域之内，而不只是最初来的那个服务器端。比如，这个响应为整个foo.example.com域设置了一个用户cookie：
				Set-Cookie: user=elharo;Domain=.foo.example.com
			浏览器可以将该cookie回写至不只是www.foo.example.com站点，也可以是lothar.foo.example.com,eliza.foo.example.com, enoch.foo.example.com，以及其他在foo.example.com域内的其他主机。不管怎样，一个服务器端只能将cookie的域设置为它立即属于的那个域。www.foo.example.com不能为www.oreilly.com, example.com, or .com设置cookie。
			web站点通过嵌入一个由某个域持有的图片或其他内容到由另一个域持有的页面中来解决这个限制。由嵌入的内容，而不是页面自己设置的cookie被称为third-party cookies。很多用户阻塞third-party cookies，一些web浏览器开始默认的阻塞他们，为了隐私的原因。
			Cookie也可以使用path来指定范围，因此他们针对服务器端的某些目录，而不是全部。默认的范围是初始的URL和任何子目录。比如，如果一个cookie被设置为针对URL http://www.cafeconleche.org/XOM/，这个cookie也适用于http://www.cafeconleche.org/XOM/apidocs/，但是不适用于http://www.cafeconleche.org/slides/
or http://www.cafeconleche.org/。不管怎样，可以在cookie中使用PATH属性来改变默认范围。比如，响应给浏览器发送一个cookie，name为“user”，value为“elharo”，它只适用于服务器端的/restricted子树，而不适用于其他站点：
				Set-Cookie: user=elharo; Path=/restricted
			当向相同的服务器请求/restricted子树中的某个文档时，客户端将该cookie回写至服务器端。不管怎样，它不会使用同一站点的其他目录的cookie。
			cookie也可以同时包含一个domain和一个path。比如，下面这个cookie适用于example.com域中的任何服务器的/restricted路径：
				Set-Cookie: user=elharo;Path=/restricted;Domain=.example.com
			不同cookie属性的顺序没有影响，只要他们是以分号分割，并且name=value对在最前面。但是，这个在客户端向服务器端写回时不是这样，这时，path必须在domain的前面。比如：
				Cookie: user=elharo; Path=/restricted;Domain=.foo.example.com
			Cookie能够被设置为在某一个指定的时间点过期，通过设置它的expires属性为一个Wdy,DD-Mon-YYYY HH:MM:SS GMT格式的日期。星期和月份都是以3个字母的简写形式给出。剩下的是数字，如果需要的话以初始的0填充。如果按java.text.SimpleDateFormat使用的模式语言来说，那就是E,dd-MMM-yyyy H:m:s z。比如这个cookie将在2015年12月21号的下午3：23过期：
				Set-Cookie: user=elharo; expires=Wed,21-Dec-2015 15:23:00 GMT
			在这个日期过去之后，浏览器应该在它的缓存中删除该cookie。
			Max-Age属性设置cookie将在某一个特定数量的秒数过后过期，而不是在某一个特定的时间点。比如，这个cookie将在它第一次设置后的一个小时（3600秒）时过期：
				Set-Cookie: user="elharo"; Max-Age=3600
			浏览器将在这么多数量的时间之后删除该cookie。
			因为cookie能包含敏感信息，比如密码和session key，一些cookie的传输应该被加密。大多数时候这意味着使用HTTPS来代替HTTP。不论它意味着什么，每一个cookie都可以包含一个secure属性，而没有任何值。就像这样：
				Set-Cookie: key=etrogl7*;Domain=.foo.example.com; secure
			对于额外的预防cookie窃取攻击，像XSRF，的安全策略，cookie可以设置HttpOnly属性，这个告诉浏览器只通过HTTP和HTTPS来返回cookie，特别是不要通过javascript来返回。
				Set-Cookie: key=etrogl7*;Domain=.foo.example.com; secure; httponly
		CookieManager
			java 5包含一个抽象的java.net.CookieHandler，它定义了存储和获取cookie的API。但是它不包含一个该抽象类的一个实现。java通过添加一个你可以使用的CookieHandler的一个具体的子类java.net.CookieManager丰满了它。然而，它默认没有被打开。在java将存储和返回cookie之前，你需要允许它：
				CookieManager manager = new CookieManager();
				CookieHandler.setDefault(manager);
			如果所有你想要的是从站点获取cookie，并将他们发送回该站点，你就已经完成了。这就是你所要做的全部。在使用这两行代码安装完CookieManager之后，java将存储你通过URL类连接到的HTTP服务器发送的cookie，并且将在后续的请求中将存储的cookie发送回相同的服务器。
			然而，你可能想要更谨慎一些，关于你将接受那些人的cookie。你可以通过指定一个CookiePolicy来实现它。预定义的三个策略是：
				• CookiePolicy.ACCEPT_ALL All cookies allowed
				• CookiePolicy.ACCEPT_NONE No cookies allowed
				• CookiePolicy.ACCEPT_ORIGINAL_SERVER Only first party cookies allowed
			比如，下面的代码片段告诉java阻塞第三方的cookie，只接受第一放的cookie：
				CookieManager manager = new CookieManager();
				manager.setCookiePolicy(CookiePolicy.ACCEPT_ORIGINAL_SERVER);
				CookieHandler.setDefault(manager);
			那就是，它将只接受你正在通信的服务器的cookie，而不接受Internet上的其他服务器的。
			如果你想要更细粒度的控制，比如允许一些已知domain的cookie，而不允许其他的。你可以自己实现CookiePolicy接口，并且覆盖它的shouldAccept()方法：
				public boolean shouldAccept(URI uri, HttpCookie cookie)
		CookieStore
			有时候在本地存放和获取cookei是需要的。比如，当一个应用离开，它可以保存存储的cookie到磁盘，并且在下次启动时加载这些cookie。你可以通过getCookieStore()方法来获取CookieManager存放的cookie：
				CookieStore store = manager.getCookieStore();
			CookieStore类允许你添加，移除和列出cookie，以使的你能够在通常的HTTP请求和回复之间控制cookie。
				public void add(URI uri, HttpCookie cookie)
				public List<HttpCookie> get(URI uri)
				public List<HttpCookie> getCookies()
				public List<URI> getURIs()
				public boolean remove(URI uri, HttpCookie cookie)
				public boolean removeAll()
                       	存储中的每一个cookie都被封装在一个HttpCookie对象中，它提供了检查cookie属性的方法。
			这些属性中的很多实际上都不会被用到，特别是comment, comment URL, discard, 和version只是被当前废弃的Cookie 2规范使用。


第七章 URLConnections
	URLConnection是一个抽象类，它展示了一个到由URL指定的资源的活跃的连接。URLConnection有两个不同但相关的意图：首先，相对于URL类，它提供了和服务器进行交互（特别是HTTP服务器）的更多的控制，一个URLConnection类能够识别服务器端发送的头，并且进行相应的响应。它能够设置客户端请求使用的头部字段。最后，URLConnection能够通过POST，PUT和其他HTTP请求方法来向服务器端发送数据。
	第二，URLConnection是java协议处理器机制的一部分，它也包括URLStreamHandler类。协议处理器后面的想法很简单，它将处理特定数据类型和处理某一个协议的细节分割开，提供了用户接口，并且做一些完整的浏览器所做的其他工作。java.net.URLConnection类是抽象的，为了实现一个特定的协议，你可以写一个子类，这些子类可以被应用在运行时加载。比如，如果浏览器执行的URL使用的是一个奇怪的模式，比如compress，不是放开手并且抛出一个错误，它能够为这个未知的协议下载协议处理器，并且使用它来和服务器交互。
	java.net包中只有抽象的URLConnection类，具体的子类都隐藏在sun.net包结构中。就像URLConnection包中单一的构造函数一样，大多数的方法和字段都是protected。换句话说，他们只能被URLConnection和它的子类的实例访问。在你的代码中，很少直接初始化一个URLConnection对象，相替代的，运行时环境在需要时创建这些对象，依赖于正在使用的协议。类然后被使用java.lang.Class类的forName()和newInstance()方法来实例化。        
	URLConnection类不是java类库中设计最好的API。其中的一个问题就是URLConnection类和HTTP协议绑定的太紧。比如，它假定传输的每个文件都是以MIME头或其他很像这个的东西开头。然而，大多数比较经典的协议，比如FTP和SMTP都不是用MIME头。
	打开URLConnection
		直接使用URLConnection类的程序遵循下面这些基本的顺序步骤：
			1. 构造一个URL对象
			2. 调用URL对象的openConnection()方法来获取一个相应于那个URL的URLConnection对象
			3. 配置URLConnection
			4. 读取头字段
			5. 获取一个输入流并且读取数据
			6. 获取一个输出流并且写出数据
			7. 关闭连接
		你不需要执行所有这些步骤。比如，如果对于一个特定的URL，默认的步骤是可接受的，你可以跳过第三步。如果你只想要从服务器端获取数据，而不关心任何元信息，或者是协议没有提供任何元信息，你可以跳过第4步。如果你只想从服务器端获取数据，但不向服务器端发送数据，你可以跳过第6步。依赖于具体的协议，第5步和第6步可以被颠倒或交互进行。
		URLConnection类的唯一的构造函数是protected的：
			protected URLConnection(URL url)
		结果是，除非你正在继承URLConnection类来处理一种新类型的URL，你都是通过调用URL类的openConnection()方法来创建一个新的这样的对象。比如：
			try {
				URL u = new URL("http://www.overcomingbias.com/");
				URLConnection uc = u.openConnection();
				// read from the URL...
			} catch (MalformedURLException ex) {
				System.err.println(ex);
			} catch (IOException ex) {
				System.err.println(ex);
			}
		URLConnection类被声明为抽象的。然而，所有它的方法都被实现，除了一个。你可能发现在类中覆盖其他的方法是方便的或必须的，但是在子类中必须实现的唯一的方法是connect()，它和服务器建立一个连接，因此依赖于服务的类型（HTTP，FTP等等）。比如，sun.net.www.protocol.file.FileURLConnection的connect()方法将URL转化为某一个相应的目录中的一个文件名，为这个文件创建MIME信息，然后，打开一个缓冲的FileInputStream到这个文件。sun.net.www.protocol.http.HttpURLConnection的connect()方法创建了一个sun.net.www.http.HttpClient对象，它负责连接到服务器：
			public abstract void connect() throws IOException
		当一个URLConnection被第一次构造时，它是未连接的，那就是，本地和远程主机不能发送和接收数据。在这两个主机之间没有套接字连接。connect()方法在本地和远程主机之间建立了一个连接，以使他们能够发送和接受数据，通常是使用TCP套接字，但是也可能通过其他的机制。然而，getInputStream(), getContent(), getHeaderField()和其他需要一个打开的连接的方法，将会调用connect()，如果连接还没有被打开。因此，你很少需要直接调用connect()方法。
	从服务器读取数据
		下面是使用URLConnection对象从URL获取数据所需要的一个最小步骤集：
			1. 构造一个URL对象
			2. 调用URL对象的openConnection()方法来为该URL对象获取一个URLConnection对象		
			3. 调用URLConnection的getInputStream()方法
			4. 使用通常的流的API来从输入流进行读取
		getInputStream()方法返回一个宽泛的InputStream，来使你读取和解析服务器发送的数据。
		URLConnection和URL的最大的不同是：
			1. URLConnection提供了到HTTP头的访问
			2. URLConnection能够配置发送给服务器端的请求参数
			3. URLConnection既能向服务器端写出数据，也能从服务器端读取数据
			读取头部
				HTTP服务器在每个响应之前在头部提供了大量的信息。比如，这是一个由Apache web服务器返回的典型的HTTP头：
 					HTTP/1.1 301 Moved Permanently
					Date: Sun, 21 Apr 2013 15:12:46 GMT
					Server: Apache
					Location: http://www.ibiblio.org/
					Content-Length: 296
					Connection: close
					Content-Type: text/html; charset=iso-8859-1
				通常，一个HTTP头可以包含被请求文档的内容类型，文档的字节长度，内容被编码时使用的字符集，日期和时间，内容过期的日期，数据内容上次修改的时间。然而，这些信息依赖于服务器。一些服务器为每个请求发送所有的信息，一些服务器只发送一些，一些服务器什么也不发送。这部分的方法允许你查询一个URL
Connection，来找出服务器提供的元信息。
				除了HTTP，很少的协议使用MIME类型的头部（从技术角度来说，就算是HTTP头部也不能确切的说是一个MIME头部，它只是看起来像是）。当编写你自己的URLConnection类型的子类时，通常有必要重写这些方法，来返回有意义的值。你可能漏掉的最重要的信息是内容的类型。URLConnection提供了一些实用的方法来根据文件名或文件数据的前几个字节来猜内容的类型。
			获取指定的头部字段
				前6个方法从头部请求指定的，极其通常的字段，他们是：
					• Content-type
					• Content-length
					• Content-encoding
					• Date
					• Last-modified
					• Expires
				public String getContentType()
					getContentType()方法返回响应体的MIME类型，它依赖于服务器发送回一个有效的内容类型。它不抛出异常，如果内容类型不可用它将返回null。当你连接到web服务器，text/html是你将要碰到的最常用的内容类型。其他常用的类型包括text/plain, image/gif, application/xml, 和image/jpeg.
					如果内容类型是某一种形式的文本，头部可能也包含一个字符集来指明文档内的字符的编码。比如：
						Content-type: text/html; charset=UTF-8
					或
						Content-Type: application/xml; charset=iso-2022-jp
					在这种情况下，getContentType()返回Content-type字段的完整的值，包括字符编码。你可以使用这个字段指定的编码方式来解码文档，或使用ISO-8859-1（HTTP默认的编码方式）当没有指定编码方式时。
				public int getContentLength()
					getContentLength()方法告诉你内容中有多少个字节。如果没有Content-length字段，getContentLength()返回-1。这个方法不抛出异常，当你需要知道确切的有多少个字节需要被读取或当你需要提前创建一个足够大的缓存来持有数据。
					随着网络更快，文件更大，很有可能发现资源的大小超出了int类型的最大值。在这种情况下，getContentLength()返回-1。java 7添加了一个getContentLengthLong()，它和getContentLength()的工作方式一样，除了它返回一个long类型来替代int类型，因此可以处理更大的资源：
						public int getContentLengthLong() // Java 7
					HTTP服务器不会总是准确的关闭连接，因此，你不知道什么时候停止读取。为了下载一个二进制文件，更可靠的做法是使用URLConnection的getContentLength()方法来获得文件的长度，然后读取指定数量的字节。
					当从URLConnection读取数据时，理想情况下，你可能想要通过一次调用read()来填充和内容长度相同的字节数组。但是你可能一次得不到所有的字节，所以读取被放到一个循环中。到现在为止读取的字节数被累计到offset变量，它用来跟踪下次调用read()获取的数据在data数组中开始存放的位置。循环继续直到offset等于或超过contentLength。那就是数组已经被期望数量的字节填充满了。你也可以在read()返回-1时打断循环，表明一个非预期的流的结尾。offset变量现在包含读取的字节的总数，它应该和内容的长度相同。如果他们不相同，就说明有错误发生。
						byte[] data = new byte[contentLength];
						int offset = 0;
						while (offset < contentLength) {
							int bytesRead = in.read(data, offset, data.length - offset);
							if (bytesRead == -1) break;
							offset += bytesRead;
						}
						if (offset != contentLength) {
							throw new IOException("Only read " + offset + " bytes; Expected " + contentLength + " bytes");
						}
				public String getContentEncoding()
					getContentEncoding()返回一个String，它告诉你内容是如何被编码的。如果内容以未编码的方式被发送，这个方法返回null。它不抛出异常，web上最常被使用的内容编码可能是x-gzip，它能够使用java.util.zip.GZipInputStream类直接解码。
					内容编码和字符编码不一样，字符编码是由Content-type或文档内部的信息来决定的，指定了字符如何被编码为字节的。内容编码指定了字节如何被编码为其他字节的。
				public long getDate()
					getDate()方法返回一个long，告诉你文档是什么时候被发送的。这个时间是文档被发送时的服务器端时间，可能和你本地机器的时间不相符。如果HTTP头不包括一个Date字段，getDate()返回0。
				public long getExpiration()
					一些文档有基于服务器的过期日期，它指明什么时候文档应该从缓存中删除，并从服务器端重新加载。如果HTTP头不包含一个Expiration字段，getExpiration()返回0，意味着文档不会过期，会一直保持在缓存中。
				public long getLastModified()
					getLastModified()返回文档最后被修改的时间。如果HTTP头不包含一个Last-modified字段，这个方法返回0。
			获取任意的头字段
				前面的6个方法从头部请求指定的字段，但一个消息中可以包含的头字段的数量在理论上没有限制。下面的5个方法用来检查头部的任意字段。事实上，前面讲到的几个方法只是在这里讨论的方法上的一个简单的包装。你可以使用这些方法来获取设计者刚开始没有计划到的头字段。如果被请求的头能找到，它就被返回，否则，返回null。
				public String getHeaderField(String name)
					getHeaderField()方法返回一个命名的头字段的值。头的名字是大小写不敏感的，而且不包括结尾的冒号。比如，获取Content-type和Content-encoding头字段的值：
						String contentType = uc.getHeaderField("content-type");
						String contentEncoding = uc.getHeaderField("content-encoding"));
					为了获取Date, Content-length, 或Expires头部，你可以用相同的方法：
						String data = uc.getHeaderField("date");
						String expires = uc.getHeaderField("expires");
						String contentLength = uc.getHeaderField("Content-length");
					这些方法都返回String，而不是int或long。如果你感兴趣的是一个数字类型，转换String类型到int或long。不要假设getHeaderField()返回的值是有效的，你必须检查来确保它是非null的。
				public String getHeaderFieldKey(int n)
					这个方法返回第n个头字段（比如Content-length或Server）的键（字段名称），请求方法是第0个头，并且键为null。第一个头是1.比如，为了获取URLConnection uc头的第六个键：
						String header6 = uc.getHeaderFieldKey(6);
				public String getHeaderField(int n)
					这个方法返回第n个头字段的值。在HTTP中，起始行包括请求方法和路径，是第0个头字段。事实上的第一个头字段是1。
				public long getHeaderFieldDate(String name, long default)
					这个方法首先获取由name参数指定的头字段的值，然后尝试将该字符串转化为long型，该long是表示时间的秒数。getHeaderFieldDate()可以用来获取一个表示时间的头字段，比如Expires, Date, 或Last-modified。为了转换字符串到整数，getHeaderFieldDate()使用了java.util.Date类的parseDate()方法。parseDate()得体的理解和转换最常用的日期格式，但它也可能有问题，比如如果你请求的头字段包含的是日期之外的类型。如果parseDate()不理解日期或如果getHeaderFieldDate()不能够找到请求的头字段，getHeaderFieldDate()将返回default参数。
				public int getHeaderFieldInt(String name, int default)
					这个方法获取name指定的头字段的值，并且尝试着将它转换成一个int。如果它失败了，或者是因为找不到请求的头字段或因为那个头字段不包括一个可识别的整数，getHeaderFieldInt()都将返回default参数的值。这个方法通常用来获取Content-length字段。
	缓存
		web浏览器缓存页面和图片已经很多年来。如果一个logo在一个站点的每个页面上重复，浏览器通常只从远程服务器上下载一次，将它存储在自己的缓存中，当它再次被需要时，从缓存中进行加载，而不是每次碰到该logo时都从远程服务器上请求它。很多HTTP头，包括Expires和Cache-control都能控制缓存。
		默认的，假设是如果一个页面是通过HTTP的GET请求的，那么它能而且也应该被缓存。一个通过HTTPS或POST访问的页面通常不应该被缓存。不管怎样，HTTP头能够调整这些：
			Expires头（主要是对于HTTP 1.0）指明可以进行缓存直到指定的时间
			Cache-control头（HTTP 1.1）提供细粒度的缓存策略：
				max-age=[seconds]：从现在开始经过多少秒后，缓存项应该过期
				s-maxage=[seconds]：从现在开始经过多少秒后，该缓存项应该从共享缓存中过期。私有缓存可以存储该缓存项更长的时间。
				public：可以缓存认证过的响应，否则，认证过的响应不能被缓存。
				private：只有单一用户缓存可以存储响应，共享缓存不能
				no-cache：不完全是它听起来的那样。该项仍然能够被缓存，但是客户端应该在每次请求中包含一个ETag或Last-modified头来核查资源的状态
				no-store：无论怎样，不缓存该项
				Cache-control会覆盖Expires，如果两个都存在的话。一个服务器可以发送多个Cache-control头在单一个头中，只要他们不冲突。
			Last-modified是资源上次被修改的时间。一个客户端可以使用HEAD请求来检查它，并且只有在本地缓存拷贝的时间比Last-modified旧时，重新发送一个完整的GET。
			ETag头（HTTP 1.1）是一个资源的唯一标识符，它随着资源的改变而改变。客户端可以使用HEAD来检查它，只有当本地缓存拷贝有一个不同的ETag时，再重新发送一个完整的GET请求。
			比如这个HTTP响应说资源能够被缓存604800秒（HTTP 1.1）或一星期以后（HTTP 1.0）。它也说它上次被修改的时间是4月20号，并且有一个ETag。所以如果本地缓存已经有一个拷贝比它更近，就不需要加载整个文档。
				HTTP/1.1 200 OK
				Date: Sun, 21 Apr 2013 15:12:46 GMT
				Server: Apache
				Connection: close
				Content-Type: text/html; charset=ISO-8859-1
				Cache-control: max-age=604800
				Expires: Sun, 28 Apr 2013 15:12:46 GMT
				Last-modified: Sat, 20 Apr 2013 09:55:04 GMT
				ETag: "67099097696afcf1b67e"
			客户端可以从这些信息中得到改进：
				如果资源在本地缓存中可用，并且它的过期日期还没到，只管使用它。不必麻烦和服务器交互。
				如果资源在本地缓存中可用，并且它的过期日期到了，在执行一个完整的GET请求之前，使用HEAD方法来和服务器核查，看资源是否被改变。
	Web Cache for Java
		默认的，java不能缓存任何东西。为了安装一个URL类将要使用的系统范围内的缓存，你需要下面的东西：
			ResponseCache的一个特定子类
			CacheRequest的一个特定子类
			CacheResponse的一个特定子类
		你通过ResponseCache.setDefault()静态方法来安装你的ResponseCache的子类，它和你的CacheRequest和CacheResponse的子类一起工作。该方法安装你的缓存对象作为系统的默认值。一个java虚拟机只能支持一个单一的共享缓存。
		一旦一个缓存被安装了，当系统尝试去加载一个新的URL时，它首先在缓存中查找，如果缓存返回了想要的内容，URLConnection将不需要连接到远程的服务器。但是，如果请求的数据不在缓存中，协议处理器将会下载它。在这以后，它会将响应放到缓存中，以便下次该URL被加载时内容能够更快的可用。
		ResponseCache类中有两个抽象方法来存储和获取数据，从系统的单一缓存中：
			public abstract CacheResponse get(URI uri, String requestMethod, Map<String, List<String>> requestHeaders) throws IOException
			public abstract CacheRequest put(URI uri, URLConnection connection) throws IOException
		put()方法返回一个CacheRequest对象，它包装了一个OutputStream，URL将使用它来写出它读取的可缓存数据。CacheRequest是有两个方法的抽象类：
			package java.net;
			public abstract class CacheRequest {
				public abstract OutputStream getBody() throws IOException;
				public abstract void abort();
			}
		子类中的getOutputStream()方法应该返回一个OutputStream，它指向了针对同一时间传递给put()方法的URI的缓存数据存储。比如，如果你将数据存储到一个文件中，你应该返回一个连接到那个文件的FileOutputStream。协议处理器将拷贝它读取的数据到这个OutputStream。如果当拷贝是出现了问题（比如，服务器不可预料的关闭了连接），协议处理器调用abort()方法。这个方法应该从缓存中删除掉针对该请求已经存储的缓存。
		ResponseCache的get()方法从缓存中获取数据和头部，并且将他们包装在一个CacheResponse对象中返回。如果期望的URI不在缓存中，它将返回null。在这种情况下，协议处理器按标准的方法从远程服务器加载该URI。同样，该类是一个抽象类，你必须通过子类类实现它。
		CacheResponse类有两个方法，一个用来返回请求的数据，一个用来返回请求的头。当缓存原始的响应时，你需要两个都存储。头应该在一个不可修改的map中进行返回，它的键是HTTP头字段的名称，值是每个HTTP头名称对应的值的列表。
			public abstract class CacheResponse {
				public abstract Map<String, List<String>> getHeaders() throws IOException;
				public abstract InputStream getBody() throws IOException;
			}
		
		Java只允许一个URL缓存一次。为了安装和改变缓存，使用静态的ResponseCache.setDefault()和ResponseCache.getDefault()方法：
			public static ResponseCache getDefault()
			public static void setDefault(ResponseCache responseCache)
		他们设置了一个单一的缓存，供同一个JVM里的所有程序使用。
		每一次获取的资源都保留在HashMap中直到它过期。这个例子中一个过期的资源在被从缓存中删除之前需要等待它再次被访问。一个更老道的实现是使用一个低优先级的线程来扫描过期的文档，并且删除他们来为其他的腾出位子。替代这个或对该实现进行补充的是：缓存文档到一个队列中，每次移除最老的或离其过期时间最近的文档。更老道的实现是跟踪每个文档的使用频度，每次删除最老并且最少使用的文档。
	配置连接
		URLConnection类有7个受保护的实例字段，它们精确定义了客户端如何向服务器端发起请求。他们是：
			protected URL url;
			protected boolean doInput = true;
			protected boolean doOutput = false;
			protected boolean allowUserInteraction = defaultAllowUserInteraction;
			protected boolean useCaches = defaultUseCaches;
			protected long ifModifiedSince = 0;
			protected boolean connected = false;
                比如，如果doOutput是true，你将可以通过该URLConnection向服务器端写出数据，就像从它读取数据一样。如果useCaches是false，连接会绕过任何本地缓存，再次从服务器上下载文件。
		因为这些字段都是受保护的，他们值的读取和修改都是通过getter和setter方法来进行的。
		你只能在URLConnection连接之前修改这些字段（在你尝试从连接中读取内容和头之前）。set字段的很多方法都会抛出一个IllegalStateException，当他们在连接被打开时调用。总体来说，你只能在连接被打开之前设置URLConnection对象的属性。
		有一些get和set方法定义了URLConnection的所有实例的默认行为。他们是：
			public boolean getDefaultUseCaches()
			public void setDefaultUseCaches(boolean defaultUseCaches)
			public static void setDefaultAllowUserInteraction(boolean defaultAllowUserInteraction)
                	public static boolean getDefaultAllowUserInteraction()
			public static FileNameMap getFileNameMap()
			public static void setFileNameMap(FileNameMap map)
                不像实例方法，这些方法可以在任何时候被调用，新的默认值只有被应用在设置新的默认值之后构造的URLConnection对象中。
		protected URL url
			url字段指定了这个URLConnection连接到的URL。在URLConnection被创建时，由构造函数设置它，并且在那之后不能再被改变。你可以通过调用getURL()方法来获取它的值。
		protected boolean connected
			如果连接是打开的，那么connected是true，否则是false。因为当一个URLConnection对象被新创建时，连接还没有被打开，所以它的初始值是false。这个变量只能被java.net.URLConnection及其子类的实例访问。
			没有方法直接的读取或修改connected的值。然而，任何导致URLConnection连接的方法都应该将该变量设置为true，包括connect(), getInputStream(), 和getOutputStream()。任何导致URLConnection断开连接的方法都应该将其设置为false。在java.net.URLConnection中没有这类方法，但一些它的子类，比如java.net.HttpURLConnection，有disconnect()方法。
			如果你继承URLConnection来编写一个协议处理器，你有责任当打开连接时将其设为true，关闭连接时将其设为false。java.net.URLConnection中的很多方法会读取这个变量来决定他们能做什么。如果没有设置正确，你的程序将碰到很难调试的bug。
		protected boolean allowUserInteraction
			一些URLConnection需要和用户进行交互。比如，web浏览器可能需要询问用户名和密码。然而，很多应用不能假设有个用户要和它交互，比如，一个搜索引擎机器人可能在后台运行，不需要任何用户提供用户名和密码。就像它的名字建议的，allowUserInteraction字段指明了是否用户交互是被允许的。它的默认值是false。
			这个变量是protected，但是public的getAllowUserInteraction()能够读取它的值，public的setAllowUserInteraction()能够改变它的值：
				public void setAllowUserInteraction(boolean allowUserInteraction)
				public boolean getAllowUserInteraction()
			值为true表明用户交互是被允许的，false表明没有用户交互。它的值能够在任何时候被读取，但是只有在URLConnection连接之前才能被设置。在URLConnection连接之后调用setAllowUserInteraction()会抛出一个IllegalStateException。
			如果你取消了用于验证的弹出框，你将得到一个401 Authorization Required错误，以及服务器发送给非验证用户的文本。然而，如果你拒绝发送任何验证信息，你可以通过单击OK，然后在它询问你是否再次尝试验证时回答NO，然后getInputStream()就将会抛出一个ProtocolException。
			静态方法getDefaultAllowUserInteraction()和setDefaultAllowUserInteraction()决定了那些没有显式设置allowUserInteraction属性的URLConnection对象的默认行为。因为allowUserInteraction字段是静态的，设置它会改变setDefaultAllowUserInteraction()方法被调用之后创建的URLConnection的所有实例。
		protected boolean doInput
			一个URLConnection能够被用来从服务器读取数据，向服务器写出数据，或两个都干。如果URLConnection能够被用来读取，那么protected boolean字段doInput就是true，否则就是false。默认值是true。为了访问这个受保护的变量，使用public的getDoInput()和setDoInput()方法。
		protected boolean doOutput
			程序可以使用URLConnection来向服务器写出数据。比如，一个程序需要通过POST方法来向服务器端写出数据，它通过从URLConnection获取一个输出流来实现这个。如果URLConnection能够被用来写，protected boolean字段doOutput的值就为true，否则就为false。默认是false。
			当你为一个HTTP URL将doOutput设置为true，请求的方法会从GET变为POST。
		protected boolean ifModifiedSince
			很多客户端，特别是web浏览器和代理，会保存上次获取的文档的缓存。如果用户再次请求相同的文档，它能被从缓存中获取。然而，它可能在上次获取后，在服务器端被修改。唯一可以知道的方式就是询问服务器。客户端可以在请求头中包含一个If-Modified-Since字段。这个头包含一个日期和时间。如果文档在那个时间之后有改变，服务器应该发送它，否则，不需要。典型的，这个时间是客户端上次获取文档的时间。
			如果文档在那个时间之后被改变，那么服务器像平常一样发送它。否则，它使用一个304 Not Modified的消息来响应。并不是所有的web服务器都会遵守If-Modified-Since字段，一些服务器不管文档是否改变都会发送它。
			URLConnection类的ifModifiedSince字段指明了日期，它将会被放置到If-Modified-Since头字段中。
		protected boolean useCaches
			一些客户端，尤其是web浏览器，能够从本地缓存中获取文档，而不是从远程服务器获取它。Applet可以访问浏览器的缓存。单机程序可以使用java.net.ResponseCache类。useCaches变量决定当一个缓存可用时，它是否将被使用。默认的值是true，意味着缓存将被使用，false意味着缓存将不被使用。
			getDefaultUseCaches()和setDefaultUseCaches()这两个方法定义了useCaches字段的初始值。
				public void setDefaultUseCaches(boolean useCaches)
				public boolean getDefaultUseCaches()
			虽然是非静态的，这些方法确实是获取或设置的静态字段，他们决定了这次改变之后，新创建的URLConnection的所有实例的默认行为。
		Timeouts
			有4个方法用来查询并修改连接的超时值，那就是，底层的套接字在抛出一个SocketTimeoutException之前，将等待一个远程的响应多长时间。他们是：
				public void setConnectTimeout(int timeout)
				public int  getConnectTimeout()
				public void setReadTimeout(int timeout)
				public int  getReadTimeout()
                        setConnectTimeout()/getConnectTimeout()方法控制等待初始连接的时间。setReadTimeout()/getReadTimeout()控制输入流等待数据到达的时间。4个方法都是以毫秒来作为时间单位。这4个方法都将0解释为永不超时。当超时值为负数时，两个setter方法都将抛出IllegalArgumentException异常。			          
	配置客户端请求HTTP的头
		一个HTTP客户端发送给服务端一个请求行和一个头。
		一个web服务器可以使用这些信息来为不同的客户端服务不同的页面，来获取和设置cookie，来通过密码来验证用户，以及更多。在客户端的请求头中放不同的字段，服务器端根据这些作出响应。
		理解这个很重要：这里说的不是服务器端发送给客户端的HTTP头，那个是由前面讨论过的多种多样的getHeaderField()和getHeaderFieldKey()方法来读取。这里讨论的是客户端发送给服务器端的头。
		每个URLConnection默认在头中设置了很多不同的名字-值对。
		你通过在连接打开之前，使用setRequestProperty()方法来向HTTP头中添加新的头。
			public void setRequestProperty(String name, String value)
		setRequestProperty()方法通过参数指定的名称和值来向这个URLConnection的头中添加一个字段。这个方法只能在连接打开之前被使用。如果连接已经打开，它会抛出一个IllegalStateException。getRequestProperty()方法返回被该URLConnection使用的HTTP头中的指定名称的字段的值。
		HTTP允许请求头中单一的名称可以有多个值。在这种情况下，各个值之间以逗号分割。比如，Accept头的值为text/html, image/gif, image/jpeg, and *.
		这些方法只有在URL连接到的是一个HTTP URL时才有意义，因为只有HTTP协议才像这样使用头部。这些方法在其他协议中可能还有其他的意思，比如NNTP，这仅仅是一个很差的API设计的例子。这些方法应该是更具体的HttpURLConnection类的一部分，而不应该是总体的URLConnection类的一部分。
		你可以设置相同的属性为一个新的值，但是这会改变现在的属性值。为了添加一个附加的属性值，使用addRequestProperty()来替代：
			public void addRequestProperty(String name, String value)
		没有一个合法头部的固定的列表。服务器端通常会忽略掉那些它不认识的头部。HTTP确实在头部字段的名称和值的内容上有一些限制。比如，名称不能包含空格，值不能包含换行符。java实施了字段中包含换行符的限制，但也没有太多。如果字段中包含一个换行符，setRequestProperty()和addRequestProperty()将抛出一个IllegalArgumentException。否则，很容易使URLConnection发送一个畸形的头部到服务器端，所以要小心。一些服务器会优雅的处理畸形的头部。一些服务器会忽略掉有问题的头部，并且无论如何都返回请求的文档，但是一些会响应一个HTTP 400, BadRequest错误。
		如果，由于某些原因，你需要检查URLConnection中的头部，有一个标准的getter方法：
			public String getRequestProperty(String name)
		java也包括一个获取连接的所有请求属性的方法，它返回一个Map：
			public Map<String,List<String>> getRequestProperties()
		键是头字段的名称，值是头字段属性值的列表。名称和值都存储为String。
	向服务器写出数据
		有时候你需要写出数据到一个URLConnection，比如，当你使用POST向web服务器提交一个表单或使用PUT来上传一个文件。getOutputStream()方法返回一个OutputStream，你可以使用它来向服务器端传输数据：
			public OutputStream getOutputStream()
		URLConnection默认不允许写出数据，在请求一个输出流之前，你需要调用setDoOutput(true)。当你为一个http URL，将doOutput设置为true，请求方法就从GET变为POST。不管怎样，GET应该被限制为在那些安全的操作中使用，比如查询请求和页面跳转，不能用于那些创建和修改资源的非安全的请求，比如，比如向web页面提交一个留言，或订一个批萨。安全的操作可以被书签，缓存，爬取，预获取，等等。不安全的操作不能。
		一旦你有一个OutputStream，可以通过将它串联到一个BufferedOutputStream或BufferedWriter来进行缓冲。你也可以将它串联到DataOutputStream,
OutputStreamWriter或其他那些比原生的OutputStream更好用的类。
		使用POST来发送数据基本上和GET方法一样简单。调用setDoOutput(true)，并且使用URLConnection的getOutputStream()方法来写出查询字符串，而不是将它附加到URL的末尾。java缓冲所有写出到输出流上的数据，直到流关闭。这允许它计算Content-length头的值。
		对于那种情况，只要你能控制客户端和服务器端，你可以使用任何其他你想要的数据编码。比如，SOAP和XML-RPC都是以XML形式向服务器端POST数据，而不是x-www-form-url-encoded形式的查询字符串。
		getOutputStream()也被PUT请求方法使用，它用于向web服务器存储一个文件。被存储的数据写出到getOutputStream()返回的OutputStream。然而，这些只能被URLConnection的子类HttpURLConnection使用。
	URLConnection上的安全考虑
		URLConnection被关于建立网络连接，读取和写出文件等等的所有平常的安全限制所约束。比如，URLConnection只有在它指向的主机是applet来自的那个主机时，才能被不信任的applet所创建。然而，细节会有一些小诡计，因为不同的URL scheme和他们响应的连接可以有不同的安全实现。比如，一个指向applet自己的jar文件的jar URL应该是可以的。然而，一个指向本地磁盘存储器的文件URL应该是不可以的。
		在尝试连接到一个URL之前，你可能想要知道连接是不是将被允许。为了这个目的，URLConnection类有一个getPermission()方法
			public Permission getPermission() throws IOException
		这个将返回一个java.security.Permission对象，它指明了连接到URL需要哪些权限。如果不需要任何权限（比如没有安装安全管理器），它将返回null。URLConnection的子类返回java.security.Permission的不同子类。比如，如果底层的URL指向www.gwbush.com，getPermission()针对主机www.gwbush.com的连接和解析操作返回一个java.net.SocketPermission。
	猜MIME媒体类型
		如果每个协议和服务器都将使用标准的MIME类型来准确的指明正在被传送文件的类型，这是最好的，不幸的是，不是这种情况。不只是因为我们需要处理旧的协议，比如FTP，它出现在MIME类型之前；也因为有些应该使用MIME类型的服务器压根没有提供MIME头或提供了不正确的头（通常是因为服务器被错误的配置）。URLConnection类提供了两个静态方法来帮助程序指出一些数据的MIME类型。如果内容类型不可知或你有原因相信给定的内容类型是不正确时，你可以使用这两个方法。第一个是URLConnection.guessContentTypeFromName()：
			public static String guessContentTypeFromName(String name)
		这个方法尝试根据URL中的文件名部分的后缀来猜测内容的类型。它以字符串的形式返回内容的类型。这种猜测可能是正确的。
		这个猜测是由content-types.properties文件来决定的，通常位于jre/lib目录。在Unix上，java也将查看mailcap文件来帮助猜测。
		这个方法无论如何都是不可靠的。比如，它遗漏了各种各样的XML应用，比如PDF（.rdf），XSL（.xsl）等等那些应该是application/xml的MIME类型。它也没有为CSS（.css）提供一个MIME类型。不管怎样，它是一个好的开始。
		第二个MIME类型猜测方法是URLConnection.guessContentTypeFromStream():
			public static String guessContentTypeFromStream(InputStream in)
		这个方法通过尝试查看流中数据的前几个字节来猜测内容的类型。为了使这种方法工作，InputStream必须支持标记，以使你在读取了开头的几个字节后能够返回流的开头。java检查InputStream的前16个字节，尽管有时候只需要更少的字节数就可以作出标识。这种猜测方法有时候也不像guessContentTypeFromName()那么准确。比如，以注释开头，而不是以xml声明开头的xml文档，将被错误的标记为HTML文件。这个方法应该只被用过最后的手段。
	HttpURLConnection
		java.net.HttpURLConnection类是URLConnection的一个抽象子类。它提供了一些当特定的处理HTTP URL时有用的额外方法。特别是，它包含有用来设置和获取请求方法的方法，决定是否要遵循转发。它也包含大量的和各种各样的HTTP响应代码相匹配的助记性的常量。最后，它覆盖了来自于超类URLConnection的getPermission()方法，虽然它根本没有改变这个方法的语义。
		因为这个方法是抽象的，并且它唯一的构造函数是受保护的，你不能直接创建一个HttpURLConnection的实例。然而，如果使用一个http URL来构造一个URL对象，并且调用它的openConnection()方法，被返回的URLConnection对象将是一个HttpURLConnection的实例。你可以对其进行强制类型转换。
		请求方法
			当一个web客户端和一个web服务器进行交互，它发送的第一个东西是一个请求行。典型的，这个行起始于GET并且紧跟着客户端想要获取的资源的路径，以及客户端理解的HTTP协议的版本。比如
				GET /catalog/jfcnut/index.html HTTP/1.0
			然而，web客户端除了从web服务器简单的GET文件之外可以做更多其他的。他们可以用POST来提交一个表单。他们可以PUT一个文件到web服务器上，或DELETE web服务器上的一个文件。他们可以只请求一个文档的头部。他们可以询问web服务器，对于一个给定的URL的一系列的OPTIONS。他们也可以TRACE请求自己。所有这些都是通过将请求方法从GET变为一个不同的关键字来实现的。比如，这里是浏览器如何使用HEAD来只获取一个文档的头部：
				HEAD /catalog/jfcnut/index.html HTTP/1.1
				Host: www.oreilly.com
				Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2
				Connection: close
			默认的，HttpURLConnection使用GET方法，然而，你可以通过setRequestMethod()方法来改变它：
				public void setRequestMethod(String method) throws ProtocolException
			方法的参数应该是下面这7个大小写敏感的字符串：
				• GET
				• POST
				• HEAD
				• PUT
				• DELETE
				• OPTIONS
				• TRACE
			如果参数是其他的方法字符串，那么java.net.ProtocolException将会被抛出，它是IOException的一个子类。然而，通常简单的设置请求方法是不够的。你可能需要调整HTTP头，并且也需要提供一个消息主体。比如，POST一个表单，需要你提供一个Content-length头。
			一些web服务器支持额外的，非标准的请求方法。比如，WebDAV要求服务器支持PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, 和UNLOCK。但java一个也不支持。
			HEAD
				HEAD方法可能是所有的请求方法中最简单的一个。它的行为很像GET。然而，它告诉服务器只返回HTTP的头，而不是实际的传送一个文件。这个方法通常被用来检查一个文件自从上次被缓存后，是否被修改过。
			DELETE
				DELETE方法从web服务器删除位于指定URL的文件。因为这个请求明显的有安全风险，并不是所有的服务器都被配置为支持它，对于支持它的那些一般也需要一定形式的验证。一个典型的DELETE请求看起来像这样：
					DELETE /javafaq/2008march.html
					HTTP/1.1
					Host: www.ibiblio.org
					Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2
					Connection: close
				服务器端可以自由的选择拒绝这个请求或要求验证，比如;
					HTTP/1.1 405 Method Not Allowed
					Date: Sat, 04 May 2013 13:22:12 GMT
					Server: Apache
					Allow: GET,HEAD,POST,OPTIONS,TRACE
					Content-Length: 334
					Connection: close
					Content-Type: text/html; charset=iso-8859-1

					<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
					<html><head>
					<title>405 Method Not Allowed</title>
					</head><body>
					<h1>Method Not Allowed</h1>
					<p>The requested method DELETE is not allowed for the URL
					/javafaq/2008march.html.</p>
					<hr>
					<address>Apache Server at www.ibiblio.org Port 80</address>
					</body></html>
				即使服务器端接受这个请求，它的响应也是依赖于具体的实现。一些服务器可能删除文件，一些的可能简单的将它移动到垃圾文件夹，一些可能简单的将它标记为不可读。细节留给了服务器提供者。
			PUT
				一些HTML编辑着或程序员想要使用PUT方法将文件存储到一个Web服务器上。它允许客户端将文档放在站点的抽象的层次结构中，而不许要知道站点如何映射到实际的文件系统。这个和FTP形成对比，对于FTP用户需要知道实际的文件夹结构，与服务器的虚拟文件结构形成对比。这里是一个如何将文件PUT到web服务器的例子：
					PUT /blog/wp-app.php/service/pomdoros.html HTTP/1.1
					Host: www.elharo.com
					Authorization: Basic ZGFmZnk6c2VjZXJldA==
					Content-Type: application/atom+xml;type=entry
					Content-Length: 329
					If-Match: "e180ee84f0671b1"

					<?xml version="1.0" ?>
					<entry xmlns="http://www.w3.org/2005/Atom">
					<title>The Power of Pomodoros</title>
					<id>urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a</id>
					<updated>2013-02-23T19:22:11Z</updated>
					<author><name>Elliotte Harold</name></author>
					<content>Until recently, I hadn't paid much attention to...</content>
					</entry>
				像删除文件一样，某些形式的验证是需要的，并且服务器必须被特别配置为支持PUT。这些细节在不同服务器中都不同。一些服务器不支持PUT的即配即用。
			OPTIONS
				OPTIONS请求方法询问对于一个指定的URL，支持哪些选项。如果请求的URL是一个*，请求作为一个整体应用于服务器，而不是针对服务器上的一个特定的URL。比如：
					OPTIONS /xml/ HTTP/1.1
					Host: www.ibiblio.org
					Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2
					Connection: close
				服务器通过发送一个HTTP头，附带一个那个URL允许的命令的列表来响应一个OPTIONS请求。比如，当前面的请求发送后，Apache的响应是这样的：
					HTTP/1.1 200 OK
					Date: Sat, 04 May 2013 13:52:53 GMT
					Server: Apache
					Allow: GET,HEAD,POST,OPTIONS,TRACE
					Content-Style-Type: text/css
					Content-Length: 0
					Connection: close
					Content-Type: text/html; charset=utf-8
				合法的命令的列表可以在Allow字段中被找到。然而，实际上他们可能只是服务器理解的命令，而不一定是它将要在那个URL上实际执行的。
			TRACE
				TRACE请求方法发送服务器端从客户端接受到的HTTP头。这个信息的主要作用是查看服务器和客户端之间的任何代理服务器可能的改变。比如，假如下面的TRACE请求被发送：
					TRACE /xml/ HTTP/1.1
					Hello: Push me
					Host: www.ibiblio.org
					Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2
					Connection: close
				服务器端应该像这样响应：
					HTTP/1.1 200 OK
					Date: Sat, 04 May 2013 14:41:40 GMT
					Server: Apache
					Connection: close
					Content-Type: message/http
				
					TRACE /xml/ HTTP/1.1
					Hello: Push me
					Host: www.ibiblio.org
					Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2
					Connection: close
				最开始的5行是服务器端通常的HTTP响应的HTTP头。从TRACE /xml/ HTTP/1.1开头的行是客户端请求的回写。在这种情况下，回写是可靠的。然而，当有一个代理服务器位于客户端和服务器端之间时，它可能就不是了。
		和服务器端断开连接
			HTTP 1.1支持持久连接，它允许多个请求和响应在一个单一的TCP套接字上被发送。不管怎样，当Keep-Alive被使用时，服务器端不会简单的立即关闭一个连接，因为它已经发送了数据的最后几个字节到客户端。客户端可能发送另一个请求。服务器端将会超时，并且关闭连接，在处于非活动状态5秒钟时。然而，它仍然支持由客户端在知道自己处理完之后立即关闭。
			HttpURLConnection类透明的支持HTTP Keep-Alive，除非你显式的关闭它。那就是，当你在服务器端关闭连接之前，再次连接到相同的服务器，它将重用套接字。一旦你知道自己已经完成了和一个特定主机的交互，disconnect()方法允许客户端关闭连接：
				public abstract void disconnect()
			如果在这个连接上有任何流仍然处于打开状态，disconnect()方法将关闭他们。然而，反过来不是这样，关闭一个持久连接上的流，不导致套接字被关闭并且连接断开。			
		处理服务器响应
			服务器端HTTP响应的第一行包括一个数字代码和一个表明响应类型的字符串.比如,最普通的响应是200 OK,表明请求的文档被发现.另一个你很熟悉的响应是404 Not Found,表明你请求的URL不再指向一个文档.
			有很多其他的,不太常用的响应,比如代码301表明文档被永久性的移动到了一个新的地址,并且浏览器需要重定向它到新的地址,并且更新任何指向旧的地址的书签.比如:
				HTTP/1.1 301 Moved Permanently
				Connection: Keep-Alive
				Content-Length: 299
				Content-Type: text/html; charset=iso-8859-1
				Date: Sat, 04 May 2013 14:20:58 GMT
				Keep-Alive: timeout=5, max=200
				Location: http://www.cafeaulait.org/
				Server: Apache
			通常,你需要从响应消息中知道响应代码.HttpURLConnection类有一个getResponseCode()方法以int形式返回它:
				public int getResponseCode() throws IOException
			紧跟在响应代码后面的文本字符串被称为response message,并且通过相应命名的方法getResponseMessage()来返回:
				public String getResponseMessage() throws IOException
			HTTP 1.0定义了16个响应代码.HTTP 1.1将其扩展到40个.虽然一些代码,特别是404,已经变成了和它的语法意义一样的行话,但他们中的大多数还是不熟悉的.HttpURLConnection类有36个命名常量,比如HttpURLConnection.OK和HttpURLConnection.NOT_FOUND,来展示常用的响应代码.
			现在没有一个特定的方法用来返回服务器端使用的HTTP的版本.
			然而,uc.getHeaderField(0)将返回HTTP请求行的第一行的整行,版本会被包含在里面:
				HTTP/1.1 200 OK
			错误情况
				有时候,服务器碰到了一个错误,尽管如此,它也会在消息主体中返回有用的信息.比如,当一个客户向www.ibiblio.org站点请求一个不存在的页面,不是简单的返回一个404错误代码,而是返回一个查询页面来帮助用户.
				getErrorStream()方法返回一个包含这个页面的InputStream或null,如果没有发生错误或没有数据返回.
					public InputStream getErrorStream()
				通常,你会在getInputStream()失败后的try-catch块中调用getErrorStream()方法.
			重定向
				300-等级的响应代码都表明某一种形式的重定向.那就是,请求的资源在期望的地址不再可用,但是它可能在一些其他的地方被找到.当碰到了这样一种响应,大多数浏览器会自动从新的地址加载该文档.然而,这样做会有安全风险,因为它可能潜在的将用户从一个受新任的站点转到一个不受新任的站点,可能没有通知用户.
				默认的,HttpURLConnection会跟踪重定向.然而,HttpURLConnection类有两个静态方法允许你指定是否要跟踪重定向:
					public static boolean getFollowRedirects()
					public static void setFollowRedirects(boolean follow)
				如果重定向被跟踪,那么getFollowRedirects()方法将返回ture.当setFollowRedirects()方法的参数为true时,他将设置HttpURLConnection为跟踪重定向.当参数为false时,它将禁止跟踪重定向.因为他们是静态方法,他们改变的是所有在这两个方法被调用之后构造的HttpURLConnection类的对象的行为.setFollowRedirects()方法会抛出一个SecurityException,如果安全管理器不允许进行改变.Applet通常不被允许改变这个值.
				java有两个方法来配置实例级别的重定向,他们是:
					public boolean getInstanceFollowRedirects()
					public void setInstanceFollowRedirects(boolean followRedirects)
				如果setInstanceFollowRedirects()没有在一个给定的setInstanceFollowRedirects()对象上调用,HttpURLConnection对象就简单的遵循类方法HttpURLConnection.setFollowRedirects()设置的默认值.
		代理
			很多用户位于防火墙后面，或使用AOL，或其他大访问量ISP都是通过代理访问Web。usingProxy()方法告诉你，某个指定的HttpURLConnection是否正在使用一个代理服务器：
				public abstract boolean usingProxy()
			如果正在使用代理，它就返回true，否则返回false。在一些上下文中，使用代理还有安全的含义。
		流模式
			每个发往HTTP服务器的请求都有一个HTTP头。这个头中有个字段是Content-length（请求体中的字节数）。头在主体之前。然而，为了设置头部，你需要知道主体的长度，但此时你可能还不知道。通常java解决这个问题通过缓存你写出到OutputStream（从HttpURLConnection中获取）的所有东西，直到流关闭。此时，它就知道主体中有多少字节，因此有足够的信息来设置Content-length。
			这个模式对于响应典型的web表单的小的请求是好的。然而，对于很长的表单或一些SOAP消息，它是繁重的。对于使用PUT发送的中等或巨大的文档，它很浪费并且很慢。如果java在向网络写出第一个字节之前不需要等待最后一个字节的写出会更有效率。java对于这个问题提供了两个解决方法。如果你知道数据的大小，比如，你使用PUT上传一个已知大小的文件，你可以告诉HttpURLConnection对象数据的大小。如果你提前不知道数据的大小，你可以使用块传输来替代。在块传输中，请求的主体分为多片进行发送，每一片都有其单独的内容长度。如果要使用块传输，只需要在连接URL之前，将你想要使用的块的大小传递给setChunkedStreamingMode()方法：
				public void setChunkedStreamingMode(int chunkLength)
			此时，java将使用一个和本书例子中稍微不同形式的HTTP。然而，对于java程序员，这个不同是不相关的。只要你正在使用URLConnection来替代原生的套接字，并且只要服务器端支持块传输，那么这就是你所需要做的全部工作，而不需要对你的代码进行进一步的修改。然而，块传输会影响验证和重定向。如果你尝试着发送一个分块的文件到一个重定向的URL或需要密码验证的URL，一个HttpRetryException就会被抛出。你将需要在新的URL重试请求或使用恰当的认证在就的URL，并且所有的这些都需要手动的来完成，而不会有你通常含有的HTTP协议处理器的完全支持。因此，不要使用块传输，除非你真的需要它。就像大多数的性能忠告一样，你不应该使用这个优化，除非测量结果证明默认的非流模式是一个瓶颈。
			如果你碰巧知道请求数据的大小，你可以通过提供这个信息给HttpURLConnection对象来优化连接。如果你这么做了，java立即开始向网络发送流数据。否则，它需要缓存你发送的任何东西来决定内容的长度，并且只有在你关闭流之后，它才会发送到网络上。如果你准确的知道数据的大小，将数字传递给setFixedLengthStreamingMode()方法：
				public void setFixedLengthStreamingMode(int contentLength)
				public void setFixedLengthStreamingMode(long contentLength) // Java 7
			因为这个数字实际上会比int的最大值要大，在java 7及其以后，你可以使用long来代替它。
			java将在HTTP头的Content-length字段中使用这个数字。然而，如果你尝试着写出比这个给出的数字更多或更少的字节的数据时，java将抛出一个IOException。当然，这个发生在后面，在你写出数据时，而不是当你第一次掉用这个方法时。setFixedLengthStreamingMode()方法会抛出IllegalArgumentException，如果你传递一个负数。或抛出IllegalStateException，如果连接已经连接上或已经设置为使用块传输模式（你不能在统一个请求中同时使用块传输或固定长度的流传输）。
			固定长度的流模式在服务器端是透明的。服务器端既不知道也不关心Content-length是如何被设置的，只要它是正确的。然而，就像块传输模式，流模式也和验证和重定向有配合。如果对于给定的URL，这两个中的其中一个是被需要的，一个HttpRetryException将会被抛出，你需要手动进行重试。因此，不要使用这种模式，除非你确实需要它。


客户端套接字
	数据在互联网上以有限大小的包的形式进行传输叫做数据报。每个数据报包含一个header和一个payload。头中包含这个数据报要去的地址和端口，这个数据报来自的地址和端口，一个校验和来检查数据损坏，和各种各样的其他管理信息用来确保可靠传输。负载包含数据自己。然而，由于数据报有有限的大小，通常需要将数据切分为多个数据报，并且在重点进行重组。有可能在传输的过程中，一个或多个数据报损坏或丢失，并且需要被重传，或数据报乱序到达，需要进行重排序。记录这些-且分数据为数据报，生成头，解析传过来的数据报的头，记录哪些数据报已经或还没有到达，等等-是大量的工作并且需要大量的复杂的代码。
	幸运的是，你不需要自己来做这些工作。套接字允许程序员对待网络连接就行对待另一个流那样，可以向它写出字节，并且从它读取字节。套接字为程序员屏蔽了网络低层的细节，比如错误检测，数据报大小，数据报切分，数据报重传，网络地址，等等。
	使用套接字
		一个套接字是两个主机之间的一个连接。它可以执行7个基本的操作：
			连接到远程主机
			发送数据
			接收数据
			关闭连接
			绑定到端口
			监听传入的数据
			在绑定的端口上，接受远程主机发起的连接
		java的Socket类，会被客户端和服务器端使用，它有和前4个操作相应的方法。后3个方法只被那些等待客户端连接到他们的服务器端有用。他们由ServerSocket来实现，java程序通常以下面的形式来使用客户端套接字：
			程序通过构造函数创建一个新的套接字
			套接字尝试连接到远程主机
		一旦连接被建立，本地和远程主机从套接字中获取输入和输出流，并且使用这些流来向彼此发送数据。这个连接是全双工的。两个主机都可以同时发送和接收数据。数据意味着什么依赖于协议。发送到FTP服务器和HTTP服务器的是不同的命令。一方向另一方发送数据的动作是紧跟在一些商定性握手之后的。
		当数据传输完成后，连接的一端或两端同时关闭连接，一些协议，比如HTTP 1.0要求每次请求被服务后就关闭连接。其他的，比如FTP和HTTP 1.1，允许在单一的连接上处理多个请求。
		通过Telnet来调查协议
                        在这章里,你将看到很多使用套接字来和很多著名的网络服务,比如时间,词典等等.套接字本身很简单,但是用来和不同服务进行通信的协议很复杂.
			为了感受协议是如何工作的,可以使用Telnet连接到服务器,输入不同的命令,观察它的响应.默认的,Telnet尝试着连接到端口23.为了连接到服务器的不同的端口,可以像这样一样指定你想要连接到的端口:
				$ telnet localhost 25
			这个请求到端口25的一个连接,SMTP的端口,在本地机器.SMTP协议用来在两个服务器之间传输邮件或在一个邮件客户端和服务器之间传输邮件.如果你知道和SMTP服务器进行交互的命令,你可以不使用一个邮件程序来发送邮件.这个诡计可以被用来伪造邮件.
			自从这个发生的20年里，大多数的SMTP服务器添加来一些比这里展示的更安全的措施。他们倾向于要求用户名和密码，并且只接受来自于本地网络的客户端连接以及其他受信任的邮件服务器。然而，在这种情况下，你仍然可以使用Telnet来模拟一个客户端，来查看客户端和服务器端如何交互，因此知道你的java程序需要做哪些东西。虽然，这样做，不能证明SMTP协议的所有功能，但是，允许你演示一个简单的邮件客户端如何和服务器端进行通信是足够了。
		使用套接字从服务器端读
			我们从一个简单的例子开始，你将要连接到位于National Institute for Standards and Technology (NIST)的时间服务器，并且询问当前的时间。这个协议定义在RFC 867。通过它，你可以知道日期服务器监听在13端口上，服务器以人类可读的格式发送时间，并且关闭连接。你可以像这样一样使用Telnet来测试时间服务器：
				$ telnet time.nist.gov 13
				Trying 129.6.15.28...
				Connected to time.nist.gov.
				Escape character is '^]'.

				56375 13-03-24 13:37:50 50 0 0 888.8 UTC(NIST) *
				Connection closed by foreign host.
			“56375 13-03-24 13:37:50 50 0 0 888.8 UTC(NIST)”这一行是由时间服务器发送，当你从Socket的InputStream进行读取时，这就是你将要得到的。其他的行或者是由Unix shell或由Telnet程序生成。
			RFC 867没有为输出声明任何特定的格式，除了它是人类可读的。在这个例子中，你可以看到这个连接是在March 24, 2013, at 1:37: 50 P.M., Greenwich Meantime建立的。更具体的，这个格式定义为JJJJJ YY-MM-DD HH:MM:SS TT L H msADV UTC(NIST) OTM，各个部分的含义如下：
				JJJJJ是儒略历日期（比如，他是自1858年11月17号午夜到现在的完整的天数）
				YY-MM-DD是年，月和当前日期的最后两位数字。
				HH:MM:SS是Coordinated Universal Time（UTC，essentially Greenwich Mean Time）的时，分，秒。
				TT指明美国当前使用的是标准时间还是夏令时：00代表标准时间，50代表夏令时，其他值代表转换时间的天数倒计时。
				L是一个一位数的代码，它指明一个leap second是否将被加上或减去，在当前月份的最后一天的午夜：0代表没有leap second，1代表增加一个leap second，2代表减去一个leap second。
				H代表服务器的健康程度：0代表健康，1代表最大5秒的误差，2代表大于5秒的误差，3代表未知数量的不精确，4代表维护模式。
				msADV是一个毫秒数，它是NIST添加到它发送的时间上，用来平滑的抵消网络延迟。在前面的代码中，它添加了888.8毫秒到当前的结果上，因为那是它估算的响应返回需要花多长时间。
				字符串UTC(NIST)是一个常量，OTM也几乎是一个常量(一个星号，除非一些确实很怪异的事情发生)
			这就是NIST声明的所有的细节。他们不是日期标准的一部分。虽然它确实提供了很多的数据，如果你确实有个程序需要和网络时间服务器同步，你最好替代的使用定义在RFC 5905 中的NTP协议。
			我不确定这里展示的例子还能运行多久。这些服务器都过载了，在编写本章时，我确实碰到过一些间歇性的连接问题。在2013年早期，NIST声明“在TCP端口13上的NIST DAYTIME协议的用户被强烈建议升级到网络时间协议（NTP），它更精确，并且需要更少的网络带宽。NIST时间客户端nistime-32bit.exe同时支持这两种协议。我们期望使用基于UDP的版本来替代基于TCP的版本，在2013年后期。”。
			现在看看如何通过编程来使用套接字来获取相同的数据。首先，打开一个到time.nist.gov的13端口的套接字：
				Socket socket = new Socket("time.nist.gov", 13);
			这个不仅仅是创建了对象，它实际上是通过网络建立了连接。如果因为服务器端没有在13端口上进行监听，而导致连接超时或失败，那么构造函数会抛出一个IOException，所以你通常需要包裹这个在一个try块里。在java 7中，Socket实现了Autocloseable接口，所以你可以使用try-with-resources：
				try (Socket socket = new Socket("time.nist.gov", 13)) {
					// read from the socket...
				} catch (IOException ex) {
					System.err.println("Could not connect to time.nist.gov");
				}
			在java 6或更早的版本，你将想要显式的关闭套接字在finally块中来释放套接字持有的资源：
				Socket socket = null;
				try {
					socket = new Socket(hostname, 13);
					// read from the socket...
				} catch (IOException ex) {
					System.err.println(ex);
				} finally {
					if (socket != null) {
						try {
							socket.close();
						} catch (IOException ex) {
							// ignore
						}
					}
				}
			下一步是可选的，但强烈建议。使用setSoTimeout()方法来为连接设置一个超时时间。超时时间的单位是毫秒，所以这个代码块设置套接字在没有响应时15秒之后超时。
				socket.setSoTimeout(15000);
			虽然一个套接字在服务器拒绝连接时立即抛出一个ConnectException，或在路由器不能找出如何将你的数据报发送到服务器端时，抛出一个NoRouteToHostException，但当在这种请款下，他们都没有帮助，当一个行为不当的服务器接受了连接，然后停止和你通信，并且不积极的关闭连接。在套接字上设置一个超时意味着每次从套接字读取或向套接字写出将最多花费某一个指定的毫秒数。当你连接到的服务器挂起了，你将以一个SocketTimeoutException被通知。确切的超时时间设置的长短依赖于你的应用的需求以及你期待的服务器的响应性。15秒对于一个本地内网服务器的响应来说是一个很长的时间，但是对于一个过载的公共服务器，比如time.nist.gov，是一个相对较少的时间。
			一旦你打开了套接字，并且设置了它的超时时间，调用getInputStream()来返回一个InputStream，你可以使用它来从套接字读取数据。通常，一个服务器可以发送任何数据。在这个特定的例子中，协议指明这些字节必须是ASCII：
				InputStream in = socket.getInputStream();
				StringBuilder time = new StringBuilder();
				InputStreamReader reader = new InputStreamReader(in, "ASCII");
				for (int c = reader.read(); c != -1; c = reader.read()) {
					time.append((char) c);
				}
				System.out.println(time);
			在大多数像这样的网络程序中，真正的精力花费在和协议通信以及理解数据的格式。比如，不是简单的打印服务器发送给你的文本，相替代的，你可能想要将它解析为一个java.util.Date对象。
			当从网络读取数据时，很重要的是记住并不是所有的协议都使用ASCII或文本。比如，声明在RFC
868中的时间协议指明时间以自Greenwich Mean Time
1900年1月1日午夜开始经过的秒数来发送。然而，它不是以ASCII字符串的形式来发送，像2,524,521,600或–1297728000，更进一步，它以32字节，无符号，big-endian的二进制形式发送。
			RFC从不会确实的站出来,说这就是使用的格式.它指明32位,并且假设你知道所有的网络协议都是用big-endian.数字是无符号的这个事实只能通过有符号的和无符号的整数来计算包装的日期,并且和规范中给出的日期进行比较.使事情更糟糕的是,规范给出了一个负时间的例子,并且根据协议,事实上不能被时间服务器发送.Time是一个相对较旧的协议.标准化于1980年的早期,在IETF像今天那样关心这类问题之前.不管怎样,当你自己在实现一个特别是没有很好定义的协议时,你需要针对已经存在的实现做大量的测试,来证明你需要做什么.在更糟的情况是,不同的实现有不同的行为.
			因为时间协议不会发送回文本,所以你不能很容易的使用Telnet来测试这样一个服务,并且你的程序不能通过Reader或任何形式的readLine()方法来读取来自于服务器端的响应.java程序连接到时间服务器必须读取原生的字节,并且恰当的解释他们.在这个例子中,问题变得复杂是因为java中缺少32位的无符号整形.结果是,你需要一次读取所有的字节,并且手动的转化他们为long,使用按位操作符<<和|.
		使用套接字来向服务器端写出数据
			向服务器端写出数据并不会明显的比从它读取数据难。你简单的向套接字请求一个输出流，就像获取一个输入流一样。虽然，你可以在使用输入流读取数据的同时，使用输出流来向套接字写出数据，但是大多数协议被设计为客户端要么在读取数据，要么在写出数据，不会两个同时进行。大多数通常的模式是，客户端发送一个请求，然后服务器端响应，然后客户端发送另一个请求，服务器端再次响应。这个将持续下去，直到一端或另一端完成，并且关闭连接。
			一个简单的双向TCP协议是dict，定义在RFC
2229。在这个协议中，客户端打开一个到dict服务器2628端口的套接字，并且发送命令，比如“DEFINE eng-lat gold”，这个告诉服务器发送一个使用它的English-to-Latin字段定义的gold。不同的服务器会有不同的字典安装。在第一个定义收到后，客户端请求第二个。当完成时，它发送“quit”命令。
			用java来实现这个协议并不是很难。首先打开一个到dict服务器端的套接字，dict.org，在端口2628上：
				Socket socket = new Socket("dict.org", 2628);
			再一次，你可能想要设置一个超时，在你连接到服务器端时，服务器端挂起的情况下：
				socket.setSoTimeout(15000);
			在dict协议中，客户端先说话，所以使用getOutputStream()方法来请求输出流。
				OutputStream out = socket.getOutputStream();
			getOutputStream()方法返回一个原生的OutputStream，用来从你的应用写出数据到套接字的另一端。你通常想要在使用它之前将它串联到一个更方便的类，像DataOutputStream或OutputStreamWriter，对它进行缓冲也是一个好主意。因为dict协议是基于文本的，更确切的说是基于UTF-8的，将它包装在一个Writer里是很方便的：
				Writer writer = new OutputStreamWriter(out, "UTF-8");
			现在向套接字写出命令：
				writer.write("DEFINE eng-lat gold\r\n");
			最后，flush输出，以使你确定命令被发送到网络上：
				writer.flush();
			服务器端现在使用一个定义进行响应，你可以使用套接字的输入流进行读取：
				InputStream in = socket.getInputStream();
				BufferedReader reader = new BufferedReader(new InputStreamReader(in, "UTF-8"));
				for (String line = reader.readLine(); !line.equals("."); line = reader.readLine()) {
					System.out.println(line);
				}
			当你在一行中看到一个句号，你就知道定义完了。你可以在输出流中发送quit：
				writer.write("quit\r\n");
				writer.flush();
			半关闭的套接字
				close()方法同时关闭从套接字获取的输入流和输出流。偶尔，你可能想要只关闭连接的一般，或者是输入流或输出流。shutdownInput()和shutdownOutput()方法只关闭连接的一半：
					public void shutdownInput() throws IOException
					public void shutdownOutput() throws IOException
				每一个都不会实际的关闭套接字。相替代的，他们调整连接到套接字的输出流，以使它认为现在到了流的结尾。在从已经关闭的输入流上的读将返回-1.在输出流关闭后的写操作将抛出IOException。
				很多协议，比如finger，whois，HTTP，都以客户端向服务器端发送一个请求开始，然后读取响应。因此可以在客户端发送完请求后关闭输出流。比如，这个代码段发送一个请求到HTTP服务器，然后关闭输出流，因为它不需要向套接字再写出任何东西：
					try (Socket connection = new Socket("www.oreilly.com", 80)) {
						Writer out = new OutputStreamWriter(connection.getOutputStream(), "8859_1");
						out.write("GET / HTTP 1.0\r\n\r\n");
						out.flush();
						connection.shutdownOutput();
						// read the response...
					} catch (IOException ex) {
						ex.printStackTrace();
					}
				注意，即使你关闭了连接的一半或两半，在你使用完后，你仍然需要关闭套接字。关闭方法简单的影响了套接字上的流。他们不会释放套接字相关的资源，比如它占有的端口。
				isInputShutdown()和isOutputShutdown()方法告诉你输入流和输出流是关闭的还是打开的，分别的。你可以使用他们（而不是isConnected()和isClosed()）来更确切的得知你是否可以在一个套接字上进行读取和写出。
					public boolean isInputShutdown()
					public boolean isOutputShutdown()
	构造和连接套接字
		java.net.Socket是用来执行客户端TCP操作的java基础类。其他的建立TCP网络连接的，面向客户端的类，比如URL, URLConnection, Applet, 和JEditorPane都最终是调用这个类的方法。这个方法自己使用本地代码来和宿主操作系统的本地TCP栈进行通信。
		基本的构造函数
			每一个Socket的构造函数指明了连接到的主机和端口。主机可以用一个InetAddress或String来指定。远程端口用从1到65535之间的int值来指定。
				public Socket(String host, int port) throws UnknownHostException, IOException
				public Socket(InetAddress host, int port) throws IOException
			这些构造函数会连接套接字（在构造函数返回之前，一个本地到远程主机的网络连接被建立）。如果连接因为某些原因不能被打开，构造函数会抛出一个IOException或UnknownHostException。比如：
				try {
					Socket toOReilly = new Socket("www.oreilly.com", 80);
					// send and receive data...
				} catch (UnknownHostException ex) {
					System.err.println(ex);
				} catch (IOException ex) {
					System.err.println(ex);
				}
			在这个构造函数中，host参数仅仅是一个用String表示的主机名。如果DNS服务器不能解析主机名或它不工作，构造函数抛出一个UnknownHostException。如果套接字因为一些其他原因不能被打开，构造函数抛出一个IOException。有很多原因会导致连接尝试失败：你连接到的主机没有在那个端口上接受连接，旅馆的wifi服务器阻止了你的连接除非你登录，或者是路由器问题导致你的数据报不能到达他们的终点。
			因为这个构造函数不只是构造一个Socket对象，并且也尝试着连接套接字到远程主机，你可以使用它来决定到一个特定主机的连接是否被允许。
			如果你好奇哪些服务运行在这些端口上，尝试使用Telnet来实验。在Unix系统，你可以通过查看文件/etc/services来决定哪个服务运行在哪个端口上。
			三个构造函数创建未连接的套接字。这些提供了更多的控制在底层的套接字的行为上，比如选择一个不同的代理服务器或加密模式：
				public Socket()
				public Socket(Proxy proxy)
				protected Socket(SocketImpl impl)
		选择一个本地接口来进行连接
			两个构造函数同时指明了要连接到的主机和端口，以及发起连接的接口和端口:
				public Socket(String host, int port, InetAddress interface, int localPort) throws IOException, UnknownHostException
				public Socket(InetAddress host, int port, InetAddress interface, int localPort) throws IOException
			这个套接字连接到前两个参数指明的主机和端口，它使用后两个参数指明的接口和端口来发起连接。网络接口或者是物理的（比如以太网卡），或者是虚拟的（多宿主主机有多于一个的IP地址）。如果向localPort参数传递的是0，java从1024到65535之间随机选择一个可用的端口。
			通常不需要选择一个特定的网络接口来发送数据，但是偶尔会有这样的需要。你可能想要选择本地端口的一种情况是路由器或防火墙使用两个以太网端口，在一个接口上接收进来的连接，处理它，从另一个接口上转发到本地网络。假设你正在编写程序来定期的传递错误日志到一个打印机或发送他们到一个内部的邮件服务器，你可能想要确定你使用的是一个面向内网的网络接口，而不是一个面向外网的网络接口。比如：
				try {
					InetAddress inward = InetAddress.getByName("router");
					Socket socket = new Socket("mail", 25, inward, 0);
					// work with the sockets...
				} catch (IOException ex) {
					System.err.println(ex);
				}
			传递0来指明本地端口号，表明我不关心使用哪个端口，但是我想要使用绑定到本地主机名router的网络接口。
			这个构造函数会因为和前面构造函数一样的原因而抛出IOException或UnknownHostException。额外的，如果套接字不能绑定到请求的本地网络接口上，它抛出一个IOException（可能是一个BindException，虽然它只是IOException的一个子类，并且没有特别的声明在这个方法的throws语句中）。比如一个运行在a.example.com
的程序不能从b.example.org来发起连接。你可以使用这个深思熟虑的改进来限制一个编译过的程序只运行在一个预先决定的主机上。它将要求自定义每个计算机的分布，会对便宜的产品有一定的杀伤。更进一步，java程序很容易反汇编，反编译，以及逆向工程，这个模式不是很简单。（前面这句没看懂本意，翻译的可能不对）不管怎样，它可能是强制软件许可模式的一部分。
		构造而不连接
			到目前为止我们讨论的套接字对象既创建套接字对象，又打开一个到远程主机的连接。有时候你想要分开这些操作，如果你没有传递参数到Sokcet的构造函数，它不知道连接到什么地方去：
				public Socket()
			你可以在稍后传递一个SocketAddress到其中一个connect()方法来建立连接，比如：
				 try {
					Socket socket = new Socket();
					// fill in socket options
					SocketAddress address = new InetSocketAddress("time.nist.gov", 13);
					socket.connect(address);
					// work with the sockets...
				} catch (IOException ex) {
					System.err.println(ex);
				}
			你可以传递一个整数作为第二个参数，用来指明在连接超时之前需要等待的毫秒数：
				public void connect(SocketAddress endpoint, int timeout) throws IOException
			默认是0，意味着永不过时。
			这种构造函数允许不同种类的套接字。你可以使用它来设置那些只能在连接建立之前设置的套接字选项。然而，我发现的最主要的好处是它允许我清理try-catch-finally块中的代码，特别是在java 7之前。没有参数的构造函数不会抛出异常，所以它允许你在finally块中关闭套接字时可以避免无聊的null检测。对于原来的构造函数，大多数时候的代码像这样：
				Socket socket = null;
				try {
					socket = new Socket(SERVER, PORT);
					// work with the socket...
				} catch (IOException ex) {
					System.err.println(ex);
				} finally {
					if (socket != null) {
						try {
							socket.close();
						} catch (IOException ex) {
							// ignore
						}
					}
				}
			对于没有参数的构造函数，它看起来像这样：
				Socket socket = new Socket();
				SocketAddress address = new InetSocketAddress(SERVER, PORT);
				try {
					socket.connect(address);
				// work with the socket...
				} catch (IOException ex) {
					System.err.println(ex);
				} finally {
					try {
						socket.close();
					} catch (IOException ex) {
						// ignore
					}
				}
			虽然它没有java 7中自动关闭的版本那么好，但它也是一种改进来。
		套接字地址
			SocketAddress类代表一个连接的终点。他是一个空的抽象类，除了一个默认的构造函数之外没有方法。至少在理论上，SocketAddress既能被用于TCP，又能被用于非TCP的套接字。事实上，目前只有TCP/IP套接字被支持，并且你通常使用的套接字地址都是InetSocketAddress的实例。
			SocketAddress的一个主要目的是，为短期的套接字连接信息提供一个便利的存储，比如，在创建套接字时可以被重用的IP地址和端口，即使在原来的套接字断开连接并且垃圾回收之后。
			为了这个目的，Socket类提供了两个返回SocketAddress的方法（getRemoteSocketAddress()返回系统正在连接到的地址，getLocalSocketAddress()返回连接发起的地址）。
				public SocketAddress getRemoteSocketAddress()
				public SocketAddress getLocalSocketAddress()
			如果套接字还没有连接，这两个方法都返回null。比如，你第一次连接到Yahoo，然后存储它的地址：
				Socket socket = new Socket("www.yahoo.com", 80);
				SocketAddress yahoo = socket.getRemoteSocketAddress();
				socket.close();
			随后，你可以使用这个地址来连接到Yahoo：
				Socket socket2 = new Socket();
				socket2.connect(yahoo);
			InetSocketAddress类（JDK中SocketAddress的唯一子类，也是我碰到过的唯一子类），通常被用来以一个主机和一个端口（对于客户端），或仅仅是一个端口（比如服务器端）：
				public InetSocketAddress(InetAddress address, int port)
				public InetSocketAddress(String host, int port)
				public InetSocketAddress(int port)
			你也可以只用静态工厂方法InetSocketAddress.createUnresolved()来跳过在DNS中查找主机：
				public static InetSocketAddress createUnresolved(String host, int port)
			InetSocketAddress类有一些getter方法，你可以使用它来检测对象：
				public final InetAddress getAddress()
				public final int getPort()
				public final String getHostName()
		代理服务器
			最后一个构造函数创建一个没有连接的套接字，它通过一个指定的代理服务器来连接：
				public Socket(Proxy proxy)
			通常，套接字使用的代理服务器是由系统属性socksProxyHost和socksProxyPort来控制的，并且这些属性应用到系统中的所有套接字上。然而，通过这个构造函数创建的套接字，将相替代的使用指定的代理服务器。值得注意的是，你可以通过传递Proxy.NO_PROXY作为参数来完全绕开代理服务器，直接连接到远程主机。当然，如果防火墙阻止直接连接，java不能针对这个做任何事情，连接将失败。
			为了使用一个特定的代理服务器，通过地址来指定它。比如，这个代码片段使用位于myproxy.example.com的SOCKS代理服务器来连接到主机login.ibiblio.org：
				SocketAddress proxyAddress = new
				InetSocketAddress("myproxy.example.com", 1080);
				Proxy proxy = new Proxy(Proxy.Type.SOCKS, proxyAddress)
				Socket s = new Socket(proxy);
				SocketAddress remote = new InetSocketAddress("login.ibiblio.org", 25);
				s.connect(remote);
			SOCKS是唯一一个java理解的底层代理类型。也有一个高层的Proxy.Type.HTTP，它工作在应用层，而不是传输层。以及一个Proxy.Type.DIRECT代表无代理连接。
	从套接字中获取信息
		Socket对象有很多属性，可以通过getter方法来获取：
			• Remote address
			• Remote port
			• Local address
			• Local port
		这里是用来访问这些方法的getter方法：
			public InetAddress getInetAddress()
			public int getPort()
			public InetAddress getLocalAddress()
			public int getLocalPort()
                没有setter方法，这些属性在连接建立时被设置，并且从那之后就固定了。
		getInetAddress()和getPort()方法告诉你Socket连接到的远程主机和端口，或者如果现在连接是关闭的，当它要连接时，Socket所要连接到的主机和端口。getLocalAddress()和getLocalPort()告诉你连接发起的网络接口和端口。
		不像远程端口，它通常是一个已经被一个标准组织提前分配的著名的端口，本地端口通常是由系统在运行时在本地未被使用的可用端口中进行选择。这样同一机器上的不同的客户端可以同时连接到相同的服务。本地端口被嵌入在向外发送的IP数据报中，伴随这本地主机的IP地址，以使服务器端可以发送数据到客户端正确的端口。
		被分配到连接的本地端口是不可预测的，很大程度上依赖于其他哪些端口在被使用。
		关闭的还是连接上的？
			如果套接字是关闭的，isClosed()返回true，否则返回false。如果你不确定套接字的状态，你可以使用这些方法来检测它，而不是冒IOException的风险。比如：
				if (socket.isClosed()) {
					// do something...
				} else {
					// do something else...
				}
			然而，这不是一个完美的测试。如果套接字起初从没有被连接，isClosed()返回false，即使套接字其实不是打开的。
			Socket类也有一个isConnected()方法。名字有一点歧义，它不是告诉你套接字目前是否正在连接到一个远程的主机。相替代的，它告诉你该套接字是否曾经连接到一个远程主机。如果套接字可以连接到远程主机，这个方法返回true，即使套接字已经被关闭。为了判断套接字是否是打开的，你需要检查isConnected()返回true，并且isClosed()返回false。比如：
				boolean connected = socket.isConnected() && !socket.isClosed();
			最后，isBound()方法告诉你套接字是否成功绑定到本地主机的外出的端口。isConnected()指的是套接字的远程端，isBound()指的是本地端。这不是很重要。
		toString()
			Socket只重写了java.lang.Object: toString()。toString()生成一个看起来像这样的字符串：
				Socket[addr=www.oreilly.com/198.112.208.11,port=80,localport=50055]
			这个对于调试很有用，不要依赖于这种格式，它可能在以后发生变化。这个字符串的任何部分都可以通过其他方法（特别是getInetAddress(), getPort(), and getLocalPort()）来获取。
			因为套接字对象是短期对象，它持续的时间和它代表的连接一样长，没有太多的理由将他们存储在hash table或对他们进行比较。因此Socket没有重写equals()或hashcode()，这些方法的语义就是Object对象中的语义。两个Socket对象只有在他们都是相同的对象才相互相等。
	设置套接字的属性
		套接字属性指明java Socket类依赖的原生的套接字如何发送和接收数据。java提供了9个属性为客户端套接字：
			• TCP_NODELAY
			• SO_BINDADDR
			• SO_TIMEOUT
			• SO_LINGER
			• SO_SNDBUF
			• SO_RCVBUF
			• SO_KEEPALIVE
			• OOBINLINE
			• IP_TOS
		这些看起来滑稽的名字来自于套接字被发明的Berkeley Unix的c头文件中的命名常量。因此它遵循经典的Unix C约定，而不是更易于理解的java命名约定。比如，SO_SNDBUF事实上意味着“Socket Option Send Buffer Size.”
		TCP_NODELAY
			public void setTcpNoDelay(boolean on) throws SocketException
			public boolean getTcpNoDelay() throws SocketException
			设置TCP_NODELAY为true，确保数据报被立即发送，而不管他们的大小。通常，小的数据报在发送之前被联合成大的数据报。在发送另一个数据报之前，本地主机等待从远程主机获取上一个数据报的响应。这个被称为Nagle’s algorithm。该算法的问题是如果远程主机没有足够快的向本地主机发送回响应，那些依赖于小的信息的稳定传输的应用就会慢下来，这个问题对于GUI程序，比如网络或网络计算机应用，客户端需要实时跟踪客户端的鼠标移动，尤其明显。在一个确实很慢的网络中，即使简单的输入也会很慢，因为恒定的缓冲。设置TCP_NODELAY为true将禁用该缓冲模式，以使所有的数据报在他们准备好时就立即发送。
			setTcpNoDelay(true)关闭针对套接字的缓冲，setTcpNoDelay(false)将它打开。如果缓冲被关闭，那么getTcpNoDelay()返回true，否则返回false。比如，下面的片段关闭缓冲（那就是，它打开TCP_NODELAY）：
				if (!s.getTcpNoDelay()) s.setTcpNoDelay(true);
			这两个方法都声明为抛出SocketException，当底层的套接字实现不支持TCP_NODELAY选项时。
		SO_LINGER
			public void setSoLinger(boolean on, int seconds) throws SocketException
			public int getSoLinger() throws SocketException
			SO_LINGER选项指明当套接字关闭时,如何处理那些还没有被发送的数据报.默认的,close()方法会立即返回,但是系统仍然会尝试着发送剩余的数据.如果linger time被设置为0,那么当套接字被关闭时,没有被发送的数据报都会被丢弃.如果SO_LINGER是打开的,并且linger time是正数,close()方法将阻塞,用来等待指定的秒数,来发送数据和接收答复.当指定的秒数过后,套接字被关闭,并且任何剩余的数据都不会被发送.
			如果底层套接字实现不支持SO_LINGER选项,这两个方法都会抛出SocketException.setSoLinger()也会抛出IllegalArgumentException,如果你尝试设置linger time为一个负数.然而,getSoLinger()也可以返回-1来指明这个选项被禁用,并且等待足够多的时间来等待剩余的数据被发送.比如,设置Socket s的linger time为4分钟,如果它还没有被设置为其他值:
				if (s.getTcpSoLinger() == -1) s.setSoLinger(true, 240);
			linger time的最大值是65,535秒，或许在一些平台上会更小。大于最大值的时间将会被设置为linger time的最大值。坦白的说，65535秒比你实际上想要等待的时间要长。通常，平台默认的值会更前当。
		SO_TIMEOUT
			public void setSoTimeout(int milliseconds) throws SocketException
			public int getSoTimeout() throws SocketException
			通常，当你尝试从一个套接字中读取数据，read()会阻塞足够长的时间来获取足够的字节。通过设置SO_TIMEOUT，你可以确定调用阻塞的时间不会超过一个指定的毫秒数。当时间超时，一个InterruptedIOException会被抛出，你应该准备好捕获它。虽然这一次read()调用失败了，你可以再次尝试从该套接字读取数据，下一次调用可能会成功。
			超时时间以毫秒数来指定。0被解释为从不超时，它是默认值。比如，如果要设置Socket s的超时值为3分钟，如果它还没有被设置的话：
				if (s.getSoTimeout() == 0) s.setSoTimeout(180000);
			如果底层的实现不支持SO_TIMEOUT选项，那么这两个方法都会抛出SocketException。如果指定的超时数为负值，setSoTimeout()方法也会抛出IllegalArgumentException。
		SO_RCVBUF和SO_SNDBUF
			TCP使用缓冲来改进网络的性能。大的缓冲区倾向于改进相对较快的（10M或以上）连接的性能，反之较慢的，拨号连接使用较小的缓冲区会更好。通常，传输大的，连续的数据块，这个在文件传输协议，比如TCP或HTTP中很普通，使用较大的缓冲区会好一些。反之，一些小的交互性会话的传输，比如Telnet或一些游戏，使用较大的缓冲时表现不是很好。相对较早的操作系统，被设计于小文件或网速较慢的年代，比如BSD 4.2使用2k的缓冲区。Windows XP使用17520字节的缓冲区。目前，128k是通常的默认值。			
			最大可用带宽等于缓冲区大小除以延迟数。比如，在Windows XP上，假如两个主机之间的延迟是半秒，即0.5秒，那么带宽就是17520 bytes / 0.5 seconds = 35040 bytes/second = 273.75 kilobits/second。这是任何套接字的最大速度，无论网络有多快。这对拨号连接来说很快，对于ISDN来数不是很差，但是对于DSL或FIOS确实不是很充分。
			你可以通过减少延迟来提升速度。然而，延迟和网络硬件以及你的应用程序控制之外的其他因素相关。另一方面，你可以控制缓冲区的大小。比如，如果你增加缓冲区大小从17520字节到128kilobytes，最大带宽增加到2MB/s。再次将缓冲区翻倍到256kb，最大带宽增加到4mb/s。当让，网络自己对最大带宽有影响。将缓冲区设置的太高，你的程序将尝试以比网络能处理的速度来发送和接受数据，会导致阻塞，丢包，和较低的性能。因此，当你想要最大带宽，你需要匹配缓冲区大小和连接的延迟，使他们比网络带宽稍微小一些。
			你可以使用ping来手动的检测到一个指定主机的延迟，或者你可以记录从你的程序中发起的一个InetAddress.isReachable()的调用的时间。
			SO_RCVBUF用于控制建议的用于网络输入的缓冲区的大小。SO_SNDBUF选项控制建议的用于网络输出的缓冲区的大小。
				public void setReceiveBufferSize(int size) throws SocketException, IllegalArgumentException
				public int getReceiveBufferSize() throws SocketException
				public void setSendBufferSize(int size) throws SocketException, IllegalArgumentException
				public int getSendBufferSize() throws SocketException
			虽然，看起来你可以独立的设置发送和接收缓冲区的大小，缓冲区通常被设置为这两个中较小的那个的值。比如，如果你设置发送缓冲区的大小为64K，接收缓冲区的大小为128K，你将得到发送缓冲区和接收缓冲区的大小都是64K。java将报告接收缓冲区的大小为128K，但底层TCP栈事实上将使用64K。
			setReceiveBufferSize()/setSendBufferSize方法建议一个字节数作为该套接字上的缓冲区大小。然而，底层实现可以自由忽略或调整这个建议值。事实上，Unix和Linux系统通常指定一个最大缓冲区大小，典型的是64K或256K，并且不允许任何套接字有一个更大的值。如果你尝试设置一个更大的值，java将把它设置为最大可能的缓冲区大小。在Linux上，底层实现会翻倍请求的大小，并不是前所未闻的。比如，如果你请求一个64K的缓冲区，你可能得到的是一个128K的。
			这两个方法会抛出IllegalArgumentException，当参数小于或等于0时。虽然，他们声明为会抛出SocketException，但事实上，他们可能不会。因为SocketException抛出的原因和IllegalArgumentException相同，并且对IllegalArgumentException的检查应该首先进行。
			总的来说，如果你发现你的应用不能完全利用可用的网络带宽（比如，你有一个25 Mbps的网络连接，但是你的数据以15 Mbps的速度被传输），可以尝试增加缓冲区的大小。然而，大多数时候，除非你确实想要一个方向或两个方向上的网络连接很繁重，默认值就很好了。特别是，现在操作系统使用TCP窗口调整（不能从java来控制）来动态的调整缓冲区的大小来适应网络。就像大多数的性能调整建议一样，经验法则就是不要做它，除非你已经检测到了一个问题。即使这样，通过在操作系统层面增加最大可用缓冲区的大小，比调整单独的套接字的缓冲区大小，可以获得更多的速度。
		SO_KEEPALIVE
			SO_KEEPALIVE是打开的，客户端偶尔在一个空闲的连接上发送一个数据报（通常是每2个小时发送一次），仅仅是用来确保服务器没有挂掉。如果服务器端响应这个数据报失败，客户端会一直尝试比11分多一点的时间，直到它收到响应。如果它在12分中内没有接收到响应，客户端关闭套接字。没有SO_KEEPALIVE，一个不活跃的客户端将或多或少的永远存活，而不会知道服务器端已经挂掉。这些方法打开或关闭SO_KEEPALIVE的状态，并且决定它当前的状态：
				public void setKeepAlive(boolean on) throws SocketException
				public boolean getKeepAlive() throws SocketException
			SO_KEEPALIVE默认是false。下面这个代码片段关闭SO_KEEPALIVE，如果它是打开的：
				if (s.getKeepAlive()) s.setKeepAlive(false);
		OOBINLINE
			TCP有一个功能，可以在带外（out of band）发送一个字节的紧急数据。这里的带外可能指该字节的优先级很高，在缓冲区内的其他字节之前优先发送。这个数据被立即发送。更进一步，接受端在接收到紧急数据时会被通知，并且可以选择在处理已经到达的其他数据之前处理紧急数据。java支持发送或接收这种紧急数据。发送方法是命名的，足够明显，sendUrgentData()：
				public void sendUrgentData(int data) throws IOException
			这个方法几乎立即发送它的参数的最低位的字节。如果需要，任何当前缓存的数据都先被flush。
			接受端如何响应紧急数据有一些迷惑，并且根据平台和API的不同而不同，一些系统分别的从常规数据中接受紧急数据。然而，更通常和更现代的做法是，将紧急数据按它正常的顺序放到常规数据中，告诉应用有紧急数据可用，让它自己去队列中查找。
			默认的，java忽略从一个套接字中接收到的紧急数据，然而，如果你想要在常规数据中接受紧急数据，你需要将OOBINLINE选项设置为true，使用这些方法：
				public void setOOBInline(boolean on) throws SocketException
				public boolean getOOBInline() throws SocketException
			OOBINLINE默认是false。下面的代码片段打开OOBINLINE，如果它是关闭的：
				if (!s.getOOBInline()) s.setOOBInline(true);
			一旦OOBINLINE打开，任何接收到的紧急数据，将被以平常的方式放到套接字将要读取的输入流中。java不会将它和非紧急数据区分开。这使它不像理想中那么有用，但是如果你有一个特殊的字节，比如Ctrl-C，它对你的程序有特殊的意义，并且在常规的数据流中从不出现，那么这就允许你更快的发送它。
		SO_REUSEADDR
			当一个套接字被关闭，它不会立即释放本地端口，特别是当套接字被关闭时，连接是打开的。它可以等待很小的一段时间，来确保它接收到了任何逗留的数据报，那些数据报和该端口有关，并且在套接字关闭时，仍然正在网络中传输。系统对于它接受到的任何迟到的数据报不会做任何事情。他们仅仅只是确保这些数据报不会被反馈给绑定到相同端口的新的进程。
			在一个随机的端口上，这不是一个很大的问题，但这可能是一个问题，当套接字绑定到一个著名的端口，因为它阻止任何其他套接字同时使用那个端口，如果SO_REUSEADDR被打开，默认是关闭的，其他套接字允许绑定到端口，即使可能有数据没有交付给前一个套接字。
			在java中，这个选项由这两个方法控制：
				public void setReuseAddress(boolean on) throws SocketException
				public boolean getReuseAddress() throws SocketException
			为了使这个工作，setReuseAddress()必须在新的套接字绑定到端口之前被调用。这意味着套接字需要使用没有参数的构造函数，以未连接的状态被创建，然后调用setReuseAddress(true)，并且套接字使用connect()方法被连接。要使它起作用，只有前一个连接的套接字和新的重用旧地址的套接字都将SO_REUSEADDR设为true。
		IP_TOS服务的分类
			不同类型的网络服务有不同的性能要求。比如，视频聊天要求比较高的带宽和较低的延迟。相反，邮件可以在较低带宽的连接上被传输，并且即使挂起几个小时也没有大的损害。VOIP相对于视频需要较少的网络带宽，但需要较小的波动。
			服务的种类被存储在IP头的一个称为IP_TOS的8个字节的字段中。java允许你查看或设置套接字在这个字段中存放的值，通过下面两个方法：
				public int getTrafficClass() throws SocketException
				public void setTrafficClass(int trafficClass) throws SocketException
			trafficClass的值是一个0到255之间的int值。因为这个值要被拷贝到TCP头的一个8位的字段中，只有这个int值的最低位字节会被用到。这个范围之外的值会导致IllegalArgumentException.
			在21世纪的TCP栈中，这个字节的高6位包含一个Differentiated Services Code Point (DSCP)的值，低位的2位包含一个Explicit Congestion Notification (ECN)的值。DSCP因此有最多2的6次方种不同的通信类别。然而，它是由独立的网络或路由器来指明具体的这64种不同的DSCP值意味着什么。下面表格列出的4个值相对比较一般：
			通常的DSCP值和解释：
				PHB (Per Hop Behavior) 		Binary value 			Purpose
				Default 			00000				Best-effort traffic.
				Expedited Forwarding (EF) 	101110 				Low-loss, low-delay, low-jitter traffic. Often limited to 30% or less of network capacity.
				Assured Forwarding (AF) 	multiple 			Assured delivery up to a specified rate.
				Class Selector 			xxx000 				Backward compatibility with the IPv4 TOS header, as stored in the first three bits.
			比如，Expedited Forwarding PHB对于VOIP是一个很好的选择，EF通信通常会被给予高于其他通信类型的严格的优先级队列。下面的代码片段通过设置通信类型为10111000，来设置套接字使用Expedited
Forwarding：
				Socket s = new Socket("www.yahoo.com", 80);
				s.setTrafficClass(0xB8); // 10111000 in binary
			记住这个数字的低2位应该是Explicit Congestion Notification，并且应该被设置为0.
			Assured Forwarding实际上是12中不同的DSCP值，他们被分为4类，展示在下面的表格中。这里的意图是让发送者表达当网络拥挤时，那些数据报应该被丢掉的相对的喜好。在同一个分类中，拥有低优先级的数据报要先于拥有高优先级的数据报被丢弃。在不同的分类之间，高优先级的分类被选择，但低优先级的分类不会完全饥饿。
			Assured forwarding优先级分类：
							Class 1 (lowest priority) 	Class 2		Class 3		Class 4 (highest priority)
				Low Drop Rate 		AF11 (001010) 			AF21 (010010) 	AF31 (011010) 	AF41 (100010)
				Medium Drop Rate 	AF12 (001100) 			AF22 (010100) 	AF32 (011100) 	AF42 (100100)
				High Drop Rate 		AF13 (001110)			AF23 (010110) 	AF33 (011110) 	AF43 (100110)
			比如，下面的代码片段使用不同的转发特性建立了3个套接字。如果网络足够拥挤，套接字3，在分类4中，有较高的丢弃概率，将发送大部分它的数据。socket 1，在分类1中，有较低的丢弃概率，也可以发送数据。socket 3，虽然也在分类1，但有较高的丢弃概率，将会完全阻塞，直到拥堵缓和下来使套接字2不再丢弃数据报。
				Socket s1 = new Socket("www.example.com", 80);
				s1.setTrafficClass(0x26); // 00100110 in binary
				Socket s2 = new Socket("www.example.com", 80);
				s2.setTrafficClass(0x0A); // 00001010 in binary
				Socket s3 = new Socket("www.example.com", 80);
				s3.setTrafficClass(0x0E); // 00001110 in binary
			DSCP不是严格的固定不变的服务保证。实际上，虽然某些网络内部遵守DSCP值，当数据报通过ISP时，这些信息基本总是被忽略。
			针对这些选项的java文档严重过期，并且描述了一些基于位的字段的服务模式，针对4中通信类型：低代价，高可靠性，最大吞吐，最小延迟。这个模式从没有被广泛的实现，并且可能在这个实际没有被使用。用来存放这些值的指定的TCP头，已经被改换意图，用来服务这里描述的DSCP和EN的值。然而，在你需要它的不太可能的事件中，你可以将这些值放在分类选择器PHB的高3位中，紧跟着的是0.
			底层的套接字实现不被要求遵守任何的这些请求。他们只是为TCP栈提供了一个暗示，关于想要的政策。一些实现完全忽略这些值。Android实际上针对setTrafficClass() 不会做任何操作。如果TCP栈不能提供请求的分类的服务，它可以，但没有被要求，抛出一个SocketException。
			作为表达喜好的一个替代方式，setPerformancePreferences()方法为连接时间，延迟和带宽，分配相对的喜好。
				public void setPerformancePreferences(int connectionTime, int latency, int bandwidth)
			比如，如果connectionTime是2, latency是1,
bandwidth是3，那么最大的带宽是最重要的因素，延迟最小，最不重要，连接时间在中间。如果connectionTime是2, latency是2, bandwidth是3，那么最大的带宽是最重要的因素，最小的延迟和连接时间有相同的重要性。确切的，任何给定的VM如何实现这个是独立的。确实，在某些实现中，它可能是不做任何操作。
	套接字异常
		Socket类的大部分方法被声明为抛出IOException或它的子类java.net.SocketException
			public class SocketException extends IOException
		然而，知道一个问题发生对于解决这个问题是不够的。远程主机拒绝连接是因为它忙吗？远程主机拒绝连接是因为没有服务在端口上监听吗？连接尝试超时是因为网络拥堵或因为主机挂掉了吗？SocketException有很多子类来提供关于哪里出错以及为什么：
			public class BindException extends SocketException
			public class ConnectException extends SocketException
			public class NoRouteToHostException extends SocketException
		一个BindException被抛出，如果你尝试构造一个Socket或ServerSocket对象在一个本地端口上，但那个端口正在被使用或你没有权利使用它。当一个连接被远程主机拒绝时，会抛出一个ConnectException，通常是因为远程主机忙或没有进程在监听那个端口。NoRouteToHostException表明连接超时。
		java.net包含ProtocolException，它是IOException的直接子类：
			public class ProtocolException extends IOException
		当接收到的数据来自于一定程度上违反TCP/IP规范的网络时，它将会被抛出。
		这些异常类没有任何特殊你在其他异常类找不到的方法，但是你可以利用这些子类提供有用的异常信息，或者决定是否重试那些可能成功的不愉快的操作。
	套接字在GUI应用中
		

第9章 服务器端套接字
	前面的章节从客户端的立场来讨论套接字：程序打开一个套接字到正在监听连接的服务器端。然而，客户端套接字自己并不足够，客户端没有太多用除非他们可以跟服务器端通话，并且前面讨论的Socket类不足以编写服务器端。为了创建一个Socket，你需要知道你想要连接到的网络主机。当你在编写一个服务器端，你不需要进一步知道谁将连接到你，并且即使你知道，你也不知道那个主机什么时候会连接到你。换句话说，服务器就像接线员，坐在电话旁边，等待电话进来。他们不知道谁，什么时候将打进来，他们只是当电话响时，拿起电话，和电话的另一端进行通话，你不能使用Socket自己来实现这个行为。
	对于接受连接的服务器端，java提供了ServerSocket类来表示服务器端套接字。本质上，服务器端套接字的工作就是坐在电话旁，等待电话打进来。更技术性的说，服务器端套接字运行在服务器端，并且监听进来的TCP连接。每个服务器端套接字监听服务器上的一个特定的端口。当远程主机上的一个客户端尝试着连接到那个端口，服务器端唤醒，协商服务器端和客户端的连接，并且返回一个常规的Socket对象来表示两个主机之间的套接字。换句话说，服务器端套接字等待连接，客户端套接字初始化连接。一旦一个ServerSocket建立起一个连接，服务器端使用一个常规的Socket对象来发送数据到客户端。数据总是在常规套接字上进行传输。
	使用ServerSocket
		ServerSocket类包含用java类编写服务器端的任何东西。它有构造函数来创建新的ServerSocket，用来监听在指定端口的连接的方法，用来配置不同服务器端套接字选项的方法，以及通常的混杂的方法，比如toString()。
		在java中，服务器端程序的基本生命周期是：
			1. 一个新的ServerSocket被创建在一个指定的端口上，使用一个ServerSocket()构造函数。
			2. ServerSocket使用它的accept()方法来监听尝试连接到那个端口的进来的连接。accept()会阻塞直到一个客户端尝试着建立一个连接。此时，accept()返回一个Socket对象，来连接客户端和服务器端。
			3. 根据服务器端的类型，或者是Socket的getInputStream()，或者是getOutputStream()，或者是两个都被调用来获取和客户端进行通信的输入流和输出流。
			4. 服务器端和客户端通过一个商定的协议进行通信，直到连接被关闭时。
			5. 服务器端，客户端或者两边关闭连接。
			6. 服务器端返回第二步，等待下一个连接。
		实现自己的daytime服务器很简单.首先,创建一个监听在13端口上的服务器段套接字:
			ServerSocket server = new ServerSocket(13);
		接着,接收一个连接:
			Socket connection = server.accept();
		accept()调用会阻塞.那就是,程序会停在那,并等待,可能是几天或几小时,直到一个客户端连接到13端口上.当一个客户端连接时,accept()方法返回一个Socket对象.注意,连接会返回一个java.net.Socket对象,和你前面章节用于客户端的一样.daytime协议要求服务器端讲话,所以从套接字中获得一个OutputStream.由于daytime协议要求文本,所以将它串联到一个OutputStreamWriter:
			OutputStream out = connection.getOutputStream();
			Writer writer = new OutputStreamWriter(writer, "ASCII");
		现在,得到当前的时间,并且将它写出到输出流.daytime协议不要求任何特定的格式,除了要求是人类可读的.所以让java为你选择:
			Date now = new Date();
			out.write(now.toString() +"\r\n");
		注意,使用回车/换行对来结束行.在一个网络服务器上,这基本总是你想要的.你应该显示的选择这个,而不是使用系统默认的行分割符,不管是通过System.getProperty("line.separator"),或者是隐式的通过一个方法,比如println():
		最后,flush连接,并关闭它:
			out.flush();
			connection.close();
		你将不总是需要在一次写出之后关闭连接.很多协议,dict和HTTP 1.1,比如,允许客户端在一个套接字上发送多个请求,并且期望服务器端发送多个响应.一些协议,比如FTP,允许永久的保持一个套接字打开.然而,daytime协议只要求一次响应.
		如果客户端在服务器端仍然操作时,关闭连接,连接服务器端到客户端的输入流/输出流会在下次读取/写出时抛出一个InterruptedIOException.不论任何一种情况,服务器端都应该准备好处理下一个进来的连接了.
		当然,你将想要重复的做这些,所以你可以将这些放到一个循环中.每次循环调用accept()方法一次。这将返回一个标识远程客户端和本地服务器端的连接的Socket对象。和客户端的交互通过该Socket对象发生，比如：
			ServerSocket server = new ServerSocket(port);
			while (true) {
				try (Socket connection = server.accept()) {
					Writer out = new OutputStreamWriter(connection.getOutputStream());
					Date now = new Date();
					out.write(now.toString() +"\r\n");
					out.flush();
				} catch (IOException ex) {
					// problem with one client; don't shut down
					// the server
					System.err.println(ex.getMessage());
				}
			}
		这被称为是一个iterative服务器端。有一个大的循环，在每次循环中，一个单独的连接被完整地处理。这个对于只有很少请求和响应的简单的协议，像daytime，工作的很好。通过这个简单的协议，可能使一个较慢的客户端延迟其他较快的客户端。接下来的例子将通过多线程或异步I/O来解决这个问题。	
		区分应该关闭服务器并记录错误日志的异常，和只需要关闭活跃连接的异常是很重要的。在一个特定连接范围内的异常应该关闭那个连接，但是不会影响其他连接或关闭服务器。在单独的请求之外的异常可能需要关闭服务器。为了组织这个，可以嵌套try块：
			ServerSocket server = null;
			try {
				server = new ServerSocket(port);
				while (true) {
					Socket connection = null;
					try {
						connection = server.accept();
						Writer out = new OutputStreamWriter(connection.getOutputStream());
						Date now = new Date();
						out.write(now.toString() +"\r\n");
						out.flush();
						connection.close();
					} catch (IOException ex) {
						// this request only; ignore
					} finally {
						try {
							if (connection != null) connection.close();
						} catch (IOException ex) {}
					}
				}
			} catch (IOException ex) {
				ex.printStackTrace();
			} finally {
				try {
					if (server != null) server.close();
				} catch (IOException ex) {}
			}
		当你使用完套接字时，通常要关闭它。在第8章我说过，一个客户端不应该依赖于连接的另一端来关闭套接字，这个对服务器端也一样。客户端超时或挂掉，客户端取消事务，在高通信量时期，网络瘫痪，黑客发起DOS攻击。对于任何这些原因或100个更多的原因，你不能依赖于客户端来关闭套接字，即使协议要求这么做。
		手动停止一个程序的命令依赖于你的系统，在Unix，windows，和很多其他系统，Ctrl-C可以完成。如果你在Unix系统的后台运行程序，可以找到服务的PID，通过kill命令(kill PID)来杀死它。
		如果你在Unix（包括linux和Mac OS X）上运行自己写的daytime，为了让他连接到13端口，你需要以root身份来运行。如果你不想或不能以root来运行，将端口改为1024以上的某一个，比如1313.
		服务二进制数据
			发送二进制的，非文本数据不是很困难。你只需要使用一个OutputStream来写出字节数组，而不是用Writer写出一个String。
		多线程服务器
			daytime和time都是很快的协议。服务器端最多发送一些字节，然后关闭连接。在移动到下一个之前，它停在那去完全处理每一个连接。在这种情况下，一个慢的或挂掉的客户端可能是服务器端挂起数秒，知道它被通知套接字已经损坏。如果发送数据要花费很长的时间，即使客户端和服务器端都运转正常，你将确实不想要每个连接都等待。
			旧的Unix服务器，比如wu-ftpd，创建一个新的进程来处理每一个连接，以使多个客户端能被同时服务。java程序应该包裹一个线程来和客户端交互，以使服务器端可以立即准备好处理下一个连接。一个线程会为服务器增加一个很小的负载，相对于一个完全的子进程。事实上，创建太多进程的开销就是为什么典型的Unix
FTP服务器不能处理多于400个连接，而不会慢的像爬。从另一方面来说，如果协议是简单的，快速的，并且在它完了允许服务器端关闭连接，服务器端立即处理客户请求，而不是包裹一个线程，将是更有效的。
			操作系统存储目的地址是到某一个特定端口的进来的连接请求到一个先进先出的队列。默认的，java设置队列的长度为50，虽然它会在操作系统之间相差很多。一些操作系统（不是Solaris）有一个最大的队列长度。比如，在FreeBSD，默认的最大队列长度是128.在这些系统上，对于java服务器端套接字来说，就是操作系统允许的值，或小于50或等于50.当队列被未处理的线程填充满，主机就会拒绝在那个端口上的额外的连接，直到队列中有插槽打开。很多客户端（虽然不是全部）都会尝试多次来建立一个连接，当他们的初始尝试被拒绝。多个ServerSocket构造函数允许你改变队列的长度，如果它默认的长度不是足够大。不管怎样，你不能增加队列的长度到操作系统支持的最大大小之外。不管队列的大小是多少，你都想要清空它的速度快于新连接到达的速度，即使需要花费一段时间来处理每个连接。
			这里的处理方法是给每个连接一个它自己的线程，和接收新连接到队列中的线程分开。这个可以解决一个慢的客户端会阻塞其他客户端的问题，这是一个thread per connection的设计。
		使用套接字向服务器端写
			到目前为止的例子，都是服务器端只向客户端套接字写，它还没有从它们进行读取。然而，很多协议要求服务器端两个都做。这个不难。你将像以前一样接受一个连接，但此时要请求InputStream和OutputStream。使用InputStream来从客户端读取，使用OutputStream来向客户端写出。最主要的是理解协议，什么时候读，什么时候写。
		关闭服务器端套接字
			如果你使用完了一个服务器端套接字，你应该关闭它，特别是当程序会继续运行一段时间的情况。这个将释放端口，为那些想要使用该端口的其他程序。关闭一个ServerSocket和关闭一个Socket不应该混淆。关闭一个ServerSocket，会在本地主机上释放一个端口，允许其他服务器绑定到这个端口上。它也会中断该ServerSocket
接收的，当前打开的套接字。
			当一个程序死亡时，服务器端套接字会自动关闭，因此在程序中关闭他们，即在ServerSocket不再被需要时，立即中止它，不是完全必须的。不管怎样，它没有损害。程序员通常遵循在try-finally块中相同的close-if-not-null模式，这个你已经在流或客户端套接字时很熟悉。
				ServerSocket server = null;
				try {
					server = new ServerSocket(port);
					// ... work with the server socket
				} finally {
					if (server != null) {
						try {
							server.close();
						} catch (IOException ex) {
							// ignore
						}
					}
				}
			你可以通过使用无参的构造函数ServerSocket()来稍微改进它，它不会抛出任何异常，也不会绑定到一个端口。相替代的，你可以在ServerSocket对象已经创建后，调用bind()来绑定到一个套接字地址。
				ServerSocket server = new ServerSocket();
				try {
					SocketAddress address = new InetSocketAddress(port);
					server.bind(address);
					// ... work with the server socket
				} finally {
					try {
						server.close();
					} catch (IOException ex) {
						// ignore
					}
				}
			在java 7中ServerSocket实现了AutoCloseable接口，所以你可以使用try-with-resources来替代：
				try (ServerSocket server = new
					ServerSocket(port)) {
					// ... work with the server socket
				}
			在一个服务器端套接字被关闭之后，它不能被重新连接，即使是在相同的端口。
			如果ServerSocket已经关闭，isClosed()返回true，如果还没有返回false。
				public boolean isClosed()
			以无参的构造函数ServerSocket()创建的ServerSocket对象，还没有绑定到一个端口，不被认为是关闭的。在这些对象上调用isClosed()会返回false。isBound()方法告诉你ServerSocket是否已经绑定到了一个端口：
				public boolean isBound()
			就像第8章讨论的Socket类的isBound()方法一样，名字会有一些歧义。如果ServerSocket曾经绑定到一个端口上，isBound()就返回true，即使它现在已经被关闭。如果你要测试ServerSocket是否是打开的，你就需要同时检测isBound()返回true，并且isClosed()返回false。比如：
				public static boolean isOpen(ServerSocket ss)
				{
					return ss.isBound() && !ss.isClosed();
				}
	日志
		服务器会在无人值守的情况下运行很长时间,直到在服务器上发生了什么,很重要.为了这个原因,建议存储服务器上的日志一段时间.
		记录什么
			有两个主要的东西你想要在你的日志中记录:
				请求
				服务器错误
			确实,服务器通常为这两个项目保持两个不同的日志文件.审计日志通常为每个连接到服务器的连接保持一条记录.当服务器对每个连接执行多个操作时,可以相替代的为每个操作保持一条记录.比如,dict服务器可能会为用户查询的每个单词保存一条记录.
			错误日志包含了服务器运行期间发生的大部分的不可预期的异常.比如,任何发生的NullPointerException都应该被记录,因为它指明了一个服务器上的你应该解决的bug.错误日志不包含客户端错误,比如,一个客户端意外的断开连接,或发送一个异常格式的请求.这些都进入到请求日志,错误日志只包含不可预期的异常.
			针对错误日志的大概的规则是错误日志中的每一行都应该被察看和解决.错误日志的理想记录数是0.这个日志中的每条记录都代表一个应该被研究并解决的bug.如果对错误日志记录的研究结果是这个异常其实不是一个问题,代码按原有的期望工作,那么就删除这个日志记录.错误日志如果充满太多的错误警告会迅速变得被忽略或无用.
			相同的原因,在生产环境不要保留调试日志.不要记录你进入某个方法,某个条件得到满足等等.没有人会察看这些日志.他们只会浪费空间和隐藏真实的问题.如果你需要方法级别的日志来用于调试,将它们放到一个单独的文件中.当在生产环境运行时,在一个全局性的配置文件中关闭他们.
			更先进的日志系统会提供日志分析工具,允许你做一些事情,像只显示优先级为INFO或更高的日志,或只显示产生于某特定代码块的日志.这些工具使保持一个日志文件或数据库变得可行,甚至更进一步,多个程序共享同一个日志.仍然适用的一个原则是没有人察看的日志是无用的,而且往往会分散注意力或引起混淆.
			不要遵循你认为在未来的某一天某些人可能需要的任何东西的反模式.实际上,程序员很难提前猜想他们可能需要哪些日志内容来调试生产环境错误.一旦问题发生,你需要哪些日志很明显,但很难提前猜想的到.添加以防万一的消息到日志文件中意味着,当有错误发生时,你需要在很多的不相关信息中寻找相关的消息.
		如何记录
			很多追溯到java 1.3或之前的合法的程序,仍然使用第三方的日志库,比如,log 4j或Apache Commons Logging.但是自从java 1.4可用的java.util.logging包可以满足大多数的需要.选择它可以避免大量复杂的第三方依赖.
			虽然你可以在需要时加载一个记录器,但通常最简单的是为每一个类创建一个,像这样:
				private final static Logger auditLogger = Logger.getLogger("requests");
			记录器是线程安全的,所以将他们存储在共享的静态字段中不会有问题.确实,他们几乎必须是,因为即使Logger对象不是在线程之间共享,日志文件或数据库将会是.这个在多线程服务器中很重要.
			这个例子输出到一个命名为requests的日志.多个Logger对象可以输出到同一个日志文件,但是每个记录器通常记录到一个日志.记录什么和记录到哪通常由外部的配置文件决定,通常它是一个文件,可能是,也可能不是命名为"requests",但是它可以是一个数据库,一个运行在不同服务器上的SOAP服务,相同主机上的另一个java程序,等等.
			一旦你有了一个记录器,你就可以使用很多方法来向它写出.最基本的是log()。比如，catch块记录一个未预期的运行时异常以最高的等级：
				catch (RuntimeException ex) {
					logger.log(Level.SEVERE, "unexpected error " + ex.getMessage(), ex);
				}
			包含一个异常，而不是只是一条消息，通常是在catch块中记录日志的通常的做法。
			有7个等级以命名常量的形式定义在java.util.logging.Level中，以严重性的逆序：
				• Level.SEVERE (highest value)
				• Level.WARNING
				• Level.INFO
				• Level.CONFIG
				• Level.FINE
				• Level.FINER
				• Level.FINEST (lowest value)
			我使用info于监控日志，warning或severe于错误日志。低等级只是用于调试，不应该被用于生产环境。info，severe和warning都有相应的便利的帮助方法来记录日志在那个等级。比如，这个代码块记录一次访问，包括日期和远程地址。
				logger.info(new Date() + " " + connection.getRemoteSocketAddress());
			你可以使用任何方便于单条日志记录的格式。通常，每条记录应该包含一个时间戳，客户端地址，将要被处理的，为请求指明的任何信息。如果日志消息代表一个错误，包含被抛出的任何的异常。
			并不是每一个异常都自动转换成一个错误日志记录。比如，当你正在写出时间时，客户端丢失连接，这是一个IOException。然而，这不是一个bug或一个服务器端bug，所以它没有被写进错误日志。在一些情况下，你可能想要将它记录进监控日志，或一个第三方的地方。然而，记住日志的黄金法则：如果没有人会察看它，就不要记录它。除非你确实想要针对客户端断开连接进行研究或做些什么，否则不要为他们烦恼或记录他们。
			通常，日志只是被输出到终端。
			你可能想要配置运行时环境，以使日志文件可以记录到一个固定的地点。虽然，你可以在代码中指定这个，你通过在虚拟机启动时，传递-Djava.util.logging.config.file=_filename_argument来设置这个属性。比如，在Mac OS X中，它可能被设置在Info.plist文件中的VMOptions中：
				<key>Java</key>
				<dict>
					<key>VMOptions</key>
					<array>
						<string>-Djava.util.logging.config.file=/opt/daytime/logging.properties</string>
					</array>
				</dict>
			下面是一个简单的日志属性文件，它指明了：
				日志应该被写出到一个文件；
				请求日志应该在/var/logs/daytime/requests.log文件中，以Info的等级
				错误日志应该在/var/logs/daytime/requests.log文件中，以Severe的等级
				限制日志文件大小为10M，然后循环
				保留两个日志文件，当前的和前一个
				使用基本的文本格式，而不是XML
				日志文件的每一行都应该使用格式：等级 消息 时间戳
					handlers=java.util.logging.FileHandler
					java.util.logging.FileHandler.pattern = /var/logs/daytime/requests.log
					java.util.logging.FileHandler.limit = 10000000
					java.util.logging.FileHandler.count = 2
					java.util.logging.FileHandler.formatter = java.util.logging.SimpleFormatter
					java.util.logging.FileHandler.append = true
					java.util.logging.SimpleFormatter.format=%4$s: %5$s [%1$tc]%n

					requests.level = INFO
					audit.level = SEVERE
			下面是一些典型的日志输出，（注意在请求消息中，时间戳看起来是出现了两次，因为日志消息包含当前的时间）：
				SEVERE: Couldn't start server [Sat Apr 13 10:07:01 EDT 2013]
				INFO: Sat Apr 13 10:08:05 EDT 2013 /0:0:0:0:0:0:0:1:57275
					[Sat Apr 13 10:08:05 EDT 2013]
				INFO: Sat Apr 13 10:08:06 EDT 2013 /0:0:0:0:0:0:0:1:57276
					[Sat Apr 13 10:08:06 EDT 2013]
			我不喜欢java日志API的一个原因是，他没有提供一个简单的方法来通过配置文件声明，不同的消息属于不同的日志。比如，你不能很容易的分开你的错误和监控日志。他可以被实现，但要求你定义一个新的FileHandler的子类，为每一个单独的日志，因此你可以为他分配一个新的文件。
			最后，一旦你为你的服务器配置了日志，不要忘了察看它，特别是错误日志。不会被任何人察看的日志文件是毫无意义的。你也想要计划并实现日志滚动和保留策略。硬盘每年都会变大，但对于一个高负载的服务器，仍然可能使用日志文件将文件系统填满，如果你不注意的话。
	构造服务器端套接字
		有4个公共的ServerSocket构造函数：
			public ServerSocket(int port) throws BindException, IOException
			public ServerSocket(int port, int queueLength) throws BindException, IOException
			public ServerSocket(int port, int queueLength, InetAddress bindAddress) throws IOException
			public ServerSocket() throws IOException
		这些构造函数指明了端口，用于保持进来的连接请求的队列的长度，要绑定到的本地网络接口。他们基本做相同的事情，虽然一些为队列长度和绑定到的地址使用默认的值。
		比如，为了为HTTP服务器在80端口上创建一个服务器端套接字，你可以这样写：
			ServerSocket httpd = new ServerSocket(80);
		为了为HTTP服务器在80端口上创建一个队列长度为50的服务器端套接字：
			ServerSocket httpd = new ServerSocket(80, 50);
		如果你尝试设置大于操作系统最大队列长度的值，它将用操作系统的最大值来代替。
		默认的，如果一个主机有多个IP地址或网络接口，服务器端套接字会监听在所有网络接口和IP地址的指定端口。然而，你可以添加第三个参数，来指定只绑定到一个特定的本地IP地址。也就是，服务器端套接字只监听指定地址进来的连接，它不会监听主机其他地址进来的连接。
		在这三个构造函数中，你可以为端口号传递0，系统为你选择一个可用的。像这样，由操作系统选择的端口，有时候叫做匿名端口，因为你提前不知道它的端口号（虽然你可以在端口号被选择之后找到它）。这个通常在多套接字协议中比较有用，比如FTP。在被动的FTP中，客户端首先通过一个著名的端口21连接到一个服务器，所以服务器应该指定这个端口。然而，当一个文件需要被传输，服务器端开始监听在任何可用的端口。服务器端然后告诉客户端，他应该连接到哪个端口来获取数据，使用已经在端口21上打开的命令连接。因此，数据端口可以在一个会话和下个会话之间不同，并且不需要提前知道。对于主动的FTP很相似，除了客户端监听在一个用于服务器端连接到它的短暂的端口）
		所有这些构造函数都抛出IOException，特别是，一个BindException，如果套接字不能被创建并且绑定到请求的端口上。创建一个ServerSocket时抛出IOException通常意味着两件事情中的一件：或者是其他的服务器端套接字，可能是来自于一个完全不同的程序，已经使用了请求的端口，或者是你请求绑定到一个0-1023范围内的端口，在Unix上，在没有root权限的情况下。
		构造而不绑定
			没有参数的构造函数，创建了一个ServerSocket对象，但是并没有实际上将它绑定到一个端口，所以它不能初始的接受一个连接。它可以在后面使用bind()方法来绑定：
				public void bind(SocketAddress endpoint) throws IOException
				public void bind(SocketAddress endpoint, int queueLength) throws IOException
			这个功能的主要用途是允许程序在将服务器端套接字绑定到一个端口之前，设置它的属性。一些属性在服务器端套接字绑定之后就固定了。大概的模式看起来像这样：
				ServerSocket ss = new ServerSocket();
				// set socket options...
				SocketAddress http = new InetSocketAddress(80);
				ss.bind(http);
			你也可以给SocketAddress传递一个null来选择一个任意的端口。这就像为其他的构造函数传递的端口参数传递一个0。
		获取关于服务器端套接字的信息
			ServerSocket提供了两个getter方法，告诉你服务器端套接字使用的本地地址和端口。如果你已经打开了一个服务器端套接字在一个匿名的端口上，并且/或，在一个未指明的网络接口上时，很有用。比如，在一个FTP会话的数据连接中：
				public InetAddress getInetAddress()
			这个方法返回服务器端（本地主机）正在使用的地址。如果本地主机只有一个单一的IP地址（大多数都是这样），这个就是InetAddress.getLocalHost()返回的地址。
			如果本地主机有多于一个的IP地址，返回的指定的IP地址是主机IP地址的其中一个。你不能预测你将获得哪个地址。比如：
				ServerSocket httpd = new ServerSocket(80);
				InetAddress ia = httpd.getInetAddress();
			如果ServerSocket还没有绑定到一个网络接口，这个方法返回null。
				public int getLocalPort()
			ServerSocket构造函数允许你通过传递一个0作为端口号来监听在一个未指定的端口。这个方法允许你找出你正在监听哪个端口。你可能会在一个端到端的多套接字程序中使用这个，或一个服务器端可能包裹了一些小的服务器端来处理特定的操作。著名的服务器端将通知客户端在哪些端口可以找到更小的服务器端。
			如果ServerSocket还没有绑定到一个端口，getLocalPort()返回-1。
			就像大多数java对象一样，你可以通过ServerSocket的toString()方法来打印它。ServerSocket的toString()方法返回的String看起来像这样：
				ServerSocket[addr=0.0.0.0,port=0,localport=5776]
			addr是服务器端套接字绑定到的本地网络接口的地址。如果它绑定到所有的接口，这个将是0.0.0.0。port通常是0。localport是服务器端用来监听连接的本地端口。这个方法有时候对调试很有用，但也不是太有用。不要依赖它。
		套接字选项
			套接字选项指明ServerSocket依赖的原生套接字如何发送和接收数据。对于服务器端套接字，java提供了3个选项：
				• SO_TIMEOUT
				• SO_REUSEADDR
				• SO_RCVBUF
			它也允许你为服务器端数据报设置性能倾向。
			SO_TIMEOUT
				SO_TIMEOUT是accept()方法在抛出一个java.io.InterruptedIOException之前，等待一个进来的连接的时间总数，单位是毫秒。如果SO_TIMEOUT是0，accept()将从不超时。默认是从不超时。
				设置SO_TIMEOUT不是很平常。如果你正在实现一个复杂的，安全的协议，要求客户端和服务器端有多个连接，响应需要在一个指定的时间之内发生，你可能需要它。然而，大多数的服务器端被设计用来运行无限期的时间，所以只管使用默认的超时值，0（永不超时）。如果你想要改变这个，setSoTimeout()为服务器端套接字对象设置SO_TIMEOUT：
					public void setSoTimeout(int timeout) throws SocketException
					public int getSoTimeout() throws IOException
				当accept()被调用时，计数器开始计数。当超时发生，accept()抛出一个SocketTimeoutException，一个IOException子类。你需要在调用accept()方法之前设置这个属性。当accept()在等待连接时，你不能改变超时值。超时参数必须大于或等于0。如果它不是，这个方法抛出一个IllegalArgumentException。
				getSoTimeout()方法返回这个服务器端套接字当前的SO_TIMEOUT值。
			SO_REUSEADDR	
				服务器端套接字的SO_REUSEADDR属性和客户端套接字的相同属性很像。它决定了一个新的套接字是否被允许绑定到前一个正在被使用的端口，当有可能网络中仍然有数据正在传送给旧的套接字。就像你预期的那样，有两个方法来get和set这个属性：
					public boolean getReuseAddress() throws SocketException
					public void setReuseAddress(boolean on) throws SocketException
				默认值是平台相关的，下面的代码片段通过创建一个新的ServerSocket，并调用它的getReuseAddress()，来查看它的默认值：
					ServerSocket ss = new ServerSocket(10240);
					System.out.println("Reusable: " + ss.getReuseAddress());
				在我测试的Linux和Max OS X上，服务器端套接字默认是可重用的。
			SO_RCVBUF
				SO_RCVBUF属性设置由服务器端套接字接收的客户端套接字的默认接收缓冲区的大小。通过下面的两个方法来读取和设置：
					public int getReceiveBufferSize() throws SocketException
					public void setReceiveBufferSize(int size) throws SocketException
				在一个服务器端套接字上设置SO_RCVBUF，就像在accept()返回的每一个独立的套接字上调用setReceiveBufferSize()（除非在套接字被接收之后，你就不能改变接收缓冲区的大小）。快的连接想要一个大的缓冲区，虽然大多数时候默认值就很好了。
				你可以在服务器端套接字绑定之前/之后来设置这个属性，除非你想要设置接收缓冲区的大小为一个大于64K的值。在那种情况下，你必须在ServerSocket绑定之前设置该属性。
			服务分类
				就像前一章学到的，不同类型的网络服务有不同的性能需要。比如，实时的流的体育视频需要相对高的带宽。从另一方面，一个电影可能仍然需要一个高的带宽，但可以容忍较多的延迟。邮件可以在低带宽的连接上传送，并且即使滞留数小时也不会有大的损害。
				4个大概的传输类被定义为TCP：
					低成本
					高可靠
					最大吞吐
					最小延迟
				这写传输分类可以向一个给定的Socket请求。比如，你可以请求在低成本的情况下最小延迟可用。这些衡量是完全模糊和相对的，不会被保证的服务。并不是所有的路由器和原生TCP栈支持这些分类。
				setPerformancePreferences()方法表达了针对连接时间，延迟，和服务器端接受的套接字的带宽的相对偏好：
					public void setPerformancePreferences(int connectionTime, int latency, int bandwidth)
				比如，通过设置connectionTime为2, latency为1, 和bandwidth为3，你指明最大带宽是最重要的特性，最小延迟最不重要，连接时间是中间：
					ss.setPerformancePreferences(2, 1, 3);
				具体的任何给定的VM如何实现这个是实现独立的。底层的套接字实现不被要求遵守这些请求。他们只为TCP栈提供一个想要策略的暗示。很多实现，包括Android，完全忽略这些值。
	HTTP服务器
		这部分展示了一些你可以使用服务器端套接字构建的HTTP服务器，每个都有一个不同的特殊意图，每一个都比前一个稍微复杂一点。
		HTTP是一个很大的协议。就像你在第5章看到的那样，一个完整功能的HTTP服务器必须响应文件请求，转化URL到本地系统的文件名，响应POST和GET请求，处理请求文件不存在的情况，解析MIME类型，等等。然而，很多HTTP服务器不需要所有这些功能。
		比如，很多站点简单的显示一个“under construction”的消息。很明显，Apache对于这样的站点已经很足够了。java的网络类库使得编写像这样的一个简单的服务器很容易。
		定制的服务器不只对小站点有用。高负载的站点，像Yahoo！也是定制服务器的候选者，因为只做一件事情的服务器要比一个通常目的的服务器（比如Apache和微软IIS）要快。很容易优化一个针对特定任务的，有特殊意图的服务器，结果就是更有效，比一个需要响应很多不同类型的请求的通常意图的服务器。比如，图标和图片被很多页面重复使用，可以被一个在启动时读取所有图片文件到内存，然后从RAM直接服务的服务器很好的服务。更进一步，这些服务器可以避免浪费时间在记录日志上，如果你不想分开跟踪图片以及包含他们的页面。		
		最后，相对于Apache和IIS，java不是一个坏的语言来实现完整功能的web服务器。即使你相信CPU密集的java程序要比CPU密集的C或C++程序要慢，大多数HTTP服务器被网络带宽和延迟限制，而不是被CPU速度。因此，java的其他优点，像半编译/半解释特性，动态类加载，垃圾收集，和内存保护有机会发光。事实上，通过servlet，PHP页面，或其他机制大量使用动态内容的站点，在纯java或基本纯java的java web服务器上运行的更快。事实上，有一些生产环境的web服务器由java编写，比如Eclipse Foundation的Jetty。很多由C编写的其他web服务器，现在也包含相当的java组建来支持Java Servlet API和Java Server Pages。这些很大程度上替代了传统的CGI，ASP和服务器端包括，大多数是因为java替代物要更快，并且需要资源更少。然而，需要指出的一个重点是，通常意图的服务器，尤其是web服务器，是java和c在现实世界性能方面的竞争的一个领域。
	

第十章 安全套接字
	Java Secure Sockets Extension (JSSE)能够使网络通信安全，通过使用Secure Sockets Layer (SSL) Version 3和Transport Layer Security (TLS)协议以及他们相关的算法。SSL是一个安全的网络协议，它允许web浏览器和其他TCP客户端，和HTTP或其他TCP服务器端交互，使用不同层级的机密性和认证。
	安全通信
		机密通信通过一个开放的通道，比如Internet，绝对需要数据被加密。大多数的加密模式都基于一个key的概念，一种稍微更通常类型的密码，不只局限于文本。纯文本和key的位结合起来，通过数学算法，来产生加密过的密文。使用有更多位的key可以指数级的增加暴力破解的难度。
		在传统的安全key加密中，相同的key被用于加密和解密数据。发送者和接受者都必须知道相同的key。设想Angela想要给Gus发送一个加密的消息，她首先要发给Gus她将要使用的key，但这个key并没有被加密，因为Gus还没有key，所以Angela以未加密的形式发送key。现在假设Edgar正在监听Angela和Gus之间的连接，他也将同时得到key。从现在开始，他就可以使用key来读取Angela和Gus之间的任何通话。
		在公钥加密算法中，不同的key被用来加密和解密数据。一个key，称为公钥，用来加密数据。这个key可以给任何人。另一个key，称为私钥，用来解密数据，这个需要被安全持有，但是只需要被通信双方的一方进行处理。如果Angela想要发送一个消息给Gus，她问Gus要他的公钥。Gus在一个未加密的连接上发给Angela。Angela使用Gus的公钥加密消息，并且发送给Gus。如果Edger窃听到Gus发送给Angela的公钥，他也知道了公钥。然而，Edger仍然不能解密Angela发送给Gus的加密消息，因为解密需要Gus的私钥。即使公钥在传输的时候被窃听到，消息仍然是安全的。
		非对称加密也可以被用于认证和消息完整性检测。对于这种用法，Angela将使用她的私钥来加密消息。当Gus收到它，他用Angela的公钥对它进行解密。如果解密成功，Gus就知道消息来自于Angela。毕竟，没有其他人可以生产一个可以用Angela的公钥成功解密的消息。Gus也知道消息在网络上没有被改变，或者是被Edger恶意的，或者被有bug的软件无意的，或网络噪音，因为任何改变都将使解密出错。更进一步，Anglea可以双重加密消息，一次用她自己的私钥，一次用Gus的公钥，因此得到私密，认证和完整性三个好处。
		实际上，公钥加密更CPU密集，并且要比私钥加密慢。因此，相替代的使用Gus的公钥加密所有要传输的数据，Angela加密一个惯例的安全的key，并且将它发送给Gus。Gus使用他的私钥解密它。现在Angela和Gus都知道了安全的key，但是Edger不知道。因此Gus和Angela可以使用较快的安全key来加密，从而私密的通信，而没有Edger的监听。
		在这个协议上，Edger仍然有一个好的攻击方法，然而（重要的是：攻击是针对用来发送和接收消息的协议，而不是针对用来加密的算法）。当Gus给Angela发送他自己的公钥时，Edger不只要得到公钥，而且要用他自己的公钥替换掉它。然后，Angela认为她正在使用Gus的公钥加密数据，她实际上是使用Edger的公钥。当她发送一个消息给Gus，Edger拦截它，使用他自己的私钥解密，再使用Gus的公钥加密，并且发送给Gus。这被称为man-in-the-middle-attack。只工作在非安全的通道上，Gus和Angela没有容易的方法来防止它。现实中的解决方法是，Gus和Angela同时向一个信任的第三方的认证机构存储和验证他们的公钥。因此不再需要向彼此发送他们自己的公钥，而是从认证机构获取他们的公钥。这种模式仍然不是安全的，Edger可以将他放在Gus和认证机构之间，Angela和认证机构之间，Angela和Gus之间，但这使得Edger难度更大。
		就像这个例子指明的，加密和认证的理论和实践，算法和协议，是一个有挑战性的领域。设计一个坏的加密算法和协议要比设计一个好的更难。通常哪个算法或协议是好的，哪个是不好的，不是很明显。幸运的是，在使用java网络编程时，你不需要是一个密码专家。JSSE将你从底层的细节屏蔽掉，关于算法如何协商，key如何交换，通信双方是认证的，并且数据是加密的。JSSE允许你创建可以透明的处理安全通信需要的协商和加密的套接字和服务器端套接字。所有你需要做的就是在你从前面章节中熟悉的流和套接字上发送数据。Java Secure Socket Extension被划分为4个包：
			javax.net.ssl
				定义用于安全网络通信的JAVA API的抽象类
			javax.net
				抽象的套接字工厂类，用来替代使用构造函数来创建安全套接字
			java.security.cert
				用来处理SSL需要的公钥证书/认证的类
			com.sun.net.ssl
				在Sun的JSSE的参考实现中实现加密算法和协议的具体的类。从技术上说，他们不是JSSE标准的一部分。其他实现可能会替代这个包。比如，一个使用本地代码来加速CPU密集的key生成和加密流程。
	创建安全的客户端套接字
		如果你不关心底层的细节，使用一个加密的SSL套接字来和一个安全的服务器端通信，是最直接的。不是通过构造函数创建一个java.net.Socket对象，你通过jav
ax.net.ssl.SSLSocketFactory的createSocket()方法获取一个。SSLSocketFactory是一个遵循抽象工厂设计模式的抽象类。你可以通过调用静态的SSLSocketFactory.getDefault()来获取一个它的实例。
			SocketFactory factory = SSLSocketFactory.getDefault();
			Socket socket = factory.createSocket("login.ibiblio.org", 7000);
		这个要么返回一个SSLSocketFactory，要么抛出一个InstantiationException，如果没有具体的子类能被找到。如果你有一个到工厂的引用，使用5个重载的createSocket()方法中的一个来构建一个SSLSocket：
			public abstract Socket createSocket(String host, int port) throws IOException, UnknownHostException
			public abstract Socket createSocket(InetAddress host, int port) throws IOException
			public abstract Socket createSocket(String host, int port, InetAddress interface, int localPort) throws IOException, UnknownHostException
			public abstract Socket createSocket(InetAddress host, int port, InetAddress interface, int localPort) throws IOException, UnknownHostException
			public abstract Socket createSocket(Socket proxy, String host, int port, boolean autoClose) throws IOException
		前两个方法创建和返回一个连接到指定主机和端口的的套接字，或者IOException，如果不能连接。第三，四个方法连接和返回一个从指定的本地网络接口和端口连接到指定主机和端口的套接字。最后的createSocket()方法有一点不同。它起始于一个连接到一个代理服务器的已经存在的套接字。它返回一个Socket，通过这个代理服务器连接到指定的主机和端口。autoClose参数决定当这个套接字被关闭时，底层的代理套接字是否应该被关闭。如果autoClose是true，底层的套接字将被关闭，如果是false，它将不会。
		所有这些方法返回的Socket实际上都是一个javax.net.ssl.SSLSocket，java.net.Socket的一个子类。然而，你不需要知道那些。一旦安全套接字被建立，你使用它就像任何其他套接字一样，通过它的getInputStream(), getOutputStream()和其他方法。
		你会发现响应要比你预期的要慢。有很明显的一段CPU和网络负载，包括生成和交换公钥。即使在一个很快的网络上，也许要花费数秒的时间来建立连接。因此，你可能不像服务你的所有内容在HTTPS上，只有那些确实需要隐私，并且对延迟不敏感的内容才需要。
	选择加密套件
		JSSE的不同实现支持不同的认证和加密算法的组合。比如，Oracle在java 7的实现只支持128位AES加密。然而，IAIK的iSaSiLk实现支持256位AES加密。
		绑定到JSSE的JDK实际上有支持更强的256位加密的代码，但它被禁用，除非你安装了JCE Unlimited Strength Jurisdiction Policy Files。
		SSLSocketFactory的getSupportedCipherSuites()方法告诉你对于一个给定的套接字对象，哪些算法的组合是可用的：
			public abstract String[] getSupportedCipherSuites()
		然而，并不是所有可被理解的算法套件都有必要允许在连接上。有些因为太脆弱，因此被禁用掉。SSLSocketFactory的getEnabledCipherSuites()方法告诉你，哪些套件是这个套接字可以使用的：
			public abstract String[] getEnabledCipherSuites()
		实际使用的套件是客户端和服务器端在连接时协商得到的。也可能客户端和服务器端没有在任何套件上达成一致。也有可能虽然客户端和服务器端允许某一个套件，但其中一方或两方都没有使用这个套件所需要的key和证书。在任何一种情况下，createSocket()方法都将抛出SSLException，IOException的一个子类。你可以通过setEnabledCipherSuites()方法来改变客户端尝试使用的套件：
			public abstract void setEnabledCipherSuites(String[] suites)
		这个方法的参数应该是你想要使用的套件的一个列表。每个名字都应该是由getSupportedCipherSuites()方法列出的套件列表中的一个。Oracle的JDK 1.7支持这些套件：
			• TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256
			• TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
			• TLS_RSA_WITH_AES_128_CBC_SHA256
			。。。等等，很多
		每个名字都可以分成4个部分：协议，key交换算法，加密算法，和校验和。比如，名字SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA意味着Secure Sockets Layer Version 3，Diffie-Hellman方法用于key允许，没有认证，40位key的Data Encryption Standard加密，Cipher Block Chaining，以及Secure Hash Algorithm校验和算法。
		默认的，JDK 1.7实现允许所有的加密的认证的套件（这个列表的前28个）。如果你想要无认证的交易，或者有认证但无加密的交易，你必须使用setEnabledCipherSuites()方法来显式的允许这些套件，你可能想要避免那些名字中包含NULL, ANON, 或EXPORT的套件，除非你想要NSA能够读取你的消息。
		TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256被认为相当的安全，可以抵御所有已知的攻击。TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA256也很好，如果你已经允许它。通常，任何以TLS_ECDHE起始，并且以SHA256或SHA384结尾的套件被认为是目前广泛可用的最强的可能的加密套件。其他的一些会常受到一些不同程度的攻击。
		除了key长度之外，DES/AES和基于RC4的加密有一个很重要的不同。DES和AES是块加密（它们一次加密一定数量的字节）。DES通常加密64字节，如果不够64字节，会用额外的字节进行扩充。AES可以加密128，192，256位大小的块，在位数不够时，仍然需要用额外的位来扩充。这个对于文件传输应用，比如加密的HTTP和FTP，来说不是一个问题，或多或少所有的数据会立马变的可用。然而，对于以用户为中心的协议，比如chat和Telnet，会是一个问题。RC4是基于流的加密，一次加密一个字节，对于那些一次发送一个字节的协议更适用。
		比如，让我们假设Edger有一些相对强劲的并行计算机，可以很快地破解64位或更少位数的加密，并且Angela和Gus知道这个。为了安全，Angela和Gus决定只使用可用的最强的套件，恰好就是TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256。这个代码片断将它们的连接限制到那个套件：
			String[] strongSuites = {"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256"};
			socket.setEnabledCipherSuites(strongSuites);
		如果连接的一端不支持这个加密协议，套接字在尝试读取或写出时，将抛出一个异常。因此确定了机密的信息不会偶然的传输在脆弱的通道上。
	事件处理器	
		网络通信相比于大多数计算机的速度要慢。有认证的网络通信更慢。必须的key生成和安全连接建立的步骤很容易花费数秒时间。因此，你可能想要异步的处理连接。JSSE使用标准的java事件模型来通知程序，当客户端和服务器端之间的握手完成时。为了获得握手完成事件的通知，简单的实现HandshakeCompletedListener接口：
			public interface HandshakeCompletedListener extends java.util.EventListener
		接口定义了handshakeCompleted()方法：
			public void handshakeCompleted(HandshakeCompletedEvent event)
		这个方法接受一个HandshakeCompletedEvent作为参数：
			public class HandshakeCompletedEvent extends java.util.EventObject
		HandshakeCompletedEvent提供了4个方法来获取关于事件的信息：
			public SSLSession getSession()
			public String getCipherSuite()
			public X509Certificate[] getPeerCertificateChain() throws SSLPeerUnverifiedException
			public SSLSocket getSocket()
		尤其是HandshakeCompletedListener对象注册他们感兴趣的一个特定的SSLSocket的握手完成的事件，通过它的addHandshakeCompletedListener()和removeHandshakeCompletedListener()方法：
			public abstract void addHandshakeCompletedListener(HandshakeCompletedListener listener)
			public abstract void removeHandshakeCompletedListener(HandshakeCompletedListener listener) throws IllegalArgumentException
	会话管理
		SSL通常被用于WEB服务器，理由正当。Web连接倾向于短暂的，每个页面要求一个单独的套接字。比如Amazon的安全服务器上的结帐需要7个单独的页面加载，如果你想要编辑某个地址或选择礼品包装会更多。假设如果这些页面的每一个都花费额外的10秒，或更多，来协商一个安全的连接。因为高负载包括为了安全连接，而在客户端和服务器端之间的握手，SSL允许延续多个套接字的会话被建立。相同会话内的不同套接字使用相同的公钥和私钥。如果到Amazon的安全连接需要7个套接字，所有这7个都会被建立在同一个会话中，并且使用相同的key。只有这个会话中的第一个套接字将必须忍受key生成和交换的负载。
		作为一个使用JSSE的程序员，你不需要做任何其他的事情来使用会话。如果你在一个适当短的时间范围内打开了多个到同一主机，同一端口的多个安全套接字，JSSE将自动重用会话的key。然而，在高安全的应用中，你可能想要不允许多个套接字之间的会话共享，或强制一个会话的重新认证。在JSSE中，会话由SSLSession接口的实例来表示。你可以使用这个接口的方法来检测会话被创建的时间和上次访问的时间，使会话失效，获取关于会话的各种各样的信息：
			public byte[] getId()
			public SSLSessionContext getSessionContext()
			public long getCreationTime()
			public long getLastAccessedTime()
			public void invalidate()
			public void putValue(String name, Object value)
			public Object getValue(String name)
			public void removeValue(String name)
			public String[] getValueNames()
			public X509Certificate[] getPeerCertificateChain() throws SSLPeerUnverifiedException
			public String getCipherSuite()
			public String getPeerHost()
		SSLSocket的getSession()方法，返回这个套接字属于的Session：
			public abstract SSLSession getSession()
		然而，会话是性能和安全之间的权衡。为每一次和每一个交易都重新协商key会更安全。如果你已经拥有了足够强劲的硬件，并且尝试保护你的系统在一个相当程度的，富有的，有动机的，称职的竞争对手，你可能想要避免会话。为了防止套接字创建会话，可以向setEnableSessionCreation()方法传递false：
			public abstract void setEnableSessionCreation(boolean allowSessions)
		如果多套接字会话被允许，getEnableSessionCreation()将返回true，否则，返回false。
			public abstract boolean getEnableSessionCreation()
		在很少的情况下，你可能想要重新认证一个连接（扔掉上一次已经达成一致的所有的key和证书，重新启动一个会话）。startHandshake()可以干这个：
			public abstract void startHandshake() throws IOException
	客户端模式
		一个法则是，在大多数安全通信中，服务器端被要求使用恰当的证书来验证它自己。然而，客户端不需要。那就是，当我使用Amazon的安全服务器来购买一本书，它必须向我的浏览器证明它确实是Amazon，而不是黑客。然而，我不需要向Amazon证明我是谁。在很大程度上，它就应该是这样，因为购买和安装认证所需要的受信任的证书是一个相当的用户不友好的体验，读者不应该经历这些，而只是购买想要的书。然而，这种不对称会导致信用卡诈骗。为了解决这个问题，套接字可以被要求认证他们自己。这种策略对于向大众公开的服务不工作。然而，在特定的，内部的高安全的应用中是适当的。
		setUseClientMode()方法决定套接字在它的第一次握手时，是否需要认证。这个方法的名字有一点歧义。它可以被服务器端和客户端套接字使用。然而，当传递true时，它意味着套接字是客户端模式（不管它是不是在客户端），并且它自己不会提供认证。当传递false时，它将会尝试着自己认证：
			public abstract void setUseClientMode(boolean mode) throws IllegalArgumentException
		对于任何套接字这个属性只能被设置一次。尝试着第二次对它进行设置，会抛出一个IllegalArgumentException。
		getUseClientMode()方法简单的告诉你，这个套接字的第一次握手是否会进行认证：
			public abstract boolean getUseClientMode()
		服务器端的一个安全套接字（SSLServerSocket的accept()方法返回的），使用setNeedClientAuth()来要求所有连接到它的客户端认证它自己（或不认证）：
			public abstract void setNeedClientAuth(boolean needsAuthentication) throws IllegalArgumentException
		如果套接字不是服务器端的，那么这个方法将抛出IllegalArgumentException。
		如果套接字需要来自客户端的认证，getNeedClientAuth()将返回true，否则返回false：
			public abstract boolean getNeedClientAuth()
	创建安全的服务器端套接字
		安全的客户端套接字只是等式的一半。另一半是启用SSL的服务器端套接字。他们是javax.net.SSLServerSocket类的实例：
			public abstract class SSLServerSocket extends ServerSocket
		就像SSLSocket，这个类的所有的构造函数都是受保护的，并且实例都是由一个抽象的工厂类javax.net.SSLServerSocketFactory来创建：
			public abstract class SSLServerSocketFactory extends ServerSocketFactory
		同样就像SSLSocketFactory，SSLServerSocketFactory的一个实例由静态的工厂方法SSLServerSocketFactory.getDefault()返回：
			public static ServerSocketFactory getDefault()
		就像SSLSocketFactory，SSLServerSocketFactory有三个重载的createServerSocket()方法，来返回SSLServerSocket的实例，并且通过类比java.net.ServerSocket的构造函数很容易理解：
			public abstract ServerSocket createServerSocket(int port) throws IOException
			public abstract ServerSocket createServerSocket(int port, int queueLength) throws IOException
			public abstract ServerSocket createServerSocket(int port, int queueLength, InetAddress interface) throws IOException
		如果那就是创建安全的服务器端套接字的全部，他们用起来将会是很简单和直接。不幸的是，他们并不是全部。SSLServerSocketFactory.getDefault()返回的工厂只支持服务器端认证。它不支持加密。为了也能够加密，服务器端安全套接字要求更多的初始化和设置。具体的这些步骤如何执行是实现独立的。在Sun的参考实现中，一个com.sun.net.ssl.SSLContext对象负责创建完全配置和初始化的安全的服务器端套接字。这些细节在不同的JSSE实现中都不同，但是为了在参考实现中创建一个安全的服务器端套接字，你必须：
			1. 使用keytool来生成公钥和证书。
			2. 付钱使你的证书被第三方机构认证
			3. 为你将使用的算法创建一个SSLContext
			4. 为你将使用的证书资料的来源创建一个TrustManagerFactory
			5. 为你将使用的key资料的类型创建一个KeyManagerFactory
			6. 为key和证书数据库创建一个KeyStore对象（Oracle默认的是JKS）
			7. 使用key和证书来填充KeyStore对象，比如通过使用他们加密时的口令来从文件系统加载他们
			8. 使用KeyStore和它的口令来初始化KeyManagerFactory
			9. 初始化上下文，通过必须的，来自于KeyManagerFactory的key管理器，来自于TrustManagerFactory的信任管理器，以及一个随机值的来源。（如果你想要接受默认值，后面这两个可以为null）。
		下面的例子用一个完整的，用来接收订单，并将其打印到System.out的SecureOrderTaker来证明这个过程。
			Example 10-2. SecureOrderTaker
			import java.io.*;
			import java.net.*;
			import java.security.*;
			import java.security.cert.CertificateException;
			import java.util.Arrays;
			import javax.net.ssl.*;
			
			public class SecureOrderTaker {

				public final static int PORT = 7000;
				public final static String algorithm = "SSL";
				
				public static void main(String[] args) {
					try {
						SSLContext context = SSLContext.getInstance(algorithm);
						
						// The reference implementation only supports X.509 keys
						KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");
						
						// Oracle's default kind of key store
						KeyStore ks = KeyStore.getInstance("JKS");
						
						// For security, every key store is encrypted with a
						// passphrase that must be provided before we can load
						// it from disk. The passphrase is stored as a char[] array
						// so it can be wiped from memory quickly rather than
						// waiting for a garbage collector.
						char[] password = System.console().readPassword();
						ks.load(new FileInputStream("jnp4e.keys"), password);
						kmf.init(ks, password);
						context.init(kmf.getKeyManagers(), null, null);
						
						// wipe the password
						Arrays.fill(password, '0');
						
						SSLServerSocketFactory factory = context.getServerSocketFactory();
						SSLServerSocket server = (SSLServerSocket) factory.createServerSocket(PORT);

						// add anonymous (non-authenticated) cipher suites
						String[] supported = server.getSupportedCipherSuites();
						String[] anonCipherSuitesSupported = new String[supported.length];
						int numAnonCipherSuitesSupported = 0;
						for (int i = 0; i < supported.length; i++) {
							if (supported[i].indexOf("_anon_") > 0) {
								anonCipherSuitesSupported[numAnonCipherSuitesSupported++] = supported[i];
							}
						}
						
						String[] oldEnabled = server.getEnabledCipherSuites();
						String[] newEnabled = new String[oldEnabled.length + numAnonCipherSuitesSupported];
						System.arraycopy(oldEnabled, 0, newEnabled, 0, oldEnabled.length);
						System.arraycopy(anonCipherSuitesSupported, 0, newEnabled, oldEnabled.length, numAnonCipherSuitesSupported);

						server.setEnabledCipherSuites(newEnabled);
						
						// Now all the set up is complete and we can focus
						// on the actual communication.
						while (true) {
							// This socket will be secure,
							// but there's no indication of that in the code!
							try (Socket theConnection = server.accept()) {
								InputStream in = theConnection.getInputStream();
								int c;
								while ((c = in.read()) != -1) {
									System.out.write(c);
								}
							} catch (IOException ex) {
								ex.printStackTrace();
							}
						}
					} catch (IOException | KeyManagementException | KeyStoreException | NoSuchAlgorithmException | CertificateException | UnrecoverableKeyException ex) {
						ex.printStackTrace();
					}
				}
			}
		这个例子加载了需要的key和证书，从命名为jnp4e.keys的文件中，该文件位于当前工作目录，并且由密码“2andnotafnord”保护。这个例子没有给你展示如何创建这个文件，它有捆绑在JDK上的keytool程序创建，像这样：
			$ keytool -genkey -alias ourstore -keystore jnp4e.keys
			Enter keystore password:
			Re-enter new password:
			What is your first and last name?
				[Unknown]: Elliotte Harold
			What is the name of your organizational unit?
				[Unknown]: Me, Myself, and I
			What is the name of your organization?
				[Unknown]: Cafe au Lait
			What is the name of your City or Locality?
				[Unknown]: Brooklyn
			What is the name of your State or Province?
				[Unknown]: New York
			What is the two-letter country code for this unit?
				[Unknown]: NY
			Is <CN=Elliotte Harold, OU="Me, Myself, and I", O=Cafe au Lait, L=Brooklyn,
			ST=New York, C=NY> correct?
				[no]: y
			Enter key password for <ourstore>
				(RETURN if same as keystore password):
		当这个结束后，你就有一个命名为jnp4e.keys的文件，它包含你的公钥。然而，没有人相信这就是你的证书，除非他们被第三方受信任的机构认证。如果你想在决定是否要走一边这样麻烦的流程，并且花钱购买认证的证书，之前想要研究JSSE，Oracle包含了一个已经认证过的，名称为testkeys的keystore文件，由口令“passphrase,”保护。然而，这对于现实的工作不够好。
		另一个方法是使用那些不需要认证的加密套件。JDK中有很多，包括：
			• SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA
			• SSL_DH_anon_EXPORT_WITH_RC4_40_MD5
			• SSL_DH_anon_WITH_3DES_EDE_CBC_SHA
			• SSL_DH_anon_WITH_DES_CBC_SHA
			• SSL_DH_anon_WITH_RC4_128_MD5
			• TLS_DH_anon_WITH_AES_128_CBC_SHA
			• TLS_DH_anon_WITH_AES_128_CBC_SHA256
			• TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA
			• TLS_ECDH_anon_WITH_AES_128_CBC_SHA
			• TLS_ECDH_anon_WITH_NULL_SHA
			• TLS_ECDH_anon_WITH_RC4_128_SHA
		这些默认是不被允许的，因为他们易受man-in-the-middle攻击，至少它允许你不用付钱就可以编写简单的程序。
	配置SSLServerSocket
		一旦你成功创建并初始化了一个SSLServerSocket，只使用从java.net.ServerSocket继承来的方法就可以编写很多应用。然而，有时候你需要稍微调整下他们的行为。像SSLSocket, SSLServerSocket提供方法来选择安全套件，管理会话，以及客户端是否被需要认证他们自己。大多数这些方法都和SSLSocket中方法有相同的名字。不同的是，他们工作于服务器端，并且设置由SSLServerSocket接收的套接字的默认值。一些情况下，一旦一个SSLSocket被接受，你仍然可以使用SSLSocket的方法来配置那个套接字，而不是SSLServerSocket接收的所有套接字。
		选择安全套件
			SSLServerSocket有三个方法来决定哪些安全套件被支持，并且被允许，就像SSLSocket那样：
				public abstract String[] getSupportedCipherSuites()
				public abstract String[] getEnabledCipherSuites()
				public abstract void setEnabledCipherSuites(String[] suites)
			这些和SSLSocket中的相似命名的方法使用相同的套件名字。不同的是，这些方法应用于SSLServerSocket接收的所有套接字，而不是只是一个SSLSocket
。比如，下面的代码片段有允许匿名的，无认证的集合到SSLServerSocketserver的作用。它依赖于那些名字中包含anon字符串的套件。虽然没有保证其他实现也遵循这个约定，但这对于Oracle的参考实现是这样的：
				String[] supported = server.getSupportedCipherSuites();
				String[] anonCipherSuitesSupported = new String[supported.length];
				int numAnonCipherSuitesSupported = 0;
				for (int i = 0; i < supported.length; i++) {
					if (supported[i].indexOf("_anon_") > 0) {
						anonCipherSuitesSupported[numAnonCipherSuitesSupported++] = supported[i];
					}
				}
				
				String[] oldEnabled = server.getEnabledCipherSuites();
				String[] newEnabled = new String[oldEnabled.length + numAnonCipherSuitesSupported];
				System.arraycopy(oldEnabled, 0, newEnabled, 0, oldEnabled.length);
				System.arraycopy(anonCipherSuitesSupported, 0, newEnabled, oldEnabled.length, numAnonCipherSuitesSupported);

				server.setEnabledCipherSuites(newEnabled);
			这个片段通过getSupportedCipherSuites()和getEnabledCipherSuites()，同时获取支持的和允许的安全套件列表。它查看每个支持的套件的名字是否包含字串“anon.”。如果套件名字确实包含字串，这个套件被添加到匿名安全套件列表中。一旦匿名安全套件列表被建立，它在一个新的数组中和前面的允许的安全套件列表合并。这个新的数组然后传递给setEnabledCipherSuites()，以使以前被允许的和匿名的安全套件现在可以被使用。
		会话管理
			客户端和服务器端必须同时就建立会话达成一致。服务器端使用setEnableSessionCreation()来决定这个是否被允许，使用getEnableSessionCreation()来查看这个当前是否被允许。
				public abstract void setEnableSessionCreation(boolean allowSessions)
				public abstract boolean getEnableSessionCreation()
			会话创建默认被允许。如果服务器端不允许会话创建，想要一个会话的客户端仍然可以连接。只是，它将不能获得一个会话，并且必须为每一个套接字进行握手。相似的，如果客户端拒绝会话，但是服务器端允许他们，他们仍然可以相互通信，但是没有会话。
		客户端模式
			SSLServerSocket类有两个方法来查看和指明，客户端套接字是否被需要向服务器端认证他们自己。通过传递true到setNeedClientAuth()方法，你指明只有可以自我认证的客户端连接才可以被接受。通过传递false，你指明客户端不需要自我认证。默认是false。如果，出于某些原因，你需要知道这个属性的当前状态，getNeedClientAuth()方法会告诉你：
				public abstract void setNeedClientAuth(boolean flag)
				public abstract boolean getNeedClientAuth()
			setUseClientMode()方法允许程序指明，即使它创建的是一个SSLServerSocket，在关于认证和其他协商的通信上，它就是并且应该被当作客户端。如果SSLServerSocket处于客户端模式，getUseClientMode()方法将返回true，否则返回false。
				public abstract void setUseClientMode(boolean flag)
				public abstract boolean getUseClientMode()
			

第十一章 非阻塞I/O
	和CPU，内存或即使是磁盘，网络都是慢的。一个高端的现代PC可以以6G/s的速度在CPU和主存之间传递数据。它和磁盘传递数据稍微慢些，但仍可以达到150M/s。相比之下，现在最快的本地网络的理论上的最大值大约是150M/s，虽然很多只支持比那个慢10倍或百倍的速度。并且通过公共互联网的速度要比本地局域网的速度慢至少几个数量级。我的比平均值较快的FIOS连接承诺3M/s到6M/s，大约是我的局域网能够支持的5%。CPU，硬盘和网络都随着时间不断加快。不管怎样，在可预见的将来，CPU和磁盘将比网络快很多数量级。在这样的环境中，你想要做的最后一件事情就是让速度较快的CPU等待速度较慢的网络。
	java原始的用来允许CPU和网络协同工作的解决方案是，缓冲区和多线程相结合。多线程可以一次为多个不同的连接生成数据，并且将数据存储到缓冲区中，直到网络确实准备好发送它。这个方法在相对简单的，没有极度性能要求的客户端和服务器端中可以很好的工作。然而，包裹多线程，并且在他们之间进行切换的工作量不小。比如，每个线程要求大约1M的RAM。在一个大的服务器上，可能每秒处理数千个请求，你可能不想为每个连接都分配一个线程。如果一个线程可以负责多个连接将会更快，从准备好接受数据的里边选择一个，尽快的，以那个连接可以管理的，尽可能多的数据来填充它，然后移动到下一个准备好的连接。
	为了工作的很好，这个方法需要底层操作系统的支持。几乎所有的，你可能想要用于大规模服务器的现代操作系统都支持这样的非阻塞I/O。然而，在一些网络客户端系统，比如平板，手机等等这些，上可能支持的不是很好。确实，java.nio提供的这些支持不是J2ME特性的当前或计划的一部分，虽然它可以在Android中被找到。然而，一个为服务器端，并且只关注服务器端的全新的I/O被设计，这就是为什么我只是略微提及，而没有做更多，直到我们开始谈论服务器端。客户端以及点对点的系统很少需要处理如此多的同时的连接，此时多线程，基于流的I/O成为一个明显的瓶颈。
	NIO太小，太迟？
		当恰当架构的非阻塞I/O明显胜过多线程，多进程的设计有一段时间。那段时间是1990年。不幸的是，java没有引入非阻塞I/O，直到2002年的java
1.4。到java 5释出的2004年，以及很确定的java 6释出的2006年，操作系统本地线程的持续改进，消除了基本所有的上下文切换，非竞争同步的开销。更进一步，服务器内存已经增长到10000个并发线程可以很容易的放到商用硬件的内存中，并且多核心/多CPU系统要求使用多线程来最大化他们的利用率变得平常。在今天的java 7和java 8 64位虚拟机上更是这样。到2013年，确实很难判定基于NIO的架构相比于很简单的线程/请求或线程/连接的设计，所增加的复杂性。
		在Linux java 6上的实际的测试中，多线程的经典I/O设计要比NIO快30%。
		有什么情况下，异步I/O可以打败经典I/O吗？可能。我仍然可以想象的一个场景是，大量的，长生命周期的，同时的连接，比如10000+，但是每个客户端不会很频繁的发送很多数据。比如，假设在内政部有一个中心计算机，收集全国连锁的便利店的收银机的每一笔交易。这个情景是为NIO特制的，可能可以在很少的线程中，被异步或非阻塞实时的处理，会更有效。
		但是，经常记住优化的两个黄金法则：
			1。不要优化
			2。只有在你已经很清楚，并且有清楚的测量证明确实有问题后才优化，并且很清楚的证明你的改变会解决这个问题。
	一个客户端的例子
		虽然新的I/O API不是特别为客户端设计的，但它确实对它们有用。我将以一个使用新的I/O API的客户端程序开始，因为它很简单。特别是，很多客户端可以被实现为一次有一个连接，因此我可以在讨论选择器和非阻塞I/O之前，介绍通道和缓冲区。
		定义在RFC 864中的字符生成协议的简单的客户端将证明这些基本概念。这个协议被设计用来测试客户端。服务器端在19端口上监听连接。当客户端连接时，服务器端发送一个持续的字符序列，直到客户端断开连接。任何客户端的输入都被忽略。RFC没有指明哪些字符序列会被发送，但是建议服务器端使用一个可辨认的模式。一个通常的模式是循环95个可打印的ASCII字符，每次72个字符，加回车/换行来截断行。像这样：
			!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefgh
			"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghi
			#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghij
			$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijk
			%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijkl
			&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklm
		我在这章中选择这个协议作为例子的原因是，不管是数据传输还是数据生成的算法都很简单，他们不会掩盖I/O。然而，字符生成可以在一个相对较少的连接上传输大量的数据，并且很快会使网络饱和。因此它是新I/O API的一个很好的候选。
		现在，Chargen已经不经常被使用了，可能会被本地防火墙阻塞，即使被打开。它很容易受到拒绝服务的攻击，欺骗的网络数据报导致两个主机各自喷涌出不受限制的大量的数据。更进一步，它基本上是无限不对称的，对于很小的客户端请求，服务器端发送一个不受限制的大量的数据作为响应。很容易使用很少的被害的主机，更不用说一个僵尸网络，来说服一个Chargen服务器，来使本地网络饱和。
		当实现一个使用新的I/O API的客户端时，起始于调用静态的工厂方法SocketChannel.open()来创建一个新的java.nio.channels.SocketChannel对象，这个方法的参数是一个包含要连接到的主机和端口的java.net.SocketAddress对象。比如，这个代码片断连接通道到rama.poly.edu的19端口：
			SocketAddress rama = new InetSocketAddress("rama.poly.edu", 19);
			SocketChannel client = SocketChannel.open(rama)；
		通道以阻塞模式被打开，所以代码的下一行不会被执行，直到连接被建立。如果连接不能被建立，IOException异常会被抛出。
		如果这是一个传统的客户端，你现在将请求套接字的输入和输出流。当你使用通道时，你直接向通道自己写出。不是写出字节数组，而是写出ByteBuffer对象。你已经得到了一个很好的信息，那就是这行文本是74个ASCII字符的长度（72个可打印字符，外加回车和缓行符），所以你可以使用静态的allocate()方法来创建一个有74个字节容量的ByteBuffer：
			ByteBuffer buffer = ByteBuffer.allocate(74);
		将这个ByteBuffer对象传递给通道的read()方法。通道使用它从套接字读取的数据来填充缓冲区。它返回它成功读取，并且存储在缓存区中的字节的数量：
			int bytesRead = client.read(buffer);	
		默认的，这个将至少读取一个字节或返回-1来表明数据的结尾，就像InputStream那样。如果有更多的字节可用于读取，它将读取更多的字节。简短的，你将看到如何将客户端变为非阻塞模式，那时，如果没有字节可用，它将立即返回0，但是目前这段代码仅仅像InputStream那样阻塞。就像你可能猜想的那样，这个方法也能抛出一个IOException，当读取时发生任何问题。
		假设有很多数据在缓冲区中，也就是说n>0，这些数据可以被拷贝到System.out。有很多方法可以从一个ByteBuffer中抽取一个字节数组，它然后可以被写出到一个传统的OutputStream，比如，System.out。然而，坚持用以个纯的，基于通道的解决方法，要更有益。这样一个解决方法要求包装OutputStream System.out到一个通道中，使用Channels实用类，特别是它的newChannel()方法：
			WritableByteChannel output = Channels.newChannel(System.out);
		然后你就可以写出读取的数据到，这个连接到System.out的输出通道。然而，在你做那些之前，你需要flip缓冲区，以使输出通道从读取数据的开头开始，而不是结尾：
			buffer.flip();
			output.write(buffer);
		你不需要告诉输出通道有多少字节要写出。缓冲区会跟踪它包含多少字节。然而，通常，输出通道不会保证写出所有缓冲区中的字节。在这种特殊情况下，它是一个阻塞的通道，并且它或者这么做，或者抛出一个IOException。
		你不能为每次读和写创建一个新的缓冲区。那将会损害性能。相替代的，重用已有的缓冲区。你将需要清空缓冲区，在再次向它里边读取数据之前：
			buffer.clear();
		这个和flip有一些不同。flip将数据保持在缓冲区中，准备它用于写出，而不是用于读取。清空重置缓冲区到一个原始的状态。（事实上那很简单。旧的数据仍然存在，它没有被覆盖，但是它将被从来源读取的新数据立即覆盖）。
		将这些放进一个完整的客户端就是下面这样：
			try {
				SocketAddress address = new InetSocketAddress(args[0], port);
				SocketChannel client = SocketChannel.open(address);
				
				ByteBuffer buffer = ByteBuffer.allocate(74);
				
				WritableByteChannel out = Channels.newChannel(System.out);
				
				while (client.read(buffer) != -1) {
					buffer.flip();
					out.write(buffer);
					buffer.clear();
				}
			} catch (IOException ex) {
				ex.printStackTrace();
			}
		到目前为止，这仅仅是使用流很容易的编写的一个替代版本的程序。如果你想要客户端做一些除了拷贝所有输入到输出之外的其他事情，真正的新功能就会被引进。你可以运行这个连接，或者在阻塞模式，或者在非阻塞模式，此时，即使没有数据可用，read()也会立即返回。这就允许程序在尝试读之前，做一些其他事情。没有必要等待较慢的网络连接。为了改变阻塞模式，传递true（阻塞）或false（非阻塞）到configureBlocking()方法。让我们使这个连接非阻塞：
			client.configureBlocking(false);
		在非阻塞模式，read()将返回0，因为它没有读取到任何东西。因此，循环需要有一些不同：
			while (true) {
				// Put whatever code here you want to run every pass through the loop
				// whether anything is read or not
				int n = client.read(buffer);
				if (n > 0) {
					buffer.flip();
					out.write(buffer);
					buffer.clear();
				} else if (n == -1) {
					// This shouldn't happen unless the server is misbehaving.
					break;
				}
			}
		可能，你可以查看是否用户做了一些操作来取消输入，比如。然而，就像你将在下个部分看到的那样，当一个程序正在处理多个连接，这允许代码在快的连接上运行的很快，在慢的连接上运行的更慢。每个连接都以它自己的速度运行，而不会被滞留在单线车道的较慢的设备后面。
	一个服务器端的例子
		客户端很好，但是通道和缓冲区确实是打算用于需要有效的处理大量的并发连接的服务器系统。处理服务器端，需要除了用于客户端的通道和缓冲区之外的第三层。特别的，你需要选择器，它允许服务器端找出所有准备好接受输出或发送输入的连接。
		为了证明基本概念，这个例子实现了一个简单的服务器端用于字符生成协议。当实现一个使用新的I/O API的服务器端时，通过调用静态工厂方法ServerSocketChannel.open()来创建一个新的ServerSocketChannel对象开始：
			ServerSocketChannel serverChannel = ServerSocketChannel.open();
		初始的，这个通道实际上并没有监听在任何端口。为了将它绑定到一个端口，通过socket()方法获取它的结伴对象ServerSocket，然后使用结伴对象上的bind()
方法。比如，这个代码片段绑定通道到一个监听在19号端口的服务器端套接字：
			ServerSocket ss = serverChannel.socket();
			ss.bind(new InetSocketAddress(19));
		在java 7及以后，你可以直接绑定，而不需要获取底层的java.net.ServerSocket：
			serverChannel.bind(new InetSocketAddress(19));
		就像常规的服务器端套接字，绑定到19端口要求你是Unix系统的root用户。非root用户只能绑定到1024及以上的端口。
		服务器端套接字通道现在在19端口上监听进来的连接。为了接收一个，调用accept()方法，它会返回一个SocketChannel对象：
			SocketChannel clientChannel = serverChannel.accept();
		在服务器端，你将肯定想要客户端通道非阻塞，来允许服务器端处理多个并发的连接：
			clientChannel.configureBlocking(false);
		你可能也想要使ServerSocketChannel非阻塞。默认的，这个accept()方法阻塞，直到有一个进来的连接，就像ServerSocket的accept()方法。为了改变这个，在调用accept()之前，简单的调用configureBlocking(false)：
			serverChannel.configureBlocking(false);
		如果没有进来的连接，非阻塞的accept()几乎立即返回null。确保检查它，否则你将得到一个令人不快的NullPointerException，当尝试使用套接字时。
		现在有两个打开的通道，一个服务器端通道，一个客户端通道。两个都需要被处理。更进一步，处理服务器端通道将创建更多的打开的客户端通道。在传统的方法中，你为每个连接分配一个线程，当客户端连接时，线程的数量迅速攀升。相替代的，在新的I/O API中，你创建一个Selector，它允许程序在准备好被处理的连接上进行迭代。为了构造一个新的Selector，只需要调用静态的Selector.open()工厂方法：
			Selector selector = Selector.open();
		接下来，你需要使用通道的register()方法来注册每一个通道到监视它的选择器上。当注册时，使用来自于SelectionKey类的命名常量来指明你感兴趣的操作。对于服务器端套接字，仅仅感兴趣的操作是OP_ACCEPT。它就是，服务器端套接字通道是否准备好接受一个新的连接：
			serverChannel.register(selector, SelectionKey.OP_ACCEPT);
		对于客户端通道，你想要知道一些不同的东西，特别是，他们是否准备好使数据写出到他们。为了这个，使用OP_WRITE建：
			SelectionKey key = clientChannel.register(selector, SelectionKey.OP_WRITE);
		两个register()方法都返回一个SelectionKey对象。然而，你将只需要使用客户端通道对应的那个key，因为可能有多个。每一个SelectionKey有一个附加的，任意的Object类型。这个通常用来持有一个对象，它表明连接当前的状态。在这种情况下，你可以存储通道用于写出到网络的缓冲区对象。一旦缓冲区被完全耗尽，你将重新填充它。使用数据填充将要被拷贝到各个缓冲区的数组。不是写出到缓冲区的结尾，然后绕回到缓冲区的开头，并且继续写出，从两个连续的数据拷贝开始，以使每一行都以一个数组中的一个连续的序列可用，会更容易：
			byte[] rotation = new byte[95*2];
			for (byte i = ' '; i <= '~'; i++) {
				rotation[i - ' '] = i;
				rotation[i + 95 - ' '] = i;
			}
		因为这个数组只有在被初始化之后，才会从它进行读取，你可以为多个通道重用它。然而，每个通道都将得到它自己的缓冲区，以这个数组中的内容填充。你将使用循环数组的前72个字节填充缓冲区，然后添加回车/换行对来截断行。然后，你将flip缓冲区，以使它准备好被耗尽，并且将它附加到通道的key上：
			ByteBuffer buffer = ByteBuffer.allocate(74);
			buffer.put(rotation, 0, 72);
			buffer.put((byte) '\r');
			buffer.put((byte) '\n');
			buffer.flip();
			key2.attach(buffer);
		为了检测是否有东西准备好被处理，调用选择器的select()方法。对于一个长期运行的服务器端，这个通常在一个无线的循环中进行：
			while (true) {
				selector.select ();
				// process selected keys...
			}
		假设选择器确实找到了一个准备好的通道，它的selectedKeys()方法返回一个java.util.Set，为每个准备好的通道包含一个SelectionKey。否则，它返回一个空的set。不管哪种情况，你可以使用一个java.util.Iterator来遍历它：
			Set<SelectionKey> readyKeys = selector.selectedKeys();
				Iterator iterator = readyKeys.iterator();
				while (iterator.hasNext()) {
					SelectionKey key = iterator.next();
					// Remove key from set so we don't process it twice
					iterator.remove();
					// operate on the channel...
			}
		将key从set中删除掉，就告诉Selector你已经处理过它，在你每次调用select()时，Selector不需要每次都将它返回。当你再次调用select()时，如果通道再次变得准备好，Selector将再次将通道加回到ready set中。从ready set中删除key确实很重要。
		如果准备好的通道是服务器端通道，程序接收一个新的套接字通道，并且将它注册到选择器。如果准备好的通道是一个套接字通道，程序写出尽可能多的数据到通道中。如果没有通道准备好，选择器会等待一个准备好。一个线程，主线程，处理多个并发的连接。
		在这种情况下，很容易得知一个客户端或服务器端通道是否已经被选择，因为服务器端通道将只会准备好来接收，客户端通道将只会准备好来写出。这两个都是I/O操作，两个都可以因为很多原因抛出IOException，所以你想要用try块包装它：
			try {
				if (key.isAcceptable()) {
					ServerSocketChannel server = (ServerSocketChannel) key.channel();
					SocketChannel connection = server.accept();
					connection.configureBlocking(false);
					connection.register(selector, SelectionKey.OP_WRITE);
					// set up the buffer for the client...
				} else if (key.isWritable()) {
					SocketChannel client = (SocketChannel) key.channel();
					// write data to client...
				}
			}
		将数据写出到通道上很简单。获得key的附件，将它转化为ByteBuffer，并且调用hasRemaining()来查看缓冲区中是否剩有任何未写出的数据。如果有，写出它。否则，使用循环数组中下一行的数据重新填充缓冲区，并写出。
			ByteBuffer buffer = (ByteBuffer) key.attachment();
			if (!buffer.hasRemaining()) {
				// Refill the buffer with the next line
				// Figure out where the last line started
				buffer.rewind();
				int first = buffer.get();
				// Increment to the next character
				buffer.rewind();
				int position = first - ' ' + 1;
				buffer.put(rotation, position, 72);
				buffer.put((byte) '\r');
				buffer.put((byte) '\n');
				buffer.flip();
			}
			client.write(buffer);
		这个算法依赖字符被以ASCII的顺序被存储在循环数组中的特点来找出从哪里获取下一行的数据。buffer.get()从缓冲区中获得第一个字节的数据。从这个数字减去空格字符（32），因为空格字符是循环数组的第一个字符。这就告诉你，缓冲区当前起始处在数组中的索引。通过增加1来找出下一行数据的开始出，并且填充缓冲区。
		在char生成协议中，服务器端从不关闭连接。它等待客户端销毁套接字。当这个发生时，一个异常将被抛出。取消key，并且关闭相应的通道。
			catch (IOException ex) {
				key.cancel();
				try {
					key.channel().close();
				} catch (IOException cex) {
					// ignore
				}
			}
		将所有这些放进一个完整的char生成协议中，在一个单一线程中有效处理多个并发连接。
			ServerSocketChannel serverChannel;
			Selector selector;
			try {
				serverChannel = ServerSocketChannel.open();
				ServerSocket ss = serverChannel.socket();
				InetSocketAddress address = new InetSocketAddress(port);
				ss.bind(address);
				serverChannel.configureBlocking(false);
				selector = Selector.open();
				serverChannel.register(selector, SelectionKey.OP_ACCEPT);
			} catch (IOException ex) {
				ex.printStackTrace();
				return;
			}
			
			while (true) {
				try {
					selector.select();
				} catch (IOException ex) {
					ex.printStackTrace();
					break;
				}

				Set<SelectionKey> readyKeys = selector.selectedKeys();
				Iterator<SelectionKey> iterator = readyKeys.iterator();
				while (iterator.hasNext()) {
				
					SelectionKey key = iterator.next();
					iterator.remove();
					try {
						if (key.isAcceptable()) {
							ServerSocketChannel server = (ServerSocketChannel) key.channel();
							SocketChannel client = server.accept();
							System.out.println("Accepted connection from " + client);
							client.configureBlocking(false);
							SelectionKey key2 = client.register(selector, SelectionKey.OP_WRITE);
							ByteBuffer buffer = ByteBuffer.allocate(74);
							buffer.put(rotation, 0, 72);
							buffer.put((byte) '\r');
							buffer.put((byte) '\n');
							buffer.flip();
							key2.attach(buffer);
						} else if (key.isWritable()) {
							SocketChannel client = (SocketChannel) key.channel();
							ByteBuffer buffer = (ByteBuffer) key.attachment();
							if (!buffer.hasRemaining()) {
								// Refill the buffer with the next line
								buffer.rewind();
								// Get the old first character
								int first = buffer.get();
								// Get ready to change the data in the buffer
								buffer.rewind();
								// Find the new first characters position in rotation
								int position = first - ' ' + 1;
								// copy the data from rotation into the buffer
								buffer.put(rotation, position, 72);
								// Store a line break at the end of the buffer
								buffer.put((byte) '\r');
								buffer.put((byte) '\n');
								// Prepare the buffer for writing
								buffer.flip();
							}
							client.write(buffer);
						}
					} catch (IOException ex) {
						key.cancel();
						try {
							key.channel().close();
						}
						catch (IOException cex) {}
					}
				}
			}
		这个例子只使用了一个线程。在很多情况下，你可能想要使用多个线程，特别是如果不同的操作有不同的优先级。比如，你可能想要接收新的连接在一个高优先级的线程中，服务已经存在的连接在一个低优先级的线程中。然而，你不再需要线程和连接是1：1的比例，这就提高了java编写的服务器端的可扩展性。
		使用多线程为了得到最大性能也很重要。多线程允许服务器使用多CPU。即使只有单一CPU，将接受线程和处理线程分开通常也是一个好主意。第三章讨论的线程池仍然相关，即使使用新的I/O模型。接收连接的线程可以将接收到的线程放到池中线程的处理队列中。这比不使用选择器来做相同的事情要快，因为select()允许你绝不会浪费时间在还没有准备好接收数据的连接上。另一方面，同步问题很棘手，所以不要尝试这个，直到性能分析证明这是一个瓶颈。
	缓冲区
		在第二章中，我建议你总是缓冲你的流。几乎没有什么能比一个足够大的缓冲区更能影响网络程序的性能。在新的I/O模型中，你不再需要作出选择。所有的I/O都是被缓冲的。确实，缓冲区是这部分API的基础。相替代的写出数据到输出流和从输入流读取数据，你从缓冲区来读取或写出数据。缓冲区可能看起来就像一个缓冲的流中的一个字节数组。然而，本地实现可以直接将他们连接到硬件，或内存，或使用其他的，很有效的实现。
		从编程的角度，流和通道的主要区别是流是基于字节的，而通道是基于块的。流被用来设计成按顺序提供字节。为了性能，可以传递字节数组。然而，基本的概念是一次传递一个字节。相比之下，通道按块分发数据到缓冲区。在数据能从通道读取或向通道写出之前，字节必须被存储在缓冲区中，并且数据被读取或写出都是以一次一个缓冲区的规模进行。	
		第二个流和缓冲区的不同之处是通道和缓冲区倾向于在同一个对象上同时支持读取和写出。这并不总是真的。比如，一个指向CD-ROM上的文件的通道，将只能读不能写。连接到已经关闭输入的套接字的通道将只能写，不能读。如果你尝试写出到一个只读的通道，或从一个只写的通道读取，一个UnsupportedOperationException将会被抛出。然而，多半网络程序可以从相同的通道进行读取和写出。
		关于底层的细节，不需要担心的太多（不同的实现之间的差别会很大，大多数时候都会和主机操作系统和硬件调整的很接近），你可以将缓冲区想成固定大小的，特定元素的列表，通常是私有数据类型，像一个数组。然而，幕后并不必然是一个数组。有时候是，有时候不是。除了boolean类型，对于所有java的私有数据类型，都有一个对应的Buffer的特定的子类：Byte Buffer, CharBuffer, ShortBuffer, IntBuffer, LongBuffer, FloatBuffer, 和Double Buffer。每个子类中的方法都有恰当类型的返回值和参数列表。比如，DoubleBuffer类有存放和获取double值的方法。IntBuffer类有存放和获取int值的方法。公共的超类Buffer只提供不需要知道缓冲区中包含数据的类型的方法。网络程序几乎总是排它性的使用ByteBuffer，虽然，偶尔有程序会使用覆盖在ByteBuffer上的其他类型的一个试图。
		除了它的数据列表，每个缓冲区跟踪4个关键的信息。所有的缓冲区都有相同的方法来设置和获得这些值，不管缓冲区的类型：
			position
				缓冲区中将要被读取或写出的下一个地址。这个从0开始计数，有一个和缓冲区大小相同的最大值。它可以使用这两个方法来设置和获取：
					public final int position()
					public final Buffer position(int newPosition)
			capacity
				缓冲区能持有的最大元素的数量，这个在缓冲区创建时设置，并且在那之后不能再改变。它可以使用这个方法来读取：
					public final int capacity()
			limit
				缓冲区中可访问数据的结尾。在不该变limit的前提下，你不能在这个点，或超过这个点进行读取和写出，即使缓冲区还有更多的容量。它使用这些方法来设置和获取：
					public final int limit()
					public final Buffer limit(int newLimit)
			mark
				缓冲区中一个客户指定的索引。通过调用mark()设置在当前的位置。通过调用reset()，当前的位置被设置为被标记的位置：
					public final Buffer mark()
					public final Buffer reset()
		如果position被设置为低于一个已经存在的标记，标记就被丢弃。
		不像从InputStream进行读取,从缓冲区了进行读取实际上不会以任何形式改变缓冲区中的数据.可以向前或向后设置position的值，以使你可以从缓冲区的特定位置开始读取。相似的，程序可以通过调整limit来控制程序将要读取数据的结尾。只有capacity是固定的。
		公共的超类Buffer也提供了一些方法，来通过引用这些公共的属性来进行一些操作。
		clear()方法通过将position设为0，limit的值设为capacity来“清空”缓冲区，这个允许完全重新填充缓冲区：
			public final Buffer clear()
		然而，clear()并没有将数据从缓冲区中删除，他们仍在那，并且可以通过绝对的获取方法或再次改变position的值来读取。
		rewind()将position的值设为0，但并不改变limit的值：
			public final Buffer rewind()
		这个允许缓冲区被重新读取。
		flip()将limit的值设为当前的position，将position的值设为0：
			public final Buffer flip()
		当你想要消耗一个你刚刚填充的缓冲区时，它将被调用。
		最后，有两个方法返回关于缓冲区的信息，但是并不会改变它。remaining()方法返回缓冲区中position和limit之间的元素的个数。hasRemaining()将返回true，如果剩下的元素数大于0：
			public final int remaining()
			public final boolean hasRemaining()
		创建缓冲区
			缓冲区类的层级结构是基于继承的，但是多态上却不是，至少在上层不是。你通常需要知道你是否在处理一个IntBuffer，或一个ByteBuffer，或一个CharBuffer，或其他东西。你针对这些子类编写代码，而不是针对公共的Buffer超类。
			每个类型化的缓冲区都有一些工厂方法，他们通过不同的方法创建特定实现的子类。空的缓冲区通常通过allocate方法创建。预先有数据填充的缓冲区通过wrap方法来创建。allocate方法通常对输入很有用，wrap方法通常对输出很有用。
			Allocation
				基本的allocate()方法简单的返回一个capacity固定的，新的，空的缓冲区。比如，这些行创建字节和整数缓冲区，他们的大小都是100：
					ByteBuffer buffer1 = ByteBuffer.allocate(100);
					IntBuffer buffer2 = IntBuffer.allocate(100);
				指针被定位在缓冲区的起始处（position是0）。一个由allocate()创建的缓冲区，将会被在java数组上实现，java数组可以通过array()和arrayOffset()方法来访问。比如，你可以使用通道来读取一大块的数据到缓冲区中，然后从缓冲区中得到数组，传递给其他方法：
					byte[] data1 = buffer1.array();
					int[] data2 = buffer2.array();
				array()方法暴露缓冲区的私有数据，所以使用它时要小心。对底层数组的改变将会反映在缓冲区上，反之亦然。通常的模式是使用数据填充缓冲区，获得它的底层数组，然后在数组上进行操作。只有当你开始在数组上工作之后，你不再向缓冲区写出，这就不会有问题。
			Direct allocation
				ByteBuffer类（其他缓冲区类不是），有一个附加的allocateDirect()方法，将不会为缓冲区创建一个底层的数组。VM将通过使用到一个以太网卡，核心内存，或其他类似设备的缓冲区的直接内存访问，来实现一个直接分配的ByteBuffer。它不被要求，但是是允许的，这样可以改进I/O操作的性能。从API的角度，allocateDirect()完全像allocate()一样被使用：
					ByteBuffer buffer = ByteBuffer.allocateDirect(100);
				在一个直接缓冲区上调用array()和arrayOffset()，将抛出一个UnsupportedOperationException。直接缓冲区在一些虚拟机上可能会更快，特别是当缓冲区很大时（1M或更大）。然而，直接缓冲区创建的代价要比非直接缓冲区创建的代价要昂贵，所以他们只有在缓冲区被期待保留一段时间时，才应该被分配。细节和VM的依赖度很高。就像对大多数性能建议都是真的一样，你可能不应该考虑使用直接缓冲区，除非测试证明性能确实是一个问题。
			Wrapping
				如果你已经有了一个数组的数据想要输出，你通常可以用一个缓冲区包裹它，而不是分配一个新的缓冲区，并且一次拷贝它的组件到缓冲区中，比如：
					byte[] data = "Some data".getBytes("UTF-8");
					ByteBuffer buffer1 = ByteBuffer.wrap(data);
					char[] text = "Some text".toCharArray();
					CharBuffer buffer2 = CharBuffer.wrap(text);
				这里，缓冲区包含一个到数组的引用，作为它的后台数组来服务。通过包裹来创建的缓冲区永远不是直接的。再次，对数组的修改会反映到缓冲区上，反之依然，所以不要包裹数组，直到你已经完成了它。
		填充和消耗
			缓冲区被设计用于顺序访问。每个缓冲区都有一个可通过position()获得的当前的位置，它介于0和缓冲区的元素个数之间，包含缓冲区中的元素个数。缓冲区的位置增加1，当一个元素被从它里边读取或被写入到缓冲区。比如，你分配了一个capacity为12的CharBuffer，并且通过向他放入5个字符来填充它：
				CharBuffer buffer = CharBuffer.allocate(12);
				buffer.put('H');
				buffer.put('e');
				buffer.put('l');
				buffer.put('l');
				buffer.put('o');
			缓冲区的position现在是5.这叫做填充缓冲区。
			你只能填充缓冲区到它的容量。如果你尝试填充它超过它的初始capacity，put()方法将抛出一个BufferOverflowException。
			如果你现在尝试着从缓冲区读取，你将得到null，java使用它来初始化char缓冲区。在你可以读取数据之前，你需要flip缓冲区：
				buffer.flip();
			这个将设置limit为position（这里是5），并且设置position为0.缓冲区的起点。现在你可以消耗它到一个字符串：
				String result = "";
				while (buffer.hasRemaining()) {
					result += buffer.get();
				}
			每次调用get()，将position向前移动一个。当position到达limit，hasRemaining()返回false。这被叫做消耗缓冲区
			Buffer类也有绝对的方法来在缓冲区的指定的位置进行填充和消耗，而不会更新position。比如，ByteBuffer有两个：
				public abstract byte get(int index)
				public abstract ByteBuffer put(int index, byte b)
			这两个方法都会抛出IndexOutOfBoundsException，如果你尝试访问在limit的位置或超过limit的位置。比如，通过使用绝对的方法，你可以像这样将相同的数据放进缓冲区：
				CharBuffer buffer = CharBuffer.allocate(12);
				buffer.put(0, 'H');
				buffer.put(1, 'e');
				buffer.put(2, 'l');
				buffer.put(3, 'l');
				buffer.put(4, 'o');
			然而，在读出之前，你不再需要flip，因为绝对方法不会改变position。更进一步，顺序也不再重要。这个会生成相同的最终结果：
				CharBuffer buffer = CharBuffer.allocate(12);
				buffer.put(1, 'e');
				buffer.put(4, 'o');
				buffer.put(0, 'H');
				buffer.put(3, 'l');
				buffer.put(2, 'l');
		大块的方法
			即使是对于缓冲区，成块的处理数据通常要比一次填充并消耗一个元素要快。不同的缓冲区类有按数组来填充和消耗他们元素类型的块方法。
			比如，ByteBuffer有用来从一个已经存在的字节数组或字数组，来填充或消耗ByteBuffer的put()和get()方法：
				public ByteBuffer get(byte[] dst, int offset, int length)
				public ByteBuffer get(byte[] dst)
				public ByteBuffer put(byte[] array, int offset, int length)
				public ByteBuffer put(byte[] array)
                        这些插入方法从指定的数组或子数组插入数据，从当前position开始。读取方法将数据读取进参数数组或子数组中，从当前position开始。put和get都以数组或字数组的长度来增加position值。如果缓冲区没有足够的空间来存放数组或子数组，put方法将抛出一个BufferOverflowException。如果缓冲区没有足够剩余的数据来填充数组或字数组，get方法将抛出一个BufferUnderflowException。这些都是运行时异常。
		数据转化
			java中的所有数据最后都被解析成字节。任何私有数据类型，int, double, float等等，能被以字节的形式写出。正确长度的任意字节序列都可以被解释称为一个原始资料。比如，4个字节的任何序列都对应一个int或float（事实上两个都可以，依赖于你想要怎么读取它）。8个字节的序列对应于一个long或double。ByteBuffer类（并且只有ByteBuffer）类，提供了相对和绝对的put方法，使用原始类型参数（除了boolean）对应的字节序列来填充缓冲区，以及相对和绝对的get方法，读取恰当数量的字节来生成一个原始资料。
				public abstract char getChar()
				public abstract ByteBuffer putChar(char value)
				public abstract char getChar(int index)
				public abstract ByteBuffer putChar(int index, char value)
				public abstract short getShort()
				public abstract ByteBuffer putShort(short value)
				public abstract short getShort(int index)
				public abstract ByteBuffer putShort(int index, short value)
				public abstract int getInt() 
				public abstract ByteBuffer putInt(int value)
				public abstract int getInt(int index)
				public abstract ByteBuffer putInt(int index, int value)
				public abstract long getLong()
				public abstract ByteBuffer putLong(long value)
				public abstract long getLong(int index)
				public abstract ByteBuffer putLong(int index, long value)
				public abstract float getFloat()
				public abstract ByteBuffer putFloat(float value)
				public abstract float getFloat(int index)
				public abstract ByteBuffer putFloat(int index, float value)
				public abstract double getDouble()
				public abstract ByteBuffer putDouble(double value)
				public abstract double getDouble(int index)
				public abstract ByteBuffer putDouble(int index, double value)
			在新I/O的世界中，这些方法做的工作和传统I/O中DataOutputStream和DataInputStream做的工作类似。这些方法也含有一些额外的，DataOutputStream和DataInputStream没有的功能。你可以选择将字节序列解释成为big-endian或little-endian的ints, floats, doubles，等等。默认的，所有的值都以big endian的形式被读取或写出（最高字节在前面）。这两个order()方法使用ByteOrder类中的命名常量来检测和设置缓冲区的字节顺序。比如，你可以像这样，改变缓冲区用little-endian的方式来解释：
				if(buffer.order().equals(ByteOrder.BIG_ENDIAN)) {
					buffer.order(ByteOrder.LITTLE_ENDIAN);
				}
		试图缓冲区
			如果你知道从SocketChannel读取的ByteBuffer，除了某一特定类型的原始数据类型之外，不包含其他任何东西，它就值得创建一个试图缓冲区。这是一个特定类型的新的Buffer对象（比如，DoubleBuffer, IntBuffer，等等），它从底层ByteBuffer的当前position开始提取它的数据。对试图缓冲区的修改会反映到底层缓冲区，反之亦然。然而，每个缓冲区都有它自己独立的limit, capacity, mark和position。试图缓冲区由ByteBuffer中的这6个方法中的一个来创建：
				public abstract ShortBuffer asShortBuffer()
				public abstract CharBuffer asCharBuffer()
				public abstract IntBuffer asIntBuffer()
				public abstract LongBuffer asLongBuffer()
				public abstract FloatBuffer asFloatBuffer()
				public abstract DoubleBuffer asDoubleBuffer()
			SocketChannel类只有读取和写出ByteBuffer的方法，它不能读取和写出其他类型的缓冲区。
		压缩缓冲区
			大多数可写的缓冲区支持一个compact()方法：
				public abstract ByteBuffer compact()
				public abstract IntBuffer compact()
				public abstract ShortBuffer compact()
				public abstract FloatBuffer compact()
				public abstract CharBuffer compact()
				public abstract DoubleBuffer compact()
			如果不是为了串联，这6个方法都可以被公共超类Buffer中的一个方法替代。压缩将缓冲区中剩余的数据移动到缓冲区的开头，为元素空出更多的空间。在这个位置上的任何数据都将被重写。缓冲区的position被设置为数据的结尾，以使可以写入更多的数据。
			压缩是特别有用的操作，当你进行拷贝时，从一个通道读取数据，并且使用非阻塞I/O写出数据到另一个。你可以读取一些数据到缓冲区中，然后再次从缓冲区写出，然后压缩数据，以使所有还没被写出的数据都在缓冲区的开头，position在缓冲区中剩余数据的结尾，准备好接受更多的数据。这就允许在只有一个缓冲区时，读和写可以或多或少的随机的被穿插。这就允许多个读连续发生，或多个写一个接一个。如果网络准备好立即写出，但是没有输入（或相反），程序可以利用这个。
			我在编写和调试程序时注意到一个事情，缓冲区会导致很大的不同。一个大的缓冲区可以隐藏很多bug。如果缓冲区足够大，可以持有所有的测试情况，而不需要被flip或drain。很容易没有注意到缓冲区没有被flip或compact在正确的时候，因为测试case实际上从不需要那样做。在交接你的程序之前，尝试着将缓冲区的大小调小到比你期望的输入更小。这样测试会降低性能，所以你不能用如此荒谬的小的缓冲区去交接，但是你绝对需要在小的缓冲区的情况下测试你的程序，来确保当缓冲区被填充满时，它有恰当的行为。
		复制缓冲区
			通常很想要将缓冲区拷贝一份，来传送相同的信息到两个或多个通道。6个类型化的缓冲区类中都有一个duplicate()方法来做这个：
				public abstract ByteBuffer duplicate()
				public abstract IntBuffer duplicate()
				public abstract ShortBuffer duplicate()
				public abstract FloatBuffer duplicate()
				public abstract CharBuffer duplicate()
				public abstract DoubleBuffer duplicate()
			返回值不是克隆。复制的缓冲区共享相同的数据，包括相同的底层数组，如果缓冲区是直接的。在一个缓冲区中更改数据，会反映在另一个缓冲区中。因此，当你只准备从缓冲区中读取数据时，你应该很想要使用这个方法。否则，跟踪数据从哪里被修改很棘手。
			原始的和拷贝的缓冲区有独立的mark，limit和position，即使他们共享相同的数据。一个缓冲区可以在另一个缓冲区的前面或后面。
			当你想要传输相同的数据到多个通道上时，复制会很有用。你可以为每个通道复制一次主要缓冲区，并且允许每个缓冲区以它自己的速度运行。比如，单个文件的HTTP服务器，使用通道和缓冲区重新实现，进行服务的单个文件被存储在一个常量的，只读的缓冲区中。没当一个客户连接时，程序为那个通道复制一份这个缓冲区，被作为通道的附件保存。如果没有复制，一个客户端需要等待另一个完成，以使原始的缓冲区可以rewind。复制允许同时的缓冲区重用。                                    
		剪接缓冲区
			剪接缓冲区是复制的一个轻微的变种。剪接也创建了一个和旧缓冲区共享数据的新的缓冲区。然而，剪接缓冲区的0位置，是原始缓冲区的当前位置，并且它的capacity只是到原始缓冲区的limit。也就是说，剪接缓冲区是原始缓冲区的一个子序列，它只包含原始缓冲区从当前位置到limit位置之间的元素。rewind剪接缓冲区只是将指针移动会剪切缓冲区被创建时，原始缓冲区的当前位置。剪切缓冲区不能看到原始缓冲区那个点之前的任何数据。再一次，在6个有类型的缓冲区类中，都有单独的slice()方法：
				public abstract ByteBuffer slice()
				public abstract IntBuffer slice()
				public abstract ShortBuffer slice()
				public abstract FloatBuffer slice()
				public abstract CharBuffer slice()
				public abstract DoubleBuffer slice()
			这很有用，当你有一个长的缓冲区的数据，并且它很容易被切分成多份，比如一个协议的头和紧跟着的数据部分。你可以读出头，然后剪切缓冲区，并且传递只包含数据部分的新的缓冲区到一个单独的方法或类。
		标记和重置
			就像输入流，缓冲区可以被标记和重置，如果你想要重新读取某些数据。不像输入流，这个在所有缓冲区上都可以进行，而不只是他们中的一些。相关的方法只在超类Buffer中定义一次，并且被所有不同类型的子类继承：
				public final Buffer mark()
				public final Buffer reset()
			reset()方法抛出一个InvalidMarkException，一个运行时异常，如果mark没有被设置。当Position被设置为当前mark点之前的位置时，markt被取消设置。
		Object方法
			缓冲区类都提供了通常的equals(), hashCode(), 和toString()。他们也实现了Comparable接口，因此也提供compareTo()方法。然而，缓冲区是不可Serializable或Cloneable。
			两个缓冲区被认为相等，如果：
				1. 他们有相同的类型（比如，ByteBuffer从不和IntBuffer相同，但是可以和另一个ByteBuffer相等）。    
				2. 他们缓冲区中剩余的元素的数量相同
				3. 相同相对位置上的剩余元素彼此相同
			注意，相等不考虑缓冲区当前位置之前的元素，缓冲区的capacity，limit或mark。比如，这个代码片段打印true，即使第一个缓冲区是第二个缓冲区的2倍大：
				CharBuffer buffer1 =
				CharBuffer.wrap("12345678");
				CharBuffer buffer2 = CharBuffer.wrap("5678");
				buffer1.get();
				buffer1.get();
				buffer1.get();
				buffer1.get();
				System.out.println(buffer1.equals(buffer2));
			hashCode()方法被实现为和相等相同的约定。那就是，两个相等的缓冲区将有相等的hashcode，两个不相等的缓冲区几乎不可能有相同的hashcode。然而，缓冲区的hashcode在每次有添加到或从缓冲区删除之后都会改变，使用缓冲区作为hash表的key不好。
			比较被实现为比较每个缓冲区中剩余的元素，一个接一个。如果所有相应的元素都相同，缓冲区就相同。否则，结果就是第一个比较不相同的元素的比较结果。如果一个缓冲区在不像同元素被找到之前被耗尽，而另一缓冲区还有元素，那么较短的缓冲区被认为比较长的缓冲区小。
			toString()方法返回看起来像这样的字符串：
				java.nio.HeapByteBuffer[pos=0 lim=62 cap=62]
			这个主要对调试有用。CharBuffer是例外，它返回一个包含缓冲区中剩余字符的字符串。
	通道
		通道移动成块的数据进入到缓冲区，并且输出到不同的I/O源，或者从缓冲区成块的移出从不同输入源读入的数据，比如文件，数据报，套接字，等等。通道类的层级结构是很复杂的，有多个接口，和很多可选的操作。然而，对于网络编程的目的，只有三个确实很重要的通道类，SocketChannel, ServerSocketChannel, and DatagramChannel。对于对于目前我们讨论到的TCP连接，你只需要前两个。
		SocketChannel
			SocketChannel从TCP套接字读取或向其写出。数据必须被转化为ByteBuffer对象，来用于读取和写出。每个SocketChannel对象都有一个相关的Socket对象，该套接字对象可以被用于进一步的配置。
			连接
				SocketChannel类没有任何公共的构造函数。相替代的，你使用两个静态open()方法中的一个来创建一个新的SocketChannel对象：
					public static SocketChannel open(SocketAddress remote) throws IOException
					public static SocketChannel open() throws IOException
				第一个变种会建立连接，这个方法会阻塞（这个方法将不会返回直到连接被建立或异常被抛出）。比如：
					SocketAddress address = new InetSocketAddress("www.cafeaulait.org", 80);
					SocketChannel channel = SocketChannel.open(address);
				没有参数的版本不会立即连接。它创建一个初始的，未连接的异常，必须在后面通过使用connect()方法来连接。比如：
					SocketChannel channel = SocketChannel.open();
					SocketAddress address = new InetSocketAddress("www.cafeaulait.org", 80);
					channel.connect(address);
				你可能会选择这种更绕的方法，为了在连接之前可以为通道和/或套接字配置不同的选项。尤其是，如果你想要打开通道，而没有阻塞，使用这种方式：
					SocketChannel channel = SocketChannel.open();
					SocketAddress address = new InetSocketAddress("www.cafeaulait.org",
					channel.configureBlocking(false);
					channel.connect();
				对于一个非阻塞的通道，connect()方法立即返回，甚至可能在连接被建立之前。当等待操作系统完成连接时，程序可以做其他事情。然而，在它确实可以使用连接之前，程序必须调用finishConnect()：
					public abstract boolean finishConnect() throws IOException
				这个只有在非阻塞模式才需要。对于一个阻塞的通道，这个方法立即返回true。如果连接现在准备好被使用，finishConnect()返回true。如果连接还没有被建立，finishConnect()返回false。最后，如果连接不能被建立，比如，网络挂掉，这个方法抛出一个异常。
				如果程序需要检测连接是否完成，它可以调用这两个方法：
					public abstract boolean isConnected()
					public abstract boolean isConnectionPending()
				如果连接是打开的，isConnected()返回true。如果连接仍然在被建立，但还没有打开，isConnectionPending()方法返回true。
			读取
				为了从SocketChannel读取，首先创建一个通道可以用来存储数据的ByteBuffer，然后将它传递给read()方法：
					public abstract int read(ByteBuffer dst) throws IOException
				通道以它能使用的尽可能多的数据来填充缓冲区，然后返回它存放在那的字节的数量。当它到了流的结尾，通道使用任何剩余的数据来填充缓冲区，并且在下一次调用read()时返回-1.如果通道是阻塞的，这个方法将读取至少一个字节，或返回-1，或抛出一个异常。如果通道是非阻塞的，这个方法可能返回0。
				因为数据被存储进缓冲区，在当前的位置。当有更多的数据被添加时，它会自动更新，你可以保持传递相同的缓冲区到read()方法，直到缓冲区被填满。比如，这个循环将读取，直到缓冲区被填满，或流的结尾被检测到：
					while (buffer.hasRemaining() && channel.read(buffer) != -1) ;
				有时候，允许从同一个数据源来填充多个缓冲区是很有用的。这个被叫组scatter。这两个方法允许接受一个ByteBuffer对象的数组作为参数，并且轮流填充他们：
					public final long read(ByteBuffer[] dsts) throws IOException
					public final long read(ByteBuffer[] dsts, int offset, int length) throws IOException
				第一个变种填充所有的缓冲区，第二个方法填充从offset开始的，length个缓冲区。
				为了填充一个数组的缓冲区，只管循环，当列表中的最后一个缓冲区仍然有空间。比如：
					ByteBuffer[] buffers = new ByteBuffer[2];
					buffers[0] = ByteBuffer.allocate(1000);
					buffers[1] = ByteBuffer.allocate(1000);
					while (buffers[1].hasRemaining() && channel.read(buffers) != -1) ;
			写出
				套接字通道同时拥有读和写的方法。一般来说，他们是全双工的。为了写出，只需要填充一个ByteBuffer，flip它，并把它传递到其中的一个写方法，在那将消耗它，将数据拷贝到输出，是读过程的反转。
				基本的write()方法接受一个单一的缓冲区作为参数：
					public abstract int write(ByteBuffer src) throws IOException
				就像读（不像OutputStream），如果通道是非阻塞的，这个方法不保证完全写出缓冲区中的内容。再一次，然而，基于游标的缓冲区允许你一次又一次的调用这个方法，直到缓冲区被完全消耗完，并且数据被完全的写出：
					while (buffer.hasRemaining() && channel.write(buffer) != -1) ;
				通常允许从多个缓冲区写出到同一个套接字很有用。这个被称为一个gather。比如，你可能想要存储HTTP头到一个缓冲区中，HTTP体到另一个缓冲区中。实现可能同时填充这两个缓冲区，使用两个线程或重叠的I/O。这两个方法接受一个ByteBuffer数组作为参数，并且轮流消耗每一个：
					public final long write(ByteBuffer[] dsts) throws IOException
					public final long write(ByteBuffer[] dsts, int offset, int length) throws IOException
				第一个变种消耗所有的缓冲区，第二个方法从第offset个开始，消耗length个缓冲区。
			关闭
				就像常规的套接字一样，当你使用完通道的时候，你应该关闭它，来释放端口和任何其他它可能使用的资源：
					public void close() throws IOException
				再次关闭一个已经关闭的通道没有影响。尝试着向一个已经关闭的通道写出数据，或从其进行读取，会抛出一个异常。如果你不确定一个通道是否已经被关闭，使用isOpen()来检测：
					public boolean isOpen()
				自然的，如果通道是关闭的，这个将返回false，如果是打开的，它将返回true。close()和isOpen()是声明在通道接口中的唯一的两个方法，被所有的通道类所共享。
				从java 7开始，SocketChannel实现了AutoCloseable，以使你可以在try-with-resource中使用它。
		ServerSocketChannel
			ServerSocketChannel有一个目的，接受进来的连接。你不能从中读取，向其写出，或连接到一个ServerSocketChannel。它支持的唯一操作是接受一个新进来的连接。这个类自己只定义了4个方法，accept()是最终要的一个。ServerSocketChannel也从它的超类继承了多个方法，大多数是关于注册到一个Selector，为了在有新连接时可以得到通知。最后，就像所有的通道，它有一个close()方法来关闭服务器端套接字。
			创建服务器端套接字通道
				静态工厂方法ServerSocketChannel.open()创建一个新的ServerSocketChannel对象。然而，名字有一点迷惑。这个方法实际上并不会打开一个新的服务器端套接字。相替代的，它仅仅创建一个对象。在你能使用它之前，你需要调用socket()方法来获取响应的对等的ServerSocket。在这个时候，你可以配置任何你想要的服务器端选项，比如接收缓冲区大小，或套接字超时，使用ServerSocket中的多种多样的setter方法。然后连接这个ServerSocket到一个SocketAddress。比如，这个代码片段，打开一个ServerSocketChannel在80端口上：
					try {
						ServerSocketChannel server = ServerSocketChannel.open();
						ServerSocket socket = serverChannel.socket();
						SocketAddress address = new InetSocketAddress(80);
						socket.bind(address);
					} catch (IOException ex) {
						System.err.println("Could not bind to port 80 because " + ex.getMessage());
					}
				在java 7中，这个会变得简单一点，因为ServerSocketChannel现在自己有一个bind()方法：
					try {
						ServerSocketChannel server = ServerSocketChannel.open();
						SocketAddress address = new InetSocketAddress(80);
						server.bind(address);
					} catch (IOException ex) {
						System.err.println("Could not bind to port 80 because " + ex.getMessage());
					}
				在这里使用一个工厂方法，而不是一个构造函数，以便不同的虚拟机可以为这个类提供不同的实现，调整的和本地硬件和OS更接近。然而，这个工厂不是用户可配置的。当在相同的虚拟机上运行时，open()方法总是返回同一个类的一个接口。
			接收连接
				一旦你已经打开并绑定了一个ServerSocketChannel对象，accept()方法就可以监听进来的连接了：
					public abstract SocketChannel accept() throws IOException
				accept()既可以在阻塞模式也可以在非阻塞模式。在阻塞模式中，accept()等待进来的连接，它然后接受那个连接，并返回一个连接到远程客户端的SocketChannel对象。线程不能做任何事情，直到连接被建立。这个策略可能对可以立即响应每个请求的简单服务器很恰当。阻塞模式是默认模式。
				ServerSocketChannel也可以在非阻塞模式。在这种情况下，如果没有进来的连接，accept()返回null。对于那些需要对每个连接做很多工作，因此想要并行的处理多个请求的服务器，非阻塞模式更合适。非阻塞模式通常和一个Selector联合使用。为了使一个ServerSocketChannel非阻塞，传递false到它的configureBlocking()方法。
				accept()方法声明为抛出一个IOException，如果任何事情出现错误。有很多IOException的子类，他们可以指明更详细的问题，就像一对运行时异常一样：
					ClosedChannelException
						你不能重新打开一个ServerSocketChannel，在关闭了它之后。
					AsynchronousCloseException
						当accept()正在执行时，另一个线程关闭了这个ServerSocketChannel。
					ClosedByInterruptException
						另一个线程中断了这个线程，当一个阻塞的ServerSocketChannel正在等待。
					NotYetBoundException
						你调用了open()，但是没有绑定ServerSocketChannel对等的ServerSocket到一个地址，在调用accept()之前。这是一个运行时异常，不是一个IOException。
					SecurityException
						安全管理器拒绝允许这个应用绑定到被请求的端口。
		Channels类
			Channels是一个简单的实用类，用来将传统的基于I/O的stream, readers, writers包装成通道，以及相反，从通道中获取这些传统的基于I/O的stream, readers, writers。当你在程序的某一部分，为了性能，想要使用新的I/O模式，但是仍然需要和遗留的，期望stream的API进行交互，这会很有用。它有将流转化为通道，以及将通道转化为stream, reader, writer的方法：
				public static InputStream newInputStream(ReadableByteChannel ch)
				public static OutputStream newOutputStream(WritableByteChannel ch)
				public static ReadableByteChannel newChannel(InputStream in)
				public static WritableByteChannel newChannel(OutputStream out)
				public static Reader newReader (ReadableByteChannel channel, CharsetDecoder decoder, int minimumBufferCapacity)
				public static Reader newReader (ReadableByteChannel ch, String encoding)
				public static Writer newWriter (WritableByteChannel ch, String encoding)
			本章讨论的SocketChannel类同时实现了ReadableByteChannel和WritableByteChannel接口。ServerSocketChannel没有实现这两个接口，因为你不能从它读取或向它写出。
			比如，所有当前的XML API使用streams, files, readers或其他传统的I/O API来读取XML文档。如果你正在设计一个HTTP服务器，被设计用来处理SOAP请求，你可能想要使用通道来读取HTTP请求头，并且使用SAX来解析XML，为了性能。在这种情况下，这种情况下，你需要转化这些通道到流，在将他们传递到XMLReader的parse()方法之前：
				SocketChannel channel = server.accept();
				processHTTPHeader(channel);
				XMLReader parser = XMLReaderFactory.createXMLReader();
				parser.setContentHandler(someContentHandlerObject);
				InputStream in = Channels.newInputStream(channel);
				parser.parse(in);
		异步通道（java 7）
			java 7引入了AsynchronousSocketChannel和AsynchronousServerSocketChannel类。他们的行为很像，并且有和SocketChannel以及ServerSocketChannel几乎一样的接口（虽然他们不是这些类的子类）。然而，不像SocketChannel和ServerSocketChannel，从异步通道进行读取或写出，会立即返回，甚至在I/O完成之前。被读取和写出的数据，更进一步被一个Future或一个CompletionHandler处理。connect()和accept()方法也异步的执行，并且返回Future。选择器Selector不再被使用。
			比如，假设一个程序在启动时需要执行大量的初始化。这些初始化中可能包括网络连接，每个连接都将花费数秒钟。你可以并行的启动多个异步操作，然后执行你的本地初始化，然后请求网络操作的结果：
				SocketAddress address = new InetSocketAddress(args[0], port);
				AsynchronousSocketChannel client = AsynchronousSocketChannel.open();
				Future<Void> connected = client.connect(address);
				
				ByteBuffer buffer = ByteBuffer.allocate(74);
				
				// wait for the connection to finish
				connected.get();
				
				// read from the connection
				Future<Integer> future = client.read(buffer);
				
				// do other things...
				
				// wait for the read to finish...
				future.get();
				
				// flip and drain the buffer
				buffer.flip();
				WritableByteChannel out = Channels.newChannel(System.out);
				out.write(buffer);
			这个方法的优点是，当程序在处理其他事情时，网络连接并行的运行。当你准备好处理从网络进来的数据时，通过调用Future.get()，你停下来并且等待它。你可以使用线程池和callable来获得相同的效果，但是这个可能更简单一些，特别是当缓冲区和你的应用结合的很好的时候。
			这个方法适合于那些你想要获取数据在一个特定的顺序的场景。然而，如果你不关心顺序，如果你可以独立的处理每个网络读取，那么你最好相替代的使用一个CompletionHandler。比如，设想你正在编写一个搜索引擎网络爬虫，他们反馈页面到后台。因为你不关心这些响应返回的顺序，你可以产生大量的AsynchronousSocketChannel请求，并且给每个一个CompletionHandler，它来将结果存储到后台。

			CompletionHandler接口声明了两个方法:completed(),在读成功完成时被调用;failed(),在一个I/O错误发生时被调用.比如,这是一个简单的CompletionHandler的例子,将它接收到的任何东西打印到System.out:
				class LineHandler implements CompletionHandler<Integer, ByteBuffer> {
					@Override
					public void completed(Integer result, ByteBuffer buffer) {
						buffer.flip();
						WritableByteChannel out = Channels.newChannel(System.out);
						try {
							out.write(buffer);
						} catch (IOException ex) {
							System.err.println(ex);
						}
					}

					@Override
					public void failed(Throwable ex, ByteBuffer attachment) {
						System.err.println(ex.getMessage());
					}
				}
			当你从通道读取时,你传递一个缓冲区,一个附件,和一个CompletionHandler到read()方法：
				ByteBuffer buffer = ByteBuffer.allocate(74);
				CompletionHandler<Integer, ByteBuffer> handler = new LineHandler();
				channel.read(buffer, buffer, handler);
			在这里，我使附件是缓冲区它自己。这是一种方法将从网络读取的数据推送到CompletionHandler，在那里它可以处理这些数据。另一个通常的模式是将CompletionHandler作为一个匿名内部类，并且缓冲区是一个final类型的本地变量，以使它的作用范围可以到达CompletionHandler内部。
			虽然你可以在多个线程之间安全的共享AsynchronousSocketChannel或AsynchronousServerSocketChannel，每一次最多只能有一个线程能从通道进行读取，以及每一次最多只能有一个现成能向通道写出。（但可以一个线程读取，一个线程同时写出）。如果一个线程，在另一个线程有一个挂起的读时，尝试读取，read()方法抛出一个ReadPendingException。相似的，如果一个线程，在另一个线程有一个挂起的写时，write()方法抛出一个WritePendingException。
		套接字选项（java 7）
			从java 7开始，SocketChannel, ServerSocketChannel, AsynchronousServerSocketChannel, AsynchronousSocketChannel, and DatagramChannel都实现了新的NetworkChannel接口。这个接口的主要目的是支持多种多样的TCP选项，比如在第8，9章中讨论到的TCP_NODELAY, SO_TIMEOUT, SO_LINGER, SO_SNDBUF, SO_RCVBUF, 和SO_KEEPALIVE。不管是设置在套接字上还是在通道上，这些选项在底层的TCP栈上都有相同的意义。然而，对于这些选项的接口却有一点不同，不是对每一个支持的选项都有一个单独的方法，每个通道类只有3个方法来获取，设置，和列出支持的选项：
				<T> T getOption(SocketOption<T> name) throws IOException
				<T> NetworkChannel setOption(SocketOption<T> name, T value) throws IOException
				Set<SocketOption<?>> supportedOptions()
			SocketOption是一个通用类，它指明了每个选项的名字和类型。类型参数<T>决定选项是否是一个boolean, Integer, 或NetworkInterface。StandardSocketOptions类为java可以认出的11个选项的每一个都提供了常量：
				• SocketOption<NetworkInterface> StandardSocketOptions.IP_MULTICAST_IF
				• SocketOption<Boolean> StandardSocketOptions.IP_MULTICAST_LOOP
				• SocketOption<Integer> StandardSocketOptions.IP_MULTICAST_TTL
				• SocketOption<Integer> StandardSocketOptions.IP_TOS
				• SocketOption<Boolean> StandardSocketOptions.SO_BROADCAST
				• SocketOption<Boolean> StandardSocketOptions.SO_KEEPALIVE
				• SocketOption<Integer> StandardSocketOptions.SO_LINGER
				• SocketOption<Integer> StandardSocketOptions.SO_RCVBUF
				• SocketOption<Boolean> StandardSocketOptions.SO_REUSEADDR
				• SocketOption<Integer> StandardSocketOptions.SO_SNDBUF
				• SocketOption<Boolean> StandardSocketOptions.TCP_NODELAY
			比如，这个代码片断打开一个客户端网络通道，并且设置SO_LINGER为240秒：
				NetworkChannel channel = SocketChannel.open();
				channel.setOption(StandardSocketOptions.SO_LINGER, 240);
			不同的通道和套接字支持不同的选项。比如，ServerSocketChannel支持SO_REUSEADDR和SO_RCVBUF，但是不支持SO_SNDBUF。尝试着设置一个通道不支持的选项会抛出一个UnsupportedOperationException.
	就绪状态选择
		对于网络编程，新I/O API的第二部分是就绪状态选择，选择一个在读和写时不会阻塞的套接字的能力。虽然，运行多个同时连接的客户段，比如网络爬虫和浏览器，也可以利用它，但它的主要兴趣在服务器端。
		为了进行就绪状态选择，不同的通道注册到一个Selector对象。每一个通道被分配一个SelectionKey，程序然后就可以请求Selector对象来获得那些准备好执行那些你想要非阻塞的执行的操作的通道对应的键。
		Selector类
			Selector类的唯一构造函数是受保护的。通常，一个新的选择器被通过调用静态工厂方法Selector.open()被创建：
				public static Selector open() throws IOException
			下一个步骤是添加通道到选择器。Selector类中没有方法来添加一个通道。register()方法被声明在SelectableChannel类中。并不是所有的通道都是可选择的，实际上，FileChannels是不可选择的，但是所有的网络通道都是可选择的。因此，通过传递选择器到通道的某一个注册方法，来讲通道注册到一个选择器：
				public final SelectionKey register(Selector sel, int ops) throws ClosedChannelException
				public final SelectionKey register(Selector sel, int ops, Object att) throws ClosedChannelException			
	
			第一个参数是通道要注册到的选择器，第二个参数是来自于SelectionKey类的命名常量，指明通道要注册到的操作。SelectionKey类定义了4个命名的位常量，被用来选择操作的类型：
				• SelectionKey.OP_ACCEPT
				• SelectionKey.OP_CONNECT
				• SelectionKey.OP_READ
				• SelectionKey.OP_WRITE
			这些是位标记的int常量（1，2，4等）。因此，如果一个通道要在同一个选择器上注册多个操作，（比如，在同一个套接字上同时读和写），在注册时通过按位或操作来合并这些常量：
				channel.register(selector, SelectionKey.OP_READ | SelectionKey.OP_WRITE);
			可选的第三个参数是key的附件。这个对象通常被用来存储连接的状态。比如，如果你正在实现一个web服务器，你可能附加一个，连接到数据器要输出到客户端的本地文件的FileInputStream或FileChannel。
			在不同的通道注册到选择器之后，你可以在任何时候查询选择器，来找出那些通道准备好被处理。一些通道可能对某些操作准备好，但是对另一些没有准备好。比如，一个通道可能准备好读取，但没有准备好写出。
			选择准备好的通道有三种方法，他们的不同之处在于将等待多长时间来查找准备好的通道。首先，selectNow()执行一个非阻塞的选择。如果现在没有连接准备好被处理，它将立即返回：
				public abstract int selectNow() throws IOException
			两外两个选择方法是阻塞的：
				public abstract int select() throws IOException
				public abstract int select(long timeout) throws IOException
			第一个方法在返回之前等待，直到至少有一个注册的通道准备好被处理。第二个方法在返回0之前，等待最多timeout毫秒，来查找是否有通道准备好。如果你的程序中，当没有通道准备好被处理时，没有任何事情可做时，很有用。
			当你知道通道准备好被处理，使用selectedKeys()来获取准备好的通道：
				public abstract Set<SelectionKey> selectedKeys()
			你在返回的集合上迭代，轮流处理每一个SelectionKey。你将也想要将key从迭代器中删除掉，来告诉选择器你已经处理了它。否则，选择器在将来的循环中将一直为你返回它。
			最后，当你准备好关闭服务器，或当你不再需要选择器，你应该关闭它：
				public abstract void close() throws IOException
			这个操作释放和选择器相关的所有资源。更重要的是，它取消掉所有key和选择器的注册关系，并且中断被选择器的选择方法阻塞的任何线程。
		SelectionKey类
			SelectionKey对象以一个指向通道的指针的方式来工作。他们也可以持有一个附件，通常用来存储那个通道上的连接的状态。
			SelectionKey对象被register()方法返回，但注册一个通道到一个选择器上时。然而，你通常不需要保持这个引用。selectedKeys()方法将再次返回相同的对象到一个Set中。一个通道可以注册到多个选择器。
			当从被选择的key的集合中获取一个SelectionKey，你通常首先测试这个key准备好了做什么。有4个可能性：
				public final boolean isAcceptable()
				public final boolean isConnectable()
				public final boolean isReadable()
				public final boolean isWritable()
			这个测试不是经常需要。在一些情况，选择器只测试一种情况，并且将只返回做那一件事情的key。但如果选择器为多个准备就绪状态进行测试，在操作它之前，你将想要测试哪个触发通道到准备就绪状态。也有可能通道准备好做多件事情。
			一旦你知道了关联到key的通道准备好了做什么，使用channel()方法来获取通道：
				public abstract SelectableChannel channel()
			如果你已经存储了一个对象在SelectionKey中，来持有状态信息。你可以使用attachment()方法来获取它：
				public final Object attachment()
			最后，当你完成了一个连接，取消注册它的SelectionKey，以使选择器不再浪费任何资源来查询它的准备就绪状态。我不知道这个在所有情况下都至关重要，但它没有伤害。你通过调用key的cancel()方法来做这个：
				public abstract void cancel()
			然而，这个步骤只有在你还没有关闭通道是才需要。关闭一个通道自动取消该通道注册到所有选择器上的所有的key。相似的，关闭一个选择器，将使该选择器上的所有的key无效。
	


第12章 UDP
	前一章讨论了运行在传输层协议TCP上的网络应用。TCP被设计用于数据的可靠传输。如果数据在传输的过程中损坏或丢失，TCP确保数据重传。如果数据报乱序到达，TCP将他们放回正确的顺序。如果对于连接，数据进来的太快，TCP减慢速度，以使数据报不会丢失。一个程序从来不需要担心获取的数据是乱序的或不正确的。然而，这个可靠性需要一定的代价。代价就是速度。建立和释放TCP需要花费相当多的时间，特别是对于协议，比如HTTP，那些倾向于需要很多短传输时。
	User Datagram Protocol (UDP)是一个替代的传输层协议，用于很快的发送数据在IP之上，但不可靠。当你发送UDP数据，你没有办法知道它是否被收到，更不用说数据片是否按他们发送的顺序到达。然而，确实到达的数据片通常到达的很快。
	UDP协议
		一个很明显的需要问的问题是为什么有人会要用不可靠的协议。确实，如果你有数据值得发送，你会关心数据是否正确的到达。显然，对于那些需要在潜在的不可靠的网络上进行可靠传输的应用，比如FTP，UDP不是很符合。然而，有很多种类的应用，原生速度要比正确获得每一个字节要重要。比如，一个实时的视频或音频，丢失数据报仅仅表现为静止。静止是可容忍的，但音频流中尴尬的暂停，当TCP请求一个重传或等待一个不规则的包到达，是不可接受的。在其他应用中，可靠测试可以在应用层被实现。比如，如果一个客户端发送一个简短的UDP请求到服务器端，如果在一个建立连接范围的时间内没有响应，它可以假设数据报丢失了，DNS就是以这种方式工作。DNS也可以在TCP上进行。事实上，你可以使用UDP实现一个可靠的文件传输协议，并且很多人已经这么做了：Network File System (NFS), Trivial FTP (TFTP), and FSP，FTP的一个远亲，都使用UDP。最近版本的NFS既可以使用TCP，也可以使用UDP。在这些协议中，应用负责可靠性，UDP不关心它。应用必须处理数据报的丢失和乱序。这是很大量的工作，但是没有原因它不能被完成，即使你自己在编写代码，认真想想你是否可以比TCP更好。
		TCP和UDP之间的不同通常使用电话系统或邮局的类比来解释。TCP就像电话系统。当你拨一个数字，电话进行响应，在两个人之间建立一个连接。当你讲话时，你知道另一方听到的顺序就是你说的顺序。如果电话是忙的，或者是没有人接听，你立即就可以知道。UDP，相反的，就像邮局。你发送邮件到一个地址。大多数的信件到达了，但是有些可能在路上丢失了。信件可能以你发送的顺序到达，但是那不被保证。你离你的接收者越远，越有可能发生丢失和乱序的情况。如果这是一个问题，你可以在信封上写上有序的数字，然后告诉接收者以正确的顺序整理他们，并且给你发送邮件告诉你哪些信件到达了，以使你可以在第一时间重新发送那些没有到达的信件。然而，你和你的合作者需要进一步的就该协议达成一致。邮局不会为你做这些。
		电话系统和邮局都有他们的用处。虽然，几乎每一个都可以用于几乎所有的通信，但是在一些情况下，一个会明显比另一个优秀。前面的几章都关注在TCP应用上，它比UDP应用更通常。然而，UDP也有它的位置。在本章中，我们将查看你可以使用UDP做什么。如果你想要走的更远，下一章描述了基于UDP的多播。一个多播套接字是一个在标准UDP协议上的相对简单的变种。
		java的UDP实现被分割为两个类：DatagramPacket和DatagramSocket。DatagramPacket类填充字节数据到UDP数据报，并且允许你从你接收到的数据报中取出数据。DatagramSocket发送和接收UDP数据报。为了发送数据，你将数据放到DatagramPacket中，并且使用DatagramSocket发送数据报。为了接收数据，你从DatagramSocket取出一个DatagramPacket对象，然后解析数据报的内容。在UDP中，关于数据报的任何东西，包括它被传送到的地址，包含在数据包自己中，套接字只需要知道用于发送和监听的本地端口。
		这个分工和TCP使用的Socket和ServerSocket形成对比.首先,UDP没有任何关于两个主机之间有一个唯一连接的概念.一个套接字发送和接收所有的数据,定向到一个端口或从一个端口来的,而不用担心远程主机是谁.一个单独的DatagramSocket可以从多个相互独立的主机发送和接收数据.套接字并不像它在TCP中那样,不是只用于一个单个的连接.事实上,UDP没有两个主机之间有个连接的概念,它只知道单独的数据报.找出谁发送了哪些数据是应用的责任.第二,TCP对待一个网络连接作为一个流,你通过从套接字获得的输入流和输出流来发送和接收数据.UDP不支持这个.你总是工作于单独的数据报.你往一个单独的数据报中填充的所有数据被作为一个单独的数据包发送,作为一个整体,或者被收到或者丢失.一个数据包不需要和下一个相关.给出两个数据包,无法决定哪个先发送,哪个后发送.相替代于流中需要时有序的数据,才\数据报尝试尽可能快地涌入到接收端,就像一群人挤进一个公交车,并且偶尔的,如果公交车被挤满,一些数据包,就像人,可能没有排上队.
	UDP客户端
		让我们以一个简单的例子开始.首先在端口0上打开一个套接字:
			DatagramSocket socket = new DatagramSocket(0);
		这个和TCP套接字很不同.你只指明了一个要连接到的本地的端口.套接字并不知道远程主机或地址.通过指定端口为0,你告诉java为你选取一个随机可用的端口,很像服务器端套接字.
		下一步是可选的,但是是高度建议的.使用setSoTimeout()在连接上设置一个超时.超时时间的单位是毫秒.所以这个代码片断设置套接字的超时时间为10秒,在没有响应的情况下:
			socket.setSoTimeout(10000);
		超时对于UDP，要比TCP更重要。因为在TCP中可能导致IOException的很多问题，在UDP中会安静的失败。比如，如果远程主机没有监听在远程端口上，你将永远不会从它听到什么。
		接下来，你需要建立数据包。你将需要两个，一个用来发送，一个用来接收。对于daytime协议，你在数据报中放了哪些数据并不重要，但是你确实需要告诉它要连接到的远程主机和远程端口：
			InetAddress host = InetAddress.getByName("time.nist.gov");
			DatagramPacket request = new DatagramPacket(new
byte[1], 1, host, 13);
		接收服务器端响应的数据包只需要包含一个空的字节数组。这个需要足够大，来持有整个响应。如果它太小，它将被安静的截断，1K应该是足够的大小：
			byte[] data = new byte[1024];
			DatagramPacket response = new DatagramPacket(data, data.length);
		现在，你准备好了。首先在套接字上发送数据包，然后接收响应：
			socket.send(request);
			socket.receive(response);
		最后，从响应中抽取字节，并且将他们转化为你可以展示给用户的字符串：	
			String daytime = new String(response.getData(), 0, response.getLength(), "US-ASCII");
			System.out.println(daytime);
		构造函数，send()和receive()每个都会抛出IOException,所以你将通常将这些包裹在一个try块中。在java 7中，DatagramSocket实现了Autocloseable，所以你可以使用try-with-resources：
			try (DatagramSocket socket = new DatagramSocket(0)) {
				// connect to the server...
			} catch (IOException ex) {
				System.err.println("Could not connect to time.nist.gov");
			}
		在java 6及以前，你将需要显示的关闭套接字在一个finally块中，来释放套接字持有的资源：
			DatagramSocket socket = null;
			try {
				socket = new DatagramSocket(0);
				// connect to the server...
			} catch (IOException ex) {
				System.err.println(ex);
			} finally {
				if (socket != null) {
				try {
					socket.close();
				} catch (IOException ex) {
					// ignore
				}
				}
			}
	UDP服务器端                                      
		UDP服务器端遵循基本和UDP客户端相同的模式，除了你通常在发送之前要先接收，以及不会选择一个匿名的端口来绑定。不像TCP，没有单独的DatagramServerSocket类。
		比如，让我们在UDP上实现daytime服务器，通过在一个著名的端口上打开一个数据报套接字来开始。对于daytime，端口是13：
			DatagramSocket socket = new DatagramSocket(13);
		就像TCP套接字，在Unix系统上，为了绑定到一个1024以下的端口，你需要以root身份运行。你或者可以使用sudo来运行程序，或者简单的将端口改为1024以上。
		接下来，创建一个包，用来接收请求到它里边。你需要提供一个用来存储进来的数据的数组，数组中的偏移量，要存储的字节数。这里我们设置一个从0开始的，有1024字节空间的包：
			DatagramPacket request = new DatagramPacket(new byte[1024], 0, 1024);
		然后接收它：
			socket.receive(request);
		这个调用无限期阻塞，直到13端口上有个UDP包到达。当这种情况发生时，java使用数据填充字节数组，并且receive()方法返回。
		接下来，创建一个响应包。这个有4个部分：原始的要发送的数据，要发送的原始数据的字节数，要发送到的主机，以及要发送到的端口。在这个例子中，原始数据来自于当前时间构成的字符串，主机和端口就是进来的数据包的主机和端口：
			String daytime = new Date().toString() + "\r\n";
			byte[] data = daytime.getBytes("US-ASCII");
			InetAddress host = request.getAddress();
			int port = request.getPort();
			DatagramPacket response = new DatagramPacket(data, data.length, host, port);
		最后，发送响应，从接收它的端口：
			socket.send(response);
		UDP服务器不像TCP服务器那样，倾向于使用多线程，他们通常对于任何一个客户端都不会做太多工作，并且它从不会因为等待另一端的响应而变得阻塞，因为UDP从不报告错误。除非大量的，很耗时间的工作被需要，在准备响应时，对于UDP服务器，一个简单的循环的方法就可以工作的很好了。
	DatagramPacket类
		UDP数据报在它之下的IP数据报上添加很少的东西。UDP头只添加了8个字节到IP头上。UDP头包含源和目的端口号，紧跟着IP头的所有东西的长度，以及一个可选的校验和。因为端口号以一个两字节的无符号整数形式给出，每个主机有65536个不同的可能的UDP端口号可用。这些和每个主机的65536个不同的TCP端口不同。因为长度也是一个2字节的无符号整数，数据报中字节的数量被限制到65536减去头部中的8个字节。然而，这个对于IP头中指定的数据报长度来说，是过剩了，IP头限制数据报的长度为65467到65507字节。具体的数字依赖于IP头的大小。校验和字段是可选的，并且不会被应用层程序使用或访问。如果数据的校验和失败，原生的网络软件安静的丢弃数据报，发送者和接受者都不会被通知。毕竟，UDP是不可靠的协议。
		虽然，UDP数据报的理论最大值是65507字节，但实际上，大多数时候会更少。在很多平台上，实际的限制更有可能是8192字节。并且实现不被要求接收超过576总字节的数据报，包括数据和头。因此，你应该对发送和接受超过8K数据的数据报的程序极其小心。大多数时候，更大的数据报被截断为8K.为了最大的安全性，UDP数据报的数据部分应该被保持在512字节或更少，虽然，这个限制相对于更大的数据报大小会对性能有负面影响。这对于TCP数据报也是一个问题，但是由Socket和ServerSocket提供的基于流的API完全为程序员屏蔽了这些细节。
		在java中，一个UDP数据报由DatagramPacket类的一个实例来表示：
			public final class DatagramPacket extends Object
		这个类提供了方法来从IP头中获取或设置源或目的地址，获取或设置源或目的端口，获取或设置数据，获取或设置数据的长度。剩余的头字段从纯java代码中是不可访问的。
		
		构造器
			DatagramPacket根据包将被用于接收数据或是发送数据，使用不同的构造器。这个有一点不平常。通常，构造器被重载，来允许你提供不同类型的信息，当你创建一个对象时，并不是被用于为创建将要被用于不同上下文的相同类的对象。在这种情况下，所有的6个构造函数使用持有数据报中数据的字节数组，以及字节数组中用于数据报数据的字节的长度作为参数。当你想要获取一个数据报，你只需要提供这些参数。当套接字从网络获取了一个数据报时，它存储数据报的数据到DatagramPacket对象的缓冲数组中，直到你指定的长度。
			第二种类型的DatagramPacket构造函数用于创建你将要发送到网络上的数据报。就像第一个，这些构造函数要求一个缓冲数组，一个长度，但是他们还要求数据报将要被发送到的地址和端口。在这种情况下，你传递给构造函数一个包含你想要发送数据的字节数组，数据报将要被发送到的目的地址和端口。DatagramSocket从包中读取目的地址和端口，地址和端口不会像TCP那样存储在套接字中。
			构造用于接收数据的数据报的构造函数
				这两个构造函数用于创建用于从网络接收数据的DatagramPacket对象：
					public DatagramPacket(byte[] buffer, int length)
					public DatagramPacket(byte[] buffer, int offset, int length)
				如果第一个构造函数被使用，当一个套接字接收到一个数据报，它存储数据报的数据部分到buffer，从buffer[0]开始，直到数据报被完全存储，或直到length个字节已经被写入到buffer中。比如，这个代码片段创建一个新的DatagramPacket来接收直到8192大小的数据报：
					byte[] buffer = new byte[8192];
					DatagramPacket dp = new DatagramPacket(buffer, buffer.length);
				如果第二个构造函数被使用，存储相替代的起始于buffer[offset]。否则，这两个构造函数是相同的，length必须小于或等于buffer.length-offset。如果你尝试构造一个DatagramPacket，它的长度超过了buffer的容量，构造函数抛出一个IllegalArgumentException。这个是RuntimeException，所以你的代码不被要求捕获它。构造一个长度小于buffer.length-offset的DatagramPacket是可以的。在这种情况下，当数据报被接收时，最多只有buffer的前length个字节被填充。
				构造函数不关心缓冲区有多大，它很高兴让你创建一个有几M数据的DatagramPacket。然而，底层的原生网络软件没有这么宽容，大多数原生的UDP实现不支持多于8192字节数据的数据报。IPV4数据报的理论限制是65507字节的数据，一个拥有65507大小的缓冲区的DatagramPacket可以接收任何可能的IPV4数据报，而不会丢失数据。IPV6数据报提升理论限制到65536字节。实际上，很多基于UDP的协议，比如DNS和HTTP使用512字节或更少数据的数据报。对于NFS，通常使用的最大的数据大小是8192字节。你可能碰到的几乎所有的数据报大小都将是8K数据或更少。实际上，很多操作系统不支持数据大于8K的数据报，并且或者截断，或者切分，或者丢弃更大的数据报。如果一个大的数据报太大，并且导致网络截断或丢弃它，你的java程序不会被通知这个问题。因此，你不应该创建数据大小大于8192字节的DatagramPacket对象。
			构造用于发送数据的数据报的构造函数
				这4个构造函数创建用于发送数据到网络的DatagramPacket对象:
					public DatagramPacket(byte[] data, int length, InetAddress destination, int port)
					public DatagramPacket(byte[] data, int offset, int length, InetAddress destination, int port)
					public DatagramPacket(byte[] data, int length, SocketAddress destination)
					public DatagramPacket(byte[] data, int offset, int length, SocketAddress destination)
				每个构造函数创建一个被发送到其他主机的DatagramPacket对象,包被由data数组中从offset(0,如果offset没有设置的话)开始的,length长度的字节数据填充.如果你尝试着构造一个DatagramPacket,他的长度超过data.length或data.length-offset，构造函数抛出一个IllegalArgumentException。创建一个DatagramPacket时，如果使用的offset和length使data数组还有未被使用的空间也是可以的。在这种情况下，data数组中，只有length长度的数据被发送到网络上。InetAddress或SocketAddress对象指名你想要传送数据到的目的地址。int类型的port参数指名了那个主机的端口。
				选择一个数据报的大小
					用来填充到一个包中的正确的数据大小依赖于场景。有些协议指明了包的大小。比如，rlogin几乎在你键入字符的同时将其传输到远程系统。因此，包偏向于短小，单个字节的数据，加上少量的头。其他应用没有这么挑剔，比如，文件传输在使用大缓冲区时更有效。唯一的要求是你将文件切分成的包的大小不要超过最大可允许的包的大小。
					要选择最佳的包的大小要考虑很多因素。如果网络是高度不可靠的，比如一个无线电分组交换网络，优先选择较小的包，因为他们在传输的过程中更不容易被损坏。另一方面，很快的，可靠的LANs应该使用可能的最大的包大小。8K对于很多类型的网络是一个很好的折中。
				习惯上，在创建DatagramPacket之前，将数据转换成字节数组，并将它们放到data中，但这不是必须的，在数据报已经被创建后修改data，以及它被发送之前修改data，数据不是被拷贝到一个私有的缓冲区。比如，你可以存储随时间改变的数据在data中，并且在每分钟发送当前的数据报（包含有最新的数据）。然而，更重要的是确保数据不被改变，当你不想它改变时。当你的程序是多线程程序时，尤其是这样，不同的线程可能写入到缓冲区。如果是这种情况，在构造DatagramPacket.之前，将数据拷贝到一个临时的缓冲区。
				比如，这个代码片断创建一个DatagramPacket，使用UTF-8编码的“This is a test”来填充。这个包被传递到www.ibiblio.org的端口7：
					String s = "This is a test";
					byte[] data = s.getBytes("UTF-8");
					try {
						InetAddress ia = InetAddress.getByName("www.ibiblio.org");
						int port = 7;
						DatagramPacket dp = new DatagramPacket(data, data.length, ia, port);
						// send the packet...
					} catch (IOException ex)
					}
				大多数时候，创建一个DatagramPacket最难的部分是转换数据到字节数组中。因为这个代码片断想要发送一个字符串，它使用String对象的getBytes()方法。java.io.ByteArrayOutputStream对于准备包含在数据报中的数据也很有帮助。
		get方法
			DatagramPacket有6个方法来获取数据报的不同部分：实际的数据和头部的多个字段。这些方法大多数时候用于从网络上获取的数据包。
			public InetAddress getAddress()
				getAddress()方法返回一个包含远程主机地址的InetAddress对象，如果数据报来自于互联网，返回的地址就是发送它的远程主机的地址（源地址）。另一方面，如果数据报是在本地被创建，发送到远程主机，这个方法返回数据报要被发送到的主机的地址（目的地址）。这个方法主要用来决定发送该UDP数据报的主机的地址，以便接收者可以回复。
			public int getPort()
				getPort()返回一个指明远程端口的整数。如果这个数据报来自于Internet，这就是发送这个包的主机的端口。如果数据报是在本地被创建，用于发送到远程主机，这个端口是这个包要被发送到的远程主机的端口。
			public SocketAddress getSocketAddress()
				getSocketAddress()返回一个包含远程主机IP地址和端口的SocketAddress对象。就像getInetAddress()，如果数据报被接收自Internet，返回的地址就是发送它的远程主机的地址（源地址）。另一方面，如果数据报是在本地被创建，用于发送到远程主机，这个方法返回的地址就是数据报将要被发送到的远程主机的地址（目的地址）。你通常调用这个方法来决定发送UDP数据报的主机和端口，在回复之前。它的网络效用没有显著的和调用getAddress()和getPort()有什么不同。如果你正在使用非阻塞I/O，DatagramChannel类接收一个SocketAddress，而不是一个InetAddress和端口。
			public byte[] getData()
				getData()方法返回一个包含来自于数据报中数据的字节数组。通常有必要将字节转换成一些其他形式的数据，在它变得对你的程序有用之前。实现这个的一个方法是将字节数组转换成String。比如，给定一个从网络接收来的DatagramPacket dp,你可以将它转换成一个UTF-8字符串：
					String s = new String(dp.getData(), "UTF-8");
				如果数据报不包含文本，将它转换成java数据有些不同。一个方法是转换getData()返回的字节数组为ByteArrayInputStream。比如，
					InputStream in = new ByteArrayInputStream(packet.getData(), packet.getOffset(), packet.getLength());
				在构造ByteArrayInputStream时，你必须指明offset和length。不要使用仅用一个字节数据作为参数的ByteArrayInputStream()的构造函数。packet.getData()返回的字节数组可能有没有被网络数据填充的额外的空间。当DatagramPacket被构造时，这些空间可能包含随机值。
				ByteArrayInputStream然后可以被串联到一个DataInputStream：
					DataInputStream din = new DataInputStream(in);
				数据然后可以被读取，使用DataInputStream的readInt(), readLong(), readChar()和其他方法。当然，这个的前提是假设数据报的发送者使用和java一样的格式。大多数现代计算机使用和java一样的浮点格式。
			public int getLength()
				getLength()方法返回数据报中数据的字节数。这个不需要和getData()返回的数组的长度相同（比如，getData().length）。getLength()返回的整数可能小于getData()返回的数组的长度。
			public int getOffset()
				这个方法简单的返回getData()返回的字节数组中，数据报中的数据的起始位置。
		set方法
			大多数时候，6个构造函数足够用来创建数据报。然而，java也提供了很多用来改变数据，远程地址，远程端口的方法，在数据报已经被创建之后。这些方法可能在创建或回收新的DatagramPacket对象是一个很明显的性能点的场景下很有用。在一些情况下，重用对象要明显比创建新的要快。然而，为了让这个改进有效果，你需要使用一个很快的网络，相比于一个较慢的网络。
			public void setData(byte[] data)
				setData()改变了UDP数据报的内容。如果你正在发送一个很大的文件（比能正好填充一个数据报大的就叫很大）到远程主机，你可能会使用这个方法。你可以重复的发送相同的DatagramPacket对象，每次只改变它的内容。
			public void setData(byte[] data, int offset, int length)
				这个setData()的重载方法，提供了一个替代方法来发送大量的数据。相替代于发送大量的新的数组，你可以将所有的数据放到一个数组中，每次发送它的一部分。比如，这个循环以每次512-byte块的大小来发送一个大的数组。
					int offset = 0;
					DatagramPacket dp = new DatagramPacket(bigarray, offset, 512);
					int bytesSent = 0;
					while (bytesSent < bigarray.length) {
						socket.send(dp);
						bytesSent += dp.getLength();
						int bytesToSend = bigarray.length - bytesSent;
						int size = (bytesToSend > 512) ? 512 : bytesToSend;
						dp.setData(bigarray, bytesSent, size);
					}
				另一方面，这个策略要求或者有足够的信息，数据实际上将会到达，或者可以忽视数据不能到达的结果。附加序列号或其他可靠性标志到独立的包相对比较困难，当你使用这个方法时。
			public void setAddress(InetAddress remote)
				setAddress()方法改变数据报将要被传送到的地址。这允许你发送相同的数据报到不同的接受者。比如：
					String s = "Really Important Message";
					byte[] data = s.getBytes("UTF-8");
					DatagramPacket dp = new DatagramPacket(data, data.length);
					dp.setPort(2000);
					int network = "128.238.5.";
					for (int host = 1; host < 255; host++) {
						try {
							InetAddress remote = InetAddress.getByName(network + host);
							dp.setAddress(remote);
							socket.send(dp);
						} catch (IOException ex) {
							// skip it; continue with the next host
						}
					}
				这个是否是一个合理的选择依赖于你的应用。如果你尝试着发送到一个网段的所有主机，就像这个代码段一样，使用本地广播地址，并且让网络来做可能会更好。本地网络地址是通过将IP地址的网络和子网ID后的所有位都设置为1.比如，Polytechnic University的网络地址是128.238.0.0，相应的，它的广播地址是128.238.255.255，发送一个数据报到128.238.255.255，会拷贝它到那个网络上的所有主机。虽然有些路由器或防火墙会阻塞它，根据它的来源。
				对于范围更广的单独的主机，使用多播可能会更好。多播通常使用这里描述的相同的DatagramPacket类。然而，它使用不同的IP地址，以及一个MulticastSocket来替代DatagramSocket。
			public void setPort(int port)
				setPort()改变数据报将要被发送到的端口。我确实想不到很多这个方法的用法。它可能被用于端口扫描应用，那些找到运行特定的基于UDP的服务，比如FSP，的打开的端口。其他的可能性可能是一些网络游戏，或会议服务，那时客户端需要从不同的端口，及不同的主机接收相同的信息。在这种情况下，setPort()会和setAddress()联合使用来改变目的地，在发送相同的数据报出去之前。
			public void setAddress(SocketAddress remote)
				setSocketAddress()方法改变数据报将要被发送到的地址和端口。你可以在回复时使用它。比如，这个代码片段接收一个数据报，并用一个包含“Hello there”字符串的数据报响应回相同的地址：
					DatagramPacket input = new
					DatagramPacket(new byte[8192], 8192);
					socket.receive(input);
					DatagramPacket output = new DatagramPacket("Hello there".getBytes("UTF-8"), 11);
					SocketAddress address = input.getSocketAddress();
					output.setAddress(address);
					socket.send(output);
				你可以使用InetAddress对象和端口来替代SocketAddress，那样代码只是有点长而已。
			public void setLength(int length)
				setLength()方法改变内部缓冲区中数据的字节数，他们被认为是数据报数据的一部分，与未填充的空间截然相反。这个方法在你接收数据报时很有用。当一个数据报被接受，它的长度被设置为进来的数据的长度。这就意味着如果你尝试着接收其他的数据报到相同的DatagramPacket，它被限制为比第一个更少的字节数。那就是，一旦你接收了一个10字节的数据报，所有后续的数据报将被截断为10字节。一旦你接收了一个9字节的数据报，所有后续的数据报都被截断为9字节，等等。这个方法允许你重新设置缓冲区的长度，以使后续的数据报不会被截断。
	DatagramSocket类
		为了发送或接收一个DatagramPacket，你必须打开一个数据报套接字。在java中，一个数据报套接字被通过DatagramSocket来创建和访问：
			public class DatagramSocket extends Object
		所有的数据报套接字绑定到一个本地端口，在该端口上监听进来的数据，该端口被设置在发送出去的数据报的头部。如果你正在写一个客户端，你不用关心本地端口是哪个，所以你调用一个构造函数，来让系统为你分配一个可用的端口。这个端口号被放置在任何出去的数据报中，并且被服务器端使用来定位响应数据报的目的地。如果你正在编写一个服务器端，客户端需要知道服务器端正在监听进来数据的端口。因此，当一个服务器端构造一个DatagramSocket，它指明它将监听的本地端口。服务器端和客户端使用的套接字基本是相同的，他们只是在是否使用一个匿名端口或著名端口上。服务器端套接字和客户端套接字没有什么不同，就像他们在TCP中一样。没有DatagramServerSocket
这个东西。
		构造函数
			DatagramSocket构造函数被用于不同的场景，很像DatagramPacket的构造函数。第一个构造函数在一个匿名的本地端口上打开一个数据报套接字。第二个构造函数在一个监听所有本地网络接口的著名端口上打开一个数据报套接字。接下来的两个构造函数在指定网络接口的一个著名端口上打开一个数据报套接字。远程地址和端口被存储在DatagramPacket中，而不是DatagramSocket中。一个DatagramSocket可以从多个远程主机和端口发送和接受数据。
			public DatagramSocket() throws SocketException
				这个构造函数创建一个邦定到匿名端口的套接字.比如:
					try {
						DatagramSocket client = new DatagramSocket();
						// send packets...
					} catch (SocketException ex) {
						System.err.println(ex);
					}
				为初始化一个和服务器端的回话的客户端选择这个构造函数.在这种场景下,你不需要关心套接字邦定到哪个端口,因为服务器端会将响应发回到数据报初始产生的那个端口.让系统分配一个端口,意味着你不需要为找到一个不使用的端口来担心.如果因为某些原因,你需要知道本地端口,你可以通过getLocalPort()来得到.
				相同的套接字可以接收服务器端发回的数据报.如果套接字不能绑定到一个端口,构造函数将抛出一个SocketException.这个构造函数抛出一个异常不是常事.
			public DatagramSocket(int port) throws SocketException
				这个构造函数创建一个在指定端口上监听进来的数据报的套接字,由port参数来指定.使用这个构造函数来编写一个监听在著名端口上的服务器端.如果套接字不能被创建,一个SocketException将被抛出.这个构造函数失败,通常会有两个原因:
指定的端口已经被占用, 或者你尝试连接到一个1024以下的端口,并且你没有足够的权限.
				TCP端口和UDP端口是不相关的.两个不同的程序可以使用相同的端口号,如果一个使用TCP端口,一个使用UDP端口.关于一个监听的端口已经接收了你的TCP数据报,通常会有一些迹象,不管应用层协议是什么,但UDP协议不提供这样的保证.为了证明一个UDP服务器端正在监听,你需要发送一个它能理解,并且响应的数据报.
			public DatagramSocket(int port, InetAddress interface) throws SocketException
				这个构造函数主要用于多地址的主机.它创建一个在指定网络接口和端口上监听进来的数据报的套接字.port参数是该套接字用于监听数据报的端口.就像TCP套接字一样,要创建一个监听在1024端口以下的DatagramSocket,你需要有root权限.
address参数是一个InetAddress对象,映射到主机的某一个网络地址.如果套接字不能被创建,一个SocketException将被抛出.这个构造函数失败通常有三个原因:
指定的端口被占用,你尝试着使用1024以下的端口,并且你没有权限,
或address并不是系统的某一个网络接口的地址。
			public DatagramSocket(SocketAddress interface) throws SocketException
				这个构造函数和前一个很相似，除了网络接口地址和端口是从SocketAddress来读取。比如，这个代码片断创建了一个监听在本地回环地址上的套接字：
					SocketAddress address = new InetSocketAddress("127.0.0.1", 9999);
					DatagramSocket socket = new DatagramSocket(address);
			protected DatagramSocket(DatagramSocketImpl impl) throws SocketException
				这个构造函数允许子类提供他们自己的UDP协议的实现，而不是盲目的接受默认的实现。不像其他四个构造函数创建的套接字，这个套接字没有被初始的邦定到一个端口。在使用它之前，你需要使用bind()方法来将它邦定到一个SocketAddress：
					public void bind(SocketAddress addr) throws SocketException
				你可以给这个方法传递null，将套接字邦定到任何可用的地址和端口。
		发送和接收数据报
			DatagramSocket类的主要目的是发送和接收数据报。一个套接字可以同时发送和接收。甚至，它可以在同一时间，与多个主机进行发送和接收。
			public void send(DatagramPacket dp) throws IOException
				一旦一个DatagramPacket被创建，以及一个DatagramSocket被构造。通过将数据报传递给套接字的send()方法来发送它。比如，如果theSocket是一个DatagramSocket对象，theOutput是一个DatagramPacket对象，使用Socket来发送theOutput就像这样：	
					theSocket.send(theOutput);
				如果在发送数据时有问题，这个方法将抛出一个IOException。然而，这对于DatagramSocket更不常见，相比于Socket或ServerSocket，因为UDP的不可靠特性意味着你将不能得到一个异常，如果只是因为数据报不能到达它的目的地。如果你尝试发送一个比主机的网络软件支持的数据报大的数据报，你可能得到一个IOException，但是也有可能不会。这个严重依赖于操作系统的原生UDP软件，以及原生软件和java的DatagramSocketImpl类之间的原生代码。如果SecurityManager不允许你和数据报将要被发送到的主机通信，这个方法也会抛出一个SecurityException。这个对于applet和其他远程加载的代码来说是个主要的问题。
			public void receive(DatagramPacket dp) throws IOException	
				这个方法从网络接收一个单独的数据报，并且将它存储在已经存在的DatagramPacket对象dp中。就像ServerSocket类中的accept()方法，这个方法会阻塞调用线程，直到一个数据报到达。如果你的程序除了等待一个数据报之外，还要做其他事情，你应该在一个单独的线程中调用receive()。
				数据报缓冲区应该足够大，来保存接收到的数据。如果不是，receive()尽它所能，放置尽可能多的数据，剩下的会丢失。记住，UDP数据报数据部分的最大大小是65507字节。这是IP数据报的最大大小65536，减去20个字节的IP头，和8个字节的UDP头。一些使用UDP的应用协议更进一步限制一个包中的最大字节数。比如，NFS使用的最大包大小是8192字节。
				如果在接受数据时有问题，receive()会抛出一个IOException。实际上，这个很少见，像可能停止TCP流的丢失包问题被网络或网络栈安静的丢弃，在java看到他们之前。		
				当每个数据报被收到时，DatagramPacket的长度被设置成为那个数据报中数据部分的长度。因此，在每个循环的最后一步，包的长度被重设为最大可能的值。否则，进来的包将会被限制到所有前面的包的最小大小。
			public void close()
				调用DatagramSocket的close()方法，释放那个套接字占用的端口。就像流和TCP套接字，你可能想要小心的关闭数据报套接字，在一个finally块中：
				DatagramSocket server = null
				try {
					server = new DatagramSocket();
					// use the socket...
				} catch (IOException ex) {
					System.err.println(ex);
				} finally {
					try {
						if (server != null) server.close();
					} catch (IOException ex) {
					}
				}
				在java 7中，DatagramSocket实现了AutoCloseable，因此，你可以使用try-with-resources：
					try (DatagramSocket server = new DatagramSocket()) {
						// use the socket...
					}
				当你使用完一个DatagramSocket时关闭它，从来都不是一个坏主意。如果程序还要继续运行很长的时间，那么关闭一个不再需要的套接字相当重要。如果程序在你用完DatagramSocket时立即结束，你不需要显式的关闭套接字，套接字被自动关闭，知道垃圾收集。然而，java并不会只因为你用完了端口或套接字，而运行垃圾收集，除非运气好，此时正好内存用完，触发了一次垃圾收集。关闭一个不需要的套接字从来没有什么坏处，并且是一个很好的编程时间。
			public int getLocalPort()
				DatagramSocket的getLocalPort()方法返回一个代表套接字正在监听的本地端口的整数。如果你使用匿名端口创建了一个DatagramSock，并且想要找出被分配的端口号，可以使用这个方法：
					DatagramSocket ds = new DatagramSocket();
					System.out.println("The socket is using port " + ds.getLocalPort());
			public InetAddress getLocalAddress()
				DatagramSocket的getLocalAddress()方法返回一个代表套接字绑定到的本地地址的InetAddress对象。在实践中，它很少被需要。通常，你或者已经知道，或者简单的不关心套接字正在监听的地址。
			public SocketAddress getLocalSocketAddress()
				getLocalSocketAddress()方法返回一个SocketAddress对象，它封装了套接字绑定到的本地接口和端口。就像getLocalAddress()，很难想到一个实际的用例。这个方法存在可能只是为了和setLocalSocketAddress()平行。
		管理连接
			不像TCP套接字，数据报对于他们将要和谁通话没有那么挑剔。实际上，默认的，他们将和任何人通话，但这通常不是你想要的。比如，applet只被允许从它来自的主机接收或发送数据报。一个NFS或FSP客户端应该只从他们通话的服务器接收包。一个网络游戏应该只接收和他们一起玩游戏的人发送的数据报。下面的5个方法允许你选择，你可以从哪个主机接收数据，或向哪个主机写出数据，拒绝其他所有的包。
			public void connect(InetAddress host, int port)
				connect()方法并没有像TCP中那样建立一个连接。然而，它指定了DatagramSocket将只发送数据报到，或从指定的主机的指定端口接收数据报。尝试这发送或接收数据报到一个不同的主机或端口，将抛出一个IllegalArgumentException。从不同的主机，或不同的端口接收到的数据报将被丢弃，而没有任何异常或通知。
				当connect()方法被调用时，将会有一个安全检查。如果VM允许发送数据到那个主机或端口，检查安静的通过。如果不是，一个SecurityExcep
tion被抛出。然而，一旦连接被建立，在那个DatagramSocket上的send()和receive()将不再进行安全检查。
			public void disconnect()
				disconnect()方法打断一个连接的DatagramSocket的“连接”，以使它可以再一次发送或接收数据，从任意主机或端口。
			public int getPort()
				如果，并且只有如果，一个DatagramSocket是连接的，getPort()方法返回它连接到的远程端口。否则，它返回-1.
			public InetAddress getInetAddress()
				如果，并且只有如果，一个DatagramSocket是连接的，getInetAddress()方法返回它连接到的远程主机的地址。否则，它返回null。
			public InetAddress getRemoteSocketAddress()
				如果一个DatagramSocket是连接的，getRemoteSocketAddress()方法返回它连接到的远程主机的地址。否则，它返回null。
	套接字选项
		java针对UDP支持6个套接字选项:
			• SO_TIMEOUT
			• SO_RCVBUF
			• SO_SNDBUF
			• SO_REUSEADDR
			• SO_BROADCAST
			• IP_TOS
		SO_TIMEOUT
			SO_TIMEOUT是在抛出一个InterruptedIOException之前,receive()方法等待进来的数据报的毫秒数,它是IOException的子类.它的值必须是非负值.如果SO_TIMEOUT的值为0,receive()方法将永不超时。这个值可以通过setSoTimeout()方法来改变，getSoTimeout()方法来检测它的值：
				public void setSoTimeout(int timeout) throws SocketException
				public int getSoTimeout() throws IOException
			默认值是永不超时，并且确实很少有你需要设置SO_TIMEOUT的情况。你可能需要它，如果你正在实现一个安全的协议，你需要响应在一个固定的时间之内发生。你可能也需要决定正在进行通信的主机挂掉（不可达或没有响应），如果你不能在一个特定的时间之内接收到响应。setSoTimeout()方法为一个数据报套接字设置SO_TIMEOUT，当阻塞发生，阻塞的receive()抛出一个SocketTimeoutException。在你调用receive()之前设置这个属性。当receive()正在等待一个数据报时，你不能改变它。timeout参数必须大于或等于0。
				try {
					byte[] buffer = new byte[2056];
					DatagramPacket dp = new DatagramPacket(buffer, buffer.length);
					DatagramSocket ds = new DatagramSocket(2048);
					ds.setSoTimeout(30000); // block for no more than 30 seconds
					try {
						ds.receive(dp);
						// process the packet...
					} catch (SocketTimeoutException ex) {
						ss.close();
						System.err.println("No connection within 30 seconds");
					} 
				}catch (SocketException ex) {
					System.err.println(ex);
				} catch (IOException ex) {
					System.err.println("Unexpected IOException: " + ex);
				}
			getSoTimeout()方法返回DatagramSocket对象的SO_TIMEOUT字段的当前值。比如：
				public void printSoTimeout(DatagramSocket ds){
					int timeout = ds.getSoTimeOut();
					if (timeout > 0) {
						System.out.println(ds + " will time out after " + timeout + "milliseconds.");
					} else if (timeout == 0) {
						System.out.println(ds + " will never time out.");
					} else {
						System.out.println("Something is seriously wrong with " + ds);
					}
				}
		SO_RCVBUF
			DatagramSocket的SO_RCVBUF和Socket的SO_RCVBUF选项很像。它决定了用于网络I/O缓冲区的大小。对于相对更快的连接，更大的缓冲区可以提升性能，因为在溢出之前，他们可以存储更多的进来的数据报。足够大的缓冲区对于UDP会更重要，相对于TCP来说，因为当一个UDP数据报到达时，如果接收缓冲区是满的，那么该数据报将被丢弃，然而，当一个TCP数据报到达时，如果缓冲区是满的，最后这个数据报将被重传。更进一步，SO_RCVBUF设置了应用可以接收到的数据包的最大大小。不能被填充到缓冲区的数据包都被安静的丢弃。
			DatagramSocket有方法来为网络输入设置或获取被建议的接收缓冲区大小：
				public void setReceiveBufferSize(int size) throws SocketException
				public int getReceiveBufferSize() throws SocketException
			setReceiveBufferSize()方法建议一个用于套接字输入的缓冲区的大小。然而，底层的实现可以自由的忽略这个建议。比如，很多BSD
4.3衍生的系统有一个最大512K的接收缓冲区，并且不允许你设置一个大于该值的限制。其他系统提升这个值到大约240K。具体细节是平台相关的。因此，你可能想要在设置它之后，使用getReceiveBufferSize()来检测接收缓冲区的真实地值。getReceiveBufferSize()方法返回用于从套接字接收的缓冲区的字节数。
			如果底层的实现不能识别SO_RCVBUF选项，这两个方法都会抛出一个SocketException。这个可能发生在一个非Posix操作系统上，如果参数是一个小于或等于0的数，setReceiveBufferSize()将抛出一个IllegalArgumentException。
		SO_SNDBUF	
			DatagramSocket有方法用于获取或设置建议的用于网络输出的发送缓冲区的大小：
				public void setSendBufferSize(int size) throws SocketException
				public int getSendBufferSize() throws SocketException
			setSendBufferSize()方法建议了一个用于套接字上缓冲输出的字节大小。再一次，操作系统可以自由的忽视这个建议。因此，你可能想要在setSendBufferSize()之后，紧跟着一个getSendBufferSize()来查看正真的缓冲区的大小。
			如果底层的原生网络软件不支持SO_SNDBUF选项，两个方法都抛出SocketException。如果参数小于或等于0，setSendBufferSize()也抛出一个IllegalArgumentException。
		SO_REUSEADDR
			对于UDP套接字，SO_REUSEADDR选项意味的东西和TCP套接字不一样。对于UDP，SO_REUSEADDR用于控制多个数据报套接字，在同一时间，是否可以绑定到相同的端口和地址。如果多个套接字绑定到相同的端口，接收到的包将被拷贝到所有绑定的套接字。这个选项被两个方法控制：
				public void setReuseAddress(boolean on) throws SocketException
				public boolean getReuseAddress() throws SocketException
			为了这个可靠的工作，setReuseAddress()方法必须在新的套接字绑定到端口之前被调用。这意味着套接字必须要用用一个DatagramImpl作为参数的受保护的构造函数，来创建在未连接的状态。可重用端口通常被用于多播套接字。数据报通道也可以创建未连接的数据报套接字，可以被配置为重用端口。
		SO_BROADCAST
			SO_BROADCAST选项控制一个套接字是否被允许发送数据报到，以及接收数据报从，广播地址，比如192.168.254.255，对于本地地址为192.168.254.*的网络来说是本地网络广播地址。UDP广播通常被用于协议，像DHCP，那些需要和本地网络上的服务器进行交互，但是那些服务器的地址又不知道。这个选项由这两个方法控制：
				public void setBroadcast(boolean on) throws SocketException
				public boolean getBroadcast() throws SocketException
			路由器和网关通常不会转发广播消息。这个选项默认是打开的，但是如果你喜欢，你可以禁止它：
				socket.setBroadcast(false);
			这个选项可以在套接字被绑定之后被改变。
			在一些实现中，绑定到指定地址的套接字不接收广播包。换句话说，你应该使用DatagramPacket(int port)构造函数，而不是DatagramPacket(InetAd
dress address, int port)构造函数来监听广播。这个需要额外的设置SO_BROADCAST选项为true。
		IP_TOS
			以为通信类由每个IP头的IP_TOS字段的值来决定。对于UDP，它本质上和TCP是一样的。毕竟，包实际上是通过IP来路由和优先化的，TCP和UDP都坐落在IP之上。DatagramSocket类的setTrafficClass()和getTrafficClass()方法，和Socket中的确实没有什么不同。他们必须在这里重复是因为DatagramSocket和Socket没有共同的超类。有两个方法允许你检测和设置套接字服务的类型：
				public int getTrafficClass() throws SocketException
				public void setTrafficClass(int trafficClass) throws SocketException
			通信类被以0到255之间的整数来给出。因为这个值被拷贝到TCP头中一个8位的字段，只有整数的低8位被使用，超过这个范围的值会导致IllegalArgumentException。
			关于这些选项的java文档严重过期，并且基于位字段的4中通信类，描述了很多的服务模式：低成本，高可用性，最大吞吐，最小延迟。这个模式从没有被广泛的实现，并且在未来也可能不会被使用。
			这个代码片段通过设置通信类为10111000，来设置套接字使用快速转发（Expedited Forwarding）：				
				DatagramSocket s = new DatagramSocket();
				s.setTrafficClass(0xB8); // 10111000 in binary
			底层的套接字实现不被要求遵循任何这些请求。一些实现完全忽略这些值。Android实际上对待setTrafficClass()为不操作。如果原生的网络栈不能提供请求的分类的服务，java可以，但是并没有要求，抛出一个SocketException。
	一些有用的应用
		当一个IP包被一个主机接收，主机通过检测IP头来决定包是一个TCP包，或是一个UDP数据报。TCP端口和UDP端口之间没有关系。TCP服务和UDP服务可以共享相同的端口，而没有问题。按照约定，如果一个服务同时有UDP实现和TCP实现，它为这两个实现使用相同的端口，虽然没有任何技术原因要求必须要这么做。
	DatagramChannel
		DatagramChannel类被用于非阻塞UDP应用，和SocketChannel和ServerSocketChannel被用于非阻塞TCP应用是一样的方法。就像SocketChannel和ServerSocketChannel，DatagramChannel是SelectableChannel的一个子类，可以注册到一个Selector。这个对于一个线程可以管理多个客户端通信的服务器端是很有用的。然而，UDP由于它的特性，它要比TCP更异步，因此网络效果会小一些。在UDP中，一个数据报套接字可以处理从多个客户端进来的输入和输出。DatagramChannel添加的功能是以非阻塞的方式来做这个，因此如果网络没有准备好发送或接收，方法会立即返回。
		使用DatagramChannel
			对于UDP，DatagramChannel是一个近乎完全替代的API。在java6和以前，你仍然需要DatagramSocket来绑定通道到一个端口。然而，在那以后你不再需要使用它，在java7及以后，你不需要再使用它。你不再使用DatagramPacket。相替代的，你读取和写出字节缓冲区，就像你对SocketChannel做的那样。
			打开一个套接字
				java.nio.channels.DatagramChannel类没有公共的构造函数。相替代的，你使用静态的open()方法来创建一个新的DatagramChannel对象。比如：
					DatagramChannel channel = DatagramChannel.open();
				这个通道初始时没有绑定到任何端口。为了绑定它，你可以使用socket()方法访问和通道结对的DatagramSocket对象。比如，这个绑定通道到端口3141：
					SocketAddress address = new InetSocketAddress(3141);
					DatagramSocket socket = channel.socket();
					socket.bind(address);
				java7直接为DatagramChannel添加了一个便利的bind()方法，所以你完全不需要使用DatagramSocket。比如：
					SocketAddress address = new InetSocketAddress(3141);
					channel.bind(address);
			接收
				receive()方法从通道读取一个数据报到一个ByteBuffer，它返回发送包的主机的地址：
					public SocketAddress receive(ByteBuffer dst) throws IOException
				如果通道是阻塞的（默认是），这个方法不会返回，直到一个包被读取。如果通道是非阻塞的，如果没有包可被读取，这个方法将立即返回。
				如果数据报有比缓冲区容量更多的数据，额外的数据会被丢弃，而没有任何的通知。你不会接收到一个BufferOverflowException或任何相似的东西。再一次，你看到了UDP是不可靠的。这个行为引入了一个额外的不可靠的层到系统中。数据可以从网络安全的到达，但可能在你自己的程序中丢失。
			发送
				send()方法从一个ByteBuffer，发送一个数据报到通道，从而发送到第二个参数指定的地址：
					public int send(ByteBuffer src, SocketAddress target) throws IOException
				源ByteBuffer可以被重用，如果你想要发送相同的数据到多个客户端。不要忘记，首先要rewind它。
				send()方法返回写出的字节数。它或者是缓冲区中可用于写出的字节数，或0，或是这两个数之间。如果通道处于非阻塞模式，并且没有数据立即可用于发送，它是0.否则，如果通道不是在非阻塞模式，send()简单的等待返回，直到它可以发送缓冲区中的所有数据。
			连接
				一旦你打开了一个数据报通道，你使用connect()方法连接到一个远程的指定的地址：
					SocketAddress remote = new InetSocketAddress("time.nist.gov", 37);
					channel.connect(remote);
				这个通道将只发送数据到，或只从该主机接收数据。不像SocketChannel的connect()方法，这个方法不会发送或接收任何包到网络上，因为UDP是一个无连接的协议。只有有数据准备好被发送时，它才和数据报要被发送到的主机建立连接。因此connect()方法返回的相当迅速。在这里，不需要有finishConnect()或isConnectionPending()方法。有一个isConnected()方法，如果，并且只有如果DatagramSocket是连接的时，它才返回true。
					public boolean isConnected()
				这个将告诉你，DatagramChannel是否被限制到一个主机。不像SocketChannel，一个DatagramChannel不需要被连接来传输或接收数据。
				最后，disconnect()方法断开连接：
					public DatagramChannel disconnect() throws IOException
				这个实际上并没有关闭任何东西，因为起初并没有任何东西被打开。它只是允许通道以后可以绑定到一个不同的主机。
			读取
				除了特殊目的的receive()方法，DatagramChannel有三个通常的read()方法：
					public int read(ByteBuffer dst) throws IOException
					public long read(ByteBuffer[] dsts) throws IOException
					public long read(ByteBuffer[] dsts, int offset, int length) throws IOException
				然而，这些方法只能被用于连接的通道。那就是，在调用这些方法中的一个之前，你必须调用connect()来绑定通道到一个特定的远程主机。这使得他们更适合适用于客户端，在那里他们知道将要和谁通话，而不像服务器端，需要在同一时间接收来自对个主机的输入，通常在第一个包到达之前，什么都不知道。
				这三个方法的每一个都从网络只读取一个数据报。来自数据报的数据被尽可能多的存储在参数ByteBuffer中。每个方法返回读取的字节数或-1，如果通道已经被关闭。这个方法返回0有很多原因，包括：
					通道是非阻塞的，并且没有包被准备好
					一个数据报没有包含数据
					缓冲区是满的
				就像receive()方法，如果数据报有比ByteBuffer的容量更多的数据，额外的数据会被丢弃，而没有任何通知。你不会收到一个BufferOverflowException或任何相似的东西。
			写出
				天生的，DatagramChannel有三个写出方法，对于所有可写的，可散播的通道，是通用的，它可以被用来替代send()方法：
					public int write(ByteBuffer src) throws IOException
					public long write(ByteBuffer[] dsts) throws IOException
					public long write(ByteBuffer[] dsts, int offset, int length) throws IOException
				这些方法将只能被用于连接的通道，否则，他们不知道向哪发送数据。这些方法的每一个都向连接发送一个单独的数据报。这些方法没有一个保证可以完全写出缓冲区中的内容。幸运的是，基于索引特性的缓冲区允许你很容易的一次又一次的调用这个方法，知道缓冲区完全被消耗完，并且数据已经被完全发送，可能使用了多个数据报。比如：
					while (buffer.hasRemaining() && channel.write(buffer) != -1) ;
			关闭
				就像常规的数据报套接字，通道在使用完之后，应该被关闭，来释放端口和任何它可能使用的任何其他资源：
					public void close() throws IOException
				关闭一个已经是关闭状态的通道没有影响。尝试着从一个已经关闭的通道读取或写出数据会抛出一个异常。如果你不确定一个通道是否被关闭，使用isOpen()来检测：
					public boolean isOpen()
				如果通道是关闭的，它返回false。如果是打开的，返回true。
				就像所有的通道，在java7中，DatagramChannel实现了AutoCloseable，因此你可以在try-with-resources块中使用它。在java7之前，如果你可以，在一个finally块中关闭它。在java6或以前：
					DatagramChannel channel = null;
					try {
						channel = DatagramChannel.open();
						// Use the channel...
					} catch (IOException ex) {
						// handle exceptions...
					} finally {
						if (channel != null) {
							try {
								channel.close();
							} catch (IOException ex) {
								// ignore
							}
						}
					}
				在java7及以后：
					try (DatagramChannel channel = DatagramChannel.open()) {
						// Use the channel...
					} catch (IOException ex) {
						// handle exceptions...
					}
			套接字选项//java7
				在java7及以后，DatagramChannel支持8个套接字选项：
		Option			Type					Constant		Purpose
		SO_SNDBUF 		StandardSocketOptions.			Integer 		用于发送数据报的缓冲区的大小
		SO_RCVBUF 		StandardSocketOptions.SO_RCVBUF 	Integer                 用于接收数据报的缓冲区的大小
		SO_REUSEADDR 		StandardSocketOptions.SO_REUSEADDR 	Boolean			允许或禁止地址重用
		SO_BROADCAST		StandardSocketOptions.SO_BROADCAST 	Boolean                 允许或禁止广播消息
		IP_TOS			StandardSocketOptions.IP_TOS 		Integer			通信分类
		IP_MULTICAST_IF 	StandardSocketOptions.IP_MULTICAST_IF	NetworkInterface        用于多播的本地网络接口
		IP_MULTICAST_TTL 	StandardSocketOptions.IP_MULTICAST_TTL  Integer 		多播数据报的TTL值
		IP_MULTICAST_LOOP 	StandardSocketOptions.IP_MULTICAST	Boolean			允许或禁止多播数据报的回环
				前5个选项，和他们在数据报套接字中有相同的意义。剩下的三个被用于多播套接字。
				他们可以通过这三个方法来检测或配置：
					public <T> DatagramChannel setOption(SocketOption<T> name, T value) throws IOException
					public <T> T getOption(SocketOption<T> name) throws IOException
					public Set<SocketOption<?>> supportedOptions()
				supportedOptions()方法列出可用的套接字选项。getOption()告诉你这些选项的当前值。setOption()允许你改变这些值。比如，你想要发送一个广播消息，SO_BROADCAST通常默认是关闭的，但是你可以像这样一样打开它：
					try (DatagramChannel channel = DatagramChannel.open()) {
						channel.setOption(StandardSocketOptions.SO_BROADCAST, true);
						// Send the broadcast message...
					} catch (IOException ex) {
						// handle exceptions...
					}
				


第13章 IP多播
	前面章节中的套接字是单一传播:他们提供点对点的通信.单一传播套接字在两个已经定义好的终点之间创建了一个连接,有一个发送者和一个接收者,虽然他们可能会交换角色,在任何给定的时间,很容易说明哪个是哪个.然而,虽然点对点通信服务于很多场合,如果不是特别需要,很多任务要求一个不同的模型.比如,一个电视基站广播数据从一个位置,到它的传输范围内的所有的点.无论电视是否是打开的,或者是否在那个频道上,信号都会到达那个电视.信号确实是到达了家里,不管是通过线缆盒或天线,或者是家里没有电视.这个是广播的经典例子,它是无差别的,并且很浪费.
	视频会议,相对应的,发送一个视频-音频反馈到一个选定的组的人.Usenet新闻从一个站点发送出来,分发到世界上数以千计的人.然而,发送站点通过中间站点来拷贝,并且传播消息到下游站点.发送者不需要为每个最终会收到该消息的主机都指定地址.这个是多播的例子,虽然他们是通过UDP或TCP上的额外的应用层协议来实现的.这些协议需要相对详细的配置,并且需要人的介入.比如,为了加入Usenet,你需要找到一个愿意发送消息给你的站点,并且传播你的向外发送的消息给其他人.为了添加你到Usenet的反馈,消息管理员需要特别添加你的站点到消息配置文件.然而,最近的开发,关于在大多数主流操作系统上的网络软件,以及网络路由器,打开了一个新的可能性-真正的多播,那时,由路由器来决定如何有效地将消息移动到单独的主机.事实上,初始路由器只发送一份拷贝到接近接收主机的路由器,后面的路由器为不同的接收者或近的路由器制作多份拷贝.网络多播构建于UDP之上.多播在java中使用DatagramPacket类,和一个新的MulticastSocket类.
	多播
		多播相对于单播和点对点通信来说范围更广，但是相对于广播来说要窄，并且更具目标性。多播从一个主机像很多不同的主机发送数据，但并不是向每一个。数据只会被传输到客户端，这些客户端通过加入一个特定的多播组来表达他们的一个兴趣。在某种程度上，这个就像一个电话会议。人们可以按自己的意愿进来或离开。在他们进来之前或离开之后，他们完全不需要处理信息，信息根本不会到达他们。在Internet上，像公共会议这种，最好是通过一个多播套接字来实现的，他们发送数据的一个拷贝到临近已经表达了对消息感兴趣的客户端的一个位置或一组位置。在最好的情况，数据只有在到达了服务感兴趣的客户端的本地网络时才进行复制：数据通过Internet时只有一份，但是，通过小心的选择流被复制的点，互联网的负载是最小的。好消息是程序员和网络管理员不需要负责来选择流被复制的点，Internet的路由器会负责处理所有的东西。
		IP也支持广播，但是广播的使用被严格的限制。协议只有在没有选择的时候才需要广播，路由器限制广播到本地网络或子网，禁止广播数据到达Internet或更大的范围。即使很少量的广播数据也会使Internet屈服。广播高带宽的数据，比如视频，音频，或即使是文本，或图片根本不可能。一个发送到数以亿计的单一的垃圾邮件就已经足够坏了。设想如果一个实时的视频反馈被拷贝到所有的百万以上的Internet用户将会发生什么，不管他们是否想要看。
		然而，在点对点通信和广播到整个世界之间有一个中间地带。发送视频反馈到对它不感兴趣的用户没有理由的。我们需要一个技术来只发送数据到对它感兴趣的主机，而不用打扰剩下的。实现这个的一种方法是使用大量的单播流。如果1000个客户想要看BBS实况流，数据被发送1000次。这个效率很低，因为它不必要的复制数据。但是它的数量级要比广播数据到Internet上的所有用户要有效。如果感兴趣的客户端的数量足够大，你最终会耗完带宽和CPU。
		解决问题的另一个办法是创建一个静态的连接树。这是被Usenet新闻和一些会议系统使用的解决方法。数据从原始站点反馈到其他服务器，这些服务器复制消息到其他服务器，最终复制到客户端。每个客户端连接到最近的服务器，这个比通过使用多个单播来将所有东西发送给感兴趣的客户端要更有效，但是这个模式很杂，并且开始显示出它的年龄（but the scheme is kludgy and beginning to show its age）。新的站点需要找到一个地方，来手动的挂载到树上。树不需要在任何时候都反映出最好的，可能的拓扑结构，服务器仍然需要维护很多到其客户端的点对点的连接，发送相同的数据到每一个。允许Internet的路由器动态的决定传输分布式消息的最好的，可能的路由，并且只有在绝对需要的时候再复制消息，是最好的。这就是多播的由来。
		比如，如果你正在从New York多播视频，并且在Los Angeles的同一LAN中的20个人在收看这个视频，反馈将只被发送到这个LAN一次。如果有50个更多的用户在San Francisco收看，数据流可能会在某个地方被复制，并且传送到这两个城市。如果有100个更多的人在Huston观看，另一个数据流将会被发送到那。数据流只通过Internet3次，而不是点对点连接要求的170次，或者不是广播要求的上亿次。多播是一个折中，相对于对于Internet来说很普通的点对点通信，以及电视的广播模型，并且比这两个都要有效。当一个包是多播时，它被定位到一个多播组，并且发送到这个组的每一个主机。它不会去到每一个单独的主机，像单播那样，也不会去到所有的主机，就像广播那样。这两个都太低效。
		当人们在谈论多播时，首先进入脑海的应用是视频和音频。确实，BBC已经运行了一个覆盖了TV和收音机的试用的多播很多年了，虽然ISP参与者被遗憾的限制。然而，视频和音频只是冰山一角。其他的可能性包括多人游戏，分布式文件系统，大量的并行计算，多人会议，数据库复制，内容传输网络，以及更多。多播可以被用来实现命名服务和目录服务，他们不需要客户端提前知道服务器端的地址。为了查找一个名字，主机可以多播它的请求到一些著名的地址，并且等待，直到一个从最近的服务器的响应被接收到。Apple的Bonjour (a.k.a. Zeroconf)和Apache的River都使用IP多播来动态的发现本地网络上的服务。
		多播被设计为尽可能无缝的符合Internet。大部分的工作被路由器来完成，并且应该对应用程序员是透明的。一个应用程序简单的发送一个数据报到一个多播地址，它从根本上跟其他单播地址不同。路由器确保包被传送到多播组的所有的主机。最大的问题是，多播路由器还不是普遍存在的，因此，你需要充分知道这些，来证明你的网络是否支持多播。事实上，多播更通常的被使用在防火墙之后的一个单一机构内，而不是跨越全局的Internet。
		拿应用自己来说，你需要注意数据报中头部的一个附加的字段TTL的值。TTL是数据报被允许跨越的路由器的最大个数。一旦一个包已经跨越了那么多的路由器，它就被丢弃。多播使用TTL来作为一个特定方式，来限制包能传输多远。
		多播地址和组
			一个多播地址是一个被称为多播组的主机的共享地址。我们先讨论这个地址。IPV4多播地址是在CIDR组224.0.0.0/4（比如，他们的范围从224.0.0.0到239.255.255.255）中的IP地址。所有这个范围内的地址都有1110的二进制位作为他们的前4位。IPV6多播地址在CIDR组ff00::/8（他们都以0xFF开始，或二进制形式11111111）中。			就像任何的IP地址，一个多播地址可以有一个主机名。比如，多播地址224.0.1.1（NTP分发服务的地址）被分配的名字为ntp.mcast.net。
			一个多播组是一个共享一个多播地址的Internet主机的集合。任何发送到多播地址的数据都被转发到组的所有成员。多播组的关系是开放的，主机可以在任何时候加入或离开组。组可以是固定的，也可以是临时的。固定组被分配的地址保持常量，不管组中是否有成员。然而，大多数的多播组都是临时的，只有在他们有成员时才存在。要创建一个多播组，你所要做的全部就是从225.0.0.0到238.255.255之间选择一个随机的地址。为那个地址构造一个InetAddress对象，并且开始向它发送数据。
			IANA负责按需要来分发固定的多播地址。至今，几百个已经被特定的分配。Link-local多播地址起始于224.0.0（从224.0.0.0开始，到224.0.0.255范围内的地址），并且被保留用于路由协议，和其他低等级的活动，比如网关发现和组成员关系报告。比如，all-systems.mcast.net, 224.0.0.1,是一个多播组，包括了本地子网内的所有的主机。多播路由器从不转发目的地在这个范围内的数据报。
			范围超出本地子网的固定分配的多播地址起始于224.1或224.2。一些大小在几十或几百的地址块已经被保留为特定的用途。虽然，你可能发现它包括很多现在已经死亡的服务，协议和公司。剩下的248十万个多播地址可以被任何需要他们的人临时使用。多播路由器负责确保两个不同的系统不会在同一时间尝试使用相同的多播地址。		
		客户端和服务器端
			当一个主机想要发送数据到一个多播组，它将数据放到一个多播数据报中，多播数据报不过是一个地址是多播组的UDP数据报。多播数据通过UDP来发送，虽然是不可靠的，但是要比面向连接的TCP快3倍。如果你仔细想想，基于TCP的多播近乎不可能。TCP要求主机响应他们已经收到了包。在多播的情况下，处理响应将是一个噩梦。如果你正在开发一个多播应用，它不能容忍数据丢失。那么就是你的责任来决定数据在传输时是否被损坏，或如何处理丢失数据的情况。比如，如果你正在构建一个分布式的缓存系统，你可能简单的不缓存没有完整到达的文件。
			更早的，我所从一个应用程序员的角度，多播和使用常规的UDP套接字的主要不同是你需要考虑TTL的值。这个是IP头中的一个单一的字节，它的值的范围从1到255.它被近似的理解为在一个包被丢弃之前，它能够通过的路由器的个数。包每通过一个路由器，它的TTL字段的值将至少减1.一些路由器可能是TTL的值减2或更多。当TTL的值为0，包就被丢弃。TTL字段最出被设计用来通过保证所有的包最终都会被丢弃来阻止路由循环。它阻止错误配置的路由器彼此之间无限的发送回或发送到。
			在IP多播中，TTL从地理上限制多播。比如，一个TTL值为16，限制包到本地区域，通常是一个组织或一个组织和它的上有和下游邻居。一个TTL的值为127，发送包到整个世界。中间的值也是可能的。然而，没有一个精确的方法来映射TTL到地理范围。通常，一个站点越远，到达它就需要穿过更多的路由器。具有较小TTL值的包没有具有较大TTL值的包传递的远。目的地址为范围在224.0.0.0到224.0.0.255之间的多播地址的包，永远不会转发到本地子网之外，无论它使用的TTL值是多少。
			一旦数据被填充到一个或多个数据报，发送主机将这些数据报发送到Internet。这个就像发送常规的UDP数据，发送主机起始于传输一个多播数据报到本地网络。这个包立即到达在相同子网内的多播组的所有成员。如果包的TTL字段的值大于1，本地网络上的多播路由器将包转发给还有多播组成员的其他网络。当包到达了其中的一个多播地址，目的网路的多播路由器将包分发给多播组的每一个成员。如果需要，多播路由器也会将包转发给处在当前路由器和最终目的地址之间的路径上的下一个路由器。
			当数据到达多播组中的一个主机，主机接受它就像接收任何其他UDP数据报一样，虽然包的目的地址和接收主机的地址不匹配。主机认出数据报确实是针对它的，因为它属于这个包被发送到的多播组的成员。接收主机必须监听在前当的端口上，准备好处理到达的数据报。
		路由器和路由
			图13-3展示了一个最简单的可能的多播配置，一个单一主机发送数据到被同一个路由器服务的4个客户端。一个多播套接字发送一个数据流到客户端的路由器，路由器复制流，并且将它发送到每一个客户端。没有多播套接字，服务器端将需要发送4个单独的，但相同的流到路由器，路由器需要路由每个流到客户端。使用相同的流来发送相同的数据到多个客户端明显的减少了需要的带宽。
			当然，现实世界的路由要更复杂，包多很多多余路由器的多个层级结构。然而，多播套接字的目标很简单，不管网络有多复杂，对于相同的网段，数据将最多只发送一次。幸运的是，你不需要担心路由问题，只需要创建一个MulticastSocket，让这个套接字加入到一个多播组，填充多播组的地址到你想要发送的DatagramPacket中。路由器和MulticastSocket类将会处理剩下的。
			多播的最大限制是特别的多播路由器的可用性。多播路由器是重新配置的，支持IP多播扩展的Internet路由器或工作站。很多面向客户的ISP故意禁止他们的路由器上的多播。到2013，仍然可以找到没有多播路由存在的主机。
			为了发送或接收多播数据到本地子网之外，你需要一个多播路由器。和网络管理员确认你的路由器是否支持多播。你也可以尝试ping
all-routers.mcast.net。如果有任何路由器响应，那么你的网络挂在在一个多播路由器上：
				% ping all-routers.mcast.net
				all-routers.mcast.net is alive
			这个仍然可能不允许你接收自或发送到每一个Internet上的具有多播能力的主机。为了使你的包到达任何给定的主机，在你的主机和远程主机之间必须存在一个多播路由器的路径。替代的，一些站点可以被一些特殊的多播通道软件连接，它会使用所有路由器理解的单播UDP来传输多播数据。如果你在使用本章的例子来产生起来的结果时有问题，咨询你的本地网络管理员或ISP，来查看你的路由器是否支持多播。
	使用多播套接字来工作
		在java中,你使用java.net.MulticastSocket类来多播数据,它是java.net.DatagramSocket的一个子类:
			public class MulticastSocket extends DatagramSocket implements Closeable, AutoCloseable
		就像你将期待的那样,MulticastSocket的行为和DatagramSocket的很像:你将你想要通过MulticastSocket发送或接收的数据放到DatagramPacket对象中.因此,我将不再重复这些基本的东西.这个讨论假设你已经知道了如何使用数据报.
		为了接收来自于远程站点的多播数据,首先使用MulticastSocket()构造函数创建一个MulticastSocket,就像其他类型的套接字那样,你需要知道监听的端口.这个代码片断打开一个监听在2300端口上的MulticastSocket:
			MulticastSocket ms = new MulticastSocket(2300);
		接下来,通过MulticastSocket的joinGroup()方法加入到一个多播组:
			InetAddress group = InetAddress.getByName("224.2.2.2");
			ms.joinGroup(group);
		这个通知在你和远程服务器之间的路由器开始给你发送数据,并且告诉本地主机应该给你传递定位给多播组的IP包给你.
		一旦你已经加入了多播组,你接收UDP数据报就像使用DatagramSocket一样.你创建一个DatagramPacket,附带一个字节数组用来缓冲数据,并且进入一个循环,在循环中通过调用继承自DatagramSocket类的receive()方法来接收数据：
			byte[] buffer = new byte[8192];
			DatagramPacket dp = new DatagramPacket(buffer, buffer.length);
			ms.receive(dp);
		当你不再想要接收数据时，通过调用套接字的leaveGroup()来离开多播组，你然后可以使用继承自DatagramSocket的close()方法来关闭套接字：
			ms.leaveGroup(group);
			ms.close();
		发送数据到一个多播地址和发送UDP数据到一个单播地址很像。你在向多播组发送数据时，不需要加入它。你创建一个新的DatagramPacket，填充数据和多播组的地址到包中，然后将它传递给send()方法：
			InetAddress ia = InetAddress.getByName("experiment.mcast.net");
			byte[] data = "Here's some multicast data\r\n".getBytes("UTF-8");
			int port = 4000;
			DatagramPacket dp = new DatagramPacket(data, data.length, ia, port);
			MulticastSocket ms = new MulticastSocket();
			ms.send(dp);
		对于这些有一个警告，多播套接字是一个足够大的漏洞。因此，和多播套接字相关的，处于SecurityManager控制之外的非信任代码不被允许作任何事情。从远程下载的代码通常只被允许向其来自的主机发送数据包或接收数据报。然而，多播套接字不允许这种类型的限制设置于他们发送或接收的包上。一旦你发送数据到一个多播套接字，你对于那些主机将接收到这些数据有很有限和不可靠的控制。因此，大多数执行远程代码的环境采取保守的方法，禁止所有的多播。
		构造函数
			构造函数很简单，你可以选择一个端口来监听，或让java给你分配一个匿名的：
				public MulticastSocket() throws SocketException
				public MulticastSocket(int port) throws SocketException
				public MulticastSocket(SocketAddress bindAddress) throws IOException
			比如：
				MulticastSocket ms1 = new MulticastSocket();
				MulticastSocket ms2 = new MulticastSocket(4000);
				SocketAddress address = new InetSocketAddress("192.168.254.32", 4000);
				MulticastSocket ms3 = new MulticastSocket(address);
			如果Socket不能被创建，所有这三个构造函数都会抛出一个SocketException。如果你没有足够的权限邦定到指定的端口，或你尝试邦定到的端口已经在使用，此时套接字不能被创建。注意，多播套接字对于操作系统层面也是一个数据报套接字，一个MulticastSocket不能占有已经被DatagramSocket占有的端口，反之亦然。
			你可以传递null给构造函数，来创建一个未邦定的套接字，它可以在后面使用bind()方法来邦定。这个对于那些只能在套接字被邦定之前设置的套接字选项很有用。比如，这个代码片断创建了一个SO_REUSEADDR被禁止的多播套接字（这个属性对于多播套接字默认通常是被允许的）。
				MulticastSocket ms = new MulticastSocket(null);
				ms.setReuseAddress(false);
				SocketAddress address = new InetSocketAddress(4000);
				ms.bind(address);
			和一个多播组通信
				一旦一个MulticastSocket被创建,他可以执行4个关键的操作:
					1. 加入一个多播组
					2. 发送数据到多播组的成员
					3. 接收多播组的数据
					4. 离开多播组
				MulticastSocket针对这4种操作都有对应的方法.没有新的方法被需要来发送或接收数据.超类DatagramSocket的send()和receive()方法，满足这些操作。你可以以任何顺序执行这些操作，例外就是你在接收组中的数据之前必须先加入组。你向多播组发送数据时，不需要加入组，你可以将发送数据和接收数据混起来进行。
				加入组
					为了加入一个组，传递一个多播组对应的InetAddress或SocketAddress，到joinGroup()方法：
						public void joinGroup(InetAddress address) throws IOException
						public void joinGroup(SocketAddress address, NetworkInterface interface) throws IOException
					一旦你已经加入到了一个多播组，你接收数据报就像你接收单播数据报一样。那就是，你建立一个DatagramPacket作为一个缓冲区，并将它传递给套接字的receive()方法。比如：
						try {
							MulticastSocket ms = new MulticastSocket(4000);
							InetAddress ia = InetAddress.getByName("224.2.2.2");
							ms.joinGroup(ia);
							byte[] buffer = new byte[8192];
							while (true) {
								DatagramPacket dp = new DatagramPacket(buffer, buffer.length);
								ms.receive(dp);
								String s = new String(dp.getData(), "8859_1");
								System.out.println(s);
							}
						} catch (IOException ex) {
							System.err.println(ex);
						}
					如果你尝试加入的地址不是多播地址（如果它不是在224.0.0.0到239.255.255.255的范围内），joinGroup()方法抛出一个IOException。
					一个单个的MulticastSocket可以加入多个多播组。关于多播组的关系信息被存储在多播路由器中，而不是对象中。在这种情况下，你将使用存储在进来的数据报中的地址来决定这个包原来打算的地址。
					相同机器，甚至相同的java程序中的多个多播套接字都可以加入到相同的组。如果是这样，每个套接字都可以接收到一个到达本地主机的，定位到那个组的数据的一个完整的拷贝。
					第二个参数允许你只在指定的网络接口上加入多播组。比如，这个代码片断尝试着在命名为eth0的网络接口上，加入IP地址为224.2.2.2的组，如果这样一个接口存在。如果这个接口不存在，它会在所有可用的网络接口上加入多播组：
						MulticastSocket ms = new MulticastSocket();
						SocketAddress group = new InetSocketAddress("224.2.2.2", 40);
						NetworkInterface ni = NetworkInterface.getByName("eth0");
						if (ni != null) {
							ms.joinGroup(group, ni);
						} else {
							ms.joinGroup(group);
						}
					除了额外的参数指定监听的网络接口，这个行为很像一个参数的joinGroup()方法。比如，传递一个不代表多播组的SocketAddress对象作为第一个参数，将抛出一个IOException.
				离开组和关闭连接
					当你不再想要从一个指定的多播组接收数据时，调用leaveGroup()方法，在所有或指定的网络接口上：
						public void leaveGroup(InetAddress address) throws IOException
						public void leaveGroup(SocketAddress multicastAddress, NetworkInterface interface) throws IOException
					它给本地多播路由器发送消息，告诉它停止给你发送数据报。如果你尝试离开的地址不是一个多播地址（它不在224.0.0.0到239.255.255.255之间），方法抛出一个IOException。然而，离开一个你从未加入过的组将不会有任何异常。
					基本所有的MulticastSocket中的方法都会抛出IOException，所以通常你需要将这些包装在一个try块里。在java7中，DatagramSocket实现了Autocloseable，因此你可以使用try-with-resources：
						try (MulticastSocket socket = new MulticastSocket()) {
							// connect to the
							// server...
						} catch (IOException ex) {
							ex.printStackTrace();
						}
					在java6和以前，你将想要在finally块中显式的关闭套结字，来释放套接字持有的资源：
						MulticastSocket socket = null;
						try {
							socket = new MulticastSocket();
							// connect to the
							// server...
						} catch (IOException ex) {
							ex.printStackTrace();
						} finally {
							if (socket != null) {
								try {
									socket.close();
								} catch (IOException ex) {
									// ignore
								}
							}
						}
				发送多播数据
					通过MulticastSocket发送数据和通过DatagramSocket发送数据很像。将你的数据填充到DatagramPacket，并且使用从DatagramSocket继承来的send()方法来发送它。数据被发送给属于包定位到的多播组内的每一个主机。比如：
						try {
							InetAddress ia = InetAddress.getByName("experiment.mcast.net");
							byte[] data = "Here's some multicast data\r\n".getBytes();
							int port = 4000;
							DatagramPacket dp = new DatagramPacket(data, data.length, ia, port);
							MulticastSocket ms = new MulticastSocket();
							ms.send(dp);
						} catch (IOException ex) {
							System.err.println(ex);
						}
					默认的，多播套接字使用的TTL的值为1（那就是包不会被传输到本地子网之外）。然而，你可以为单独的包改变这个设置，通过传递一个从0到255之间的一个整数到构造函数的第一个参数。
					setTimeToLive()方法设置包使用的默认的TTL的值，包通过使用从DatagramSock继承来的send(DatagramPacket
dp)方法（相对于MulticastSocket中的send(DatagramPacket dp, byte
ttl)方法）来发送。getTimeToLive()方法返回MulticastSocket的默认的TTL的值：
						public void setTimeToLive(int ttl) throws IOException
						public int getTimeToLive() throws IOException
					比如，这个代码片断设置TTL为64：
						try {
							InetAddress ia = InetAddress.getByName("experiment.mcast.net");
							byte[] data = "Here's some multicast data\r\n".getBytes();
							int port = 4000;
							DatagramPacket dp = new DatagramPacket(data, data.length, ia, port);
							MulticastSocket ms = new MulticastSocket();
							ms.setTimeToLive(64);
							ms.send(dp);
						} catch (IOException ex) {
							System.err.println(ex);
						}
				回环模式
					发送多播包的主机是否可以接收到多播包是平台相关的，那就是，他们是否回环。传递true到setLoopback()表明你不想要接收你发送的包。传递false表明你想要接收你发送的包：
						public void setLoopbackMode(boolean disable) throws SocketException
						public boolean getLoopbackMode() throws SocketException
					然而，这只是一个暗示。实现不被要求按你请求的去做。因为并不是所有的系统都遵循回环模式。如果你同时要发送和接收数据，检查是否是回环模式很重要。如果包不是回环，getLoopbackMode()方法返回ture，如果是，它返回false。
					如果系统是回环模式，但是你不想它这样，你将需要认出这些包，并且丢弃他们。如果系统不是回环模式，但是你想它是，存储你发送的包的拷贝，并且在发送他们的同时，将他们手动注入到内部的数据结构。你可以使用setLoopback()来请求你想要的行为，但是你不能指望它。
				网络接口
					在一个多地址的主机，setInterface()和setNetworkInterface()方法选择用于多播发送或接收的网络接口：
						public void setInterface(InetAddress address) throws SocketException
						public InetAddress getInterface() throws SocketException
						public void setNetworkInterface(NetworkInterface interface) throws SocketException
						public NetworkInterface getNetworkInterface() throws SocketException
					如果参数不是本地机器的一个网络接口的地址，setter方法抛出一个SocketException。不清楚为什么对于对于单播的Socket和DatagramSocket对象，网络接口在构造函数中被不可变的设置，但是对于MulticastSocket对象，网络接口是可变的，并且使用单独的方法设置。为了安全，在构造完MulticastSocket之后，立即设置网络接口，并且从此之后不要修改它。这里是你可能使用setInterface()的方式：
						try {
							InetAddress ia = InetAddress.getByName("www.ibiblio.org");
							MulticastSocket ms = new MulticastSocket(2048);
							ms.setInterface(ia);
							// send and receive
							// data...
						} catch (UnknownHostException ue) {
							System.err.println(ue);
						} catch (SocketException se) {
							System.err.println(se);
						}
					setNetworkInterface()和setInterface()有相同的目的，那就是选择用于多播发送或接收的网络接口。然而，它基于网络接口的本地名字，比如eth0，而不是绑定到那个网络接口的IP地址。如果传递的NetworkInterface不是本地机器的一个网络接口，setNetworkInterface()方法抛出一个SocketException。
					getNetworkInterface()方法返回一个MulticastSocket正在其监听数据的，代表网络接口的NetworkInterface对象。如果在构造函数中，或使用setNetworkInterface()，没有网络接口被显式的设置，他返回一个地址为0.0.0.0，索引为-1的占位对象。比如，这个代码片断打印套接字使用的网络接口：
						NetworkInterface intf = ms.getNetworkInterface();
						System.out.println(intf.getName());
		两个简单的例子	
