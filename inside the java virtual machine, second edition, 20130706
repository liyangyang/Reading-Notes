深入Java虚拟机 第二版
Java体系结构介绍
  为什么使用java
		Java是为网络设计的，它可以保证安全的、健壮的和平台无关的程序通过网络传播，运行在不同的计算机和设备上。
	网络带来的挑战和机遇
		关于平台无关性，Java的平台无关性解决了网络环境的复杂性
		关于安全性，Java可以使从网络上下载的程序以不同的定制安全级别运行
		关于健壮性，Java体系结构对健壮性有一定的保证，一些有害代码不会在java中出现。比如内存泄漏。
		关于网络移动性，Java可以在网络上传送小段的二进制代码，对象在网络上的移动性为分布式系统编程创造了新模型。
	体系结构
		Java体系结构包括四个独立但相关的技术；
			Java程序设计语言
			Java class文件格式
			Java应用编程接口（API）
			Java虚拟机
		Java虚拟机和Java API一起组成了一个平台，或称为Java运行时系统。
		Java虚拟机
			Java面向网络的核心就是Java虚拟机，它支持：平台无关性，安全性和网络移动性
			Java虚拟机规范很灵活，可以以软件方式实现，也可以硬件方式实现。
			Java虚拟机的主要任务是装载class文件和执行其中的字节码。这两个功能通过类装载器和执行引擎来完成。
			执行引擎可以有不同的实现：
				1。一次性解释字节码，下次执行重新解释
				2。即时编译器，将所有字节码编译成本低机器代码，更快也更消耗内存。
				3。自适应优化器，只是将使用频繁的字节码编译成本地机器代码。
				3。由硬件芯片组成，用本地方法执行java字节码
			Java有两种方法：java方法和本地方法（native）。本地方法有其他语言编写，编译成与处理器相关的机器代码。本地方法保存在动态链接库中，格式是各个平台专有的。Java调用本地方法时，虚拟机装在含有该方法的动态链接库，并调用这个方法。本地方法是联系Java程序和底层主机操作系统的连接方法。
			通过本地方法，java可以直接访问底层操作系统的资源，但这样程序就变成平台相关
			如果希望保证平台相关性，就只能通过java api来访问底层资源
		类装载器的体系结构
			实际上在java虚拟机中，包含多个类装载器。
			一个java程序可以有两种类装载器：启动类装载器和用户自定义类装载器。
			启动类装载器是java虚拟机实现的一部分。
			启动类装载器通常使用某种默认方式从本地磁盘中装载类，包括java api的类。
			启动类装载器也被称为原始类装载器、系统类装载器、默认类装载器
			java程序能在运行时安装用户自定义的装载器。自定义装载器可以用java语言编写。他们实际上只是运行中的java程序可执行代码的一部分。
			自定义类装载器使得在运行时扩展java应用程序成为可能。
			java虚拟机会监视被装载的类是由哪个装载器装载的。当被装载的类使用另外一个类时，虚拟机使用装载第一个类的装载器装载被引用的类。因此被装载的类默认情况下只能看到被同一装载器装载的其他类。通过这种方法，java体系结构允许在java程序中建立多个命名空间。每一个类装载器都有它自己的命名空间。
			不同命名空间中的类不能互相访问，除非应用程序显式的允许这么做。通过这种方式可以防止恶意代码。
		Java class文件
			Java class文件为java程序提供独立于底层主机平台的二进制形式的服务。
			Java class文件中的字节顺序是高位在前。
			Java class文件对网络移动性的支持 ：1。class文件设计的很紧凑；2。Java程序是动态连接和动态扩展的，只有在需要的时候才下载相应的class文件。
		Java API
			所有被装载的class文件（包括从应用程序中和java api中提取的）和所有已经装载的动态库（含本地方法）共同组成了Java虚拟机上运行的整个程序。
			Java API的class文件天生就与主机平台密切相关。
			Java程序-〉java API-〉本地方法-〉主机操作系统
			当Java API方法在进行任何有潜在危险的操作之前，都会通过查询安全管理器来检验是否得到了授权。
			安全管理器是一个为应用程序提供自定义安全策略的特殊对象。
			在java 1.2版本以后，安全管理器被访问控制器所取代，该类用来执行栈检验，以决定是否准许某种操作。
		Java程序设计语言
			Java对内存操作的约束有：强制类型转换、自动垃圾回收、数组边界检查
	Java体系结构的代价
		性能
		垃圾回收机制行为的不确定性
		线程调度规范比较松散
		要实现平台无关，也需要付出代价，即最小公分母问题。
		java程序语言是动态连接的，从一个类到另一个类的引用是符号化的。
	结论
		

平台无关
	为什么要平台无关
		Jini技术--专用于给网络带来即插即用功能的技术。
	java的体系结构对平台无关的支持
		java平台
			Java平台扮演一个运行时Java程序与其下的硬件和操作系统之间的缓冲角色。
		java语言
			java基本数据类型的值域和行为都是由语言自己定义的。
		java class文件
			java class文件可以在任何平台上创建，在任何平台上运行
		可伸缩性
			J2ME、J2SE、J2EE
	影响平台无关性的因素
		Java程序的平台无关程度依赖于作者怎样编写它
		Java平台的部署
		Java平台的版本
			java平台中保证可用的基本库集合被称为标准API，Sun定义了另外一些运行时库，把这些库作为标准版的可选项，把他们称为标准扩展API。
			java平台中的java api变动比较频繁
		本地方法
			要编写平台无关的程序，就不能直接或间接的调用不属于java api的本地方法。
			本地方法在三种情况下适用：
				1。为了使用底层主机平台的某个特性，而这个特性不能通过java api来访问
				2。为了访问一个老的系统或使用一个已有的库，而这个系统或库不是用java编写的。
				3。为了加快程序的性能，将一些时间敏感的代码用本地方法实现。
		非标准运行时库
			判断平台无关性，要看非标准运行时库是否调用了本地方法
		对虚拟机的依赖
			由于虚拟机的实现不同，编写平台无关的程序，需要遵循两个原则：
				1。不要依赖及时终结(finialization)来达到程序的正确性。
				2。不要依赖线程的优先级来达到程序的正确性。
					在较高优先级线程没有被阻塞的情况下，并没有禁止较低优先级的线程的运行。
		对用户界面的依赖
		java平台实现中的bug
		测试
			程序仍需要在所有需要运行的平台上进行测试。
	平台无关的七个步骤
		1。选择要运行的主机和设备的集合
		2。选择java版本
		3。选择java实现
		4。编写程序，只使用java api
		5。编写程序，不依赖垃圾回收器和线程优先级来达到正确性
		6。设计一个平台无关的界面
		7。在不同平台上测试
	平台无关性的策略
	平台无关性和网络移动对象
		jini的体系结构很大程序上依赖于网络移动对象

		
安全
	为什么需要安全性
		java安全模型发展的主线：
			1。1.0版本中的基本沙箱
			2。1.1版本的代码签名和认证
			3。1.2版本的细粒度访问控制
	基本沙箱
		java沙箱的基本组件：
			1。类装载器结构
			2。class文件检验器
			3。内置于java虚拟机的安全特性
			4。安全管理器及java api
		类装载器和安全管理器可以由用户自定义
		在1.0和1.1版本中，访问控制包括安全策略规范和运行时安全策略的实施，它是由称作安全管理器的对象负责的。用户可以自己定制安全管理器。
		在1.2版本中提供了默认实现的安全管理器，允许在ascii策略文件中说明安全策略。在运行时，安全管理器通过访问控制器来执行策略文件。
	类装载器体系结构
		类装载器体系结构在三个方面对沙箱起作用：
			1。可以防止恶意代码去干涉善意代码
			2。它守护了被信任的类库的边界
			3。它将代码归入某类（或称保护域），该类决定了代码可以进行哪些操作。
		防止恶意代码干涉善意代码是通过为由不同的类装载器装入的类提供不同的命名空间。这个命名空间是由虚拟机为每个类装载器维护的。
		默认情况下不同命名空间的类甚至不能察觉彼此的存在，除非显式的提供了允许他们进行交互的机制。
		命名空间中的每一个命名都被关联到方法区中的一个类型数据，这个类型数据用那个名字定义了一个类型。
		用户自定义的类装载器经常依赖其它类装载器--至少依赖虚拟机启动时创建的启动类装载器--来帮助它实现一些装载请求。
		在版本1.2以前，用户自定义类装载器可以请求其他类装载器来装载一个类，通过调用其loadClass()。也可以请求启动类装载器装载一个类，通过findSystemClass()。
		在版本1.2以后，采用双亲委派模式，除启动类装载器之外的每个类装载器都有一个双亲类装载器。当某个类装载器试图以常用方式装载一个类时，它默认先将这个任务委派给它的双亲，依次类推，直到达到启动类装载器。一般启动类装载器是这个链的最后一个类装载器。如果一个类装载器的双亲有能力装载某个类型，就装载并返回，否则，这个类装载器试图自己来装载。
		在版本1.2以前的大多数虚拟机实现中，内置的类装载器（也叫原始类装载器）负责装载本地可用的class文件，包括要运行的java程序的class文件和该程序所依赖的一些类库，这些类库包括java api的基本class文件。在版本1.2中，本地class文件的装载被分配到多个类装载器中，原先称为原始类装载器的内置装载器被重新命名为启动类装载器，只负责装载核心java api的class文件。由用户自定义类装载器负责其他class文件的装载。
		在版本1.2的java虚拟机开始运行时，应用程序启动之前，它至少创建了1个用户自定义的类装载器。所有这些类装载器被连接在一个双亲-孩子的关系链中。这个链的顶端是启动类装载器，末端是一个在版本1.2中被称为系统类装载器的装载器。它是指由java程序创建的，新的用户自定义类装载器的默认委派双亲。这个默认的委派双亲通常是一个用户自定义的装载器（被称为用户自定义，和启动类装载器相对而言，其实它是由java虚拟机的实现提供的），它装载应用程序的初始类。但是它也有可能是用户自定义的装载器，这是由java平台的设计者决定的。
		在双亲委派模式下，可以防止不可靠的代码用他们自己的版本来替代可信任的类。
		包访问权限的前提是由同一类装载器装载。
		类装载器可以拒绝装载特定的禁止类型
	class文件检验器
		class文件检验器保证装载的class文件内容有正确的内部结构，并且这些class文件相互间协调一致。
		class文件检验器只在执行前而不是执行中对字节码进行一次分析，每一次遇到一条跳转指令时都进行检验。虚拟机保证每一条跳转指令都会到达另一条合法的指令，而且这条指令在这个方法的字节码流中。
		class文件检验器要进行四趟独立的扫描来完成它的操作。第一趟是在类被装载时，检查这个class文件的内部结构，保证它能安全的编译。第二趟和第三趟是在链接时进行的，确认类型数据遵从java语言的语义，包括它所包含的所有字节码的完整性。第四趟扫描是在进行动态连接的过程中解析符号引用时进行的，确认被引用的类、字段、方法确实存在。
		第一趟：class文件的结构检查
			确认是否符合class文件的基本结构。例如，魔数。主版本号、次版本号是否由该虚拟机支持。
			class文件有没有被删节，尾部有没有附带其他字节。class文件的每个部分都声明了它的长度，可以用每个部分的长度之和和整个class文件的大小比较。
			class文件定义的类型必须符合java class文件的固定格式，这样才能被编译成方法区中的内部数据结构。
			第二三四趟扫描是在方法区中，由实现决定的数据结构上进行的。
		第二趟：类型数据的语义检查
			在这趟扫描中，检验器查看每个组成部分，确认他们是否是其所属类型的实例，他们的结构是否正确。
			检查这个类本身是否符合特定的条件。比如除Object外都有超类，final类是否被继承，常量池中的所有索引必须指向正确类型的常量池条目。
			也就是说检查一些java语言在编译时应该遵守的强制规则。
		第三趟：字节码验证
			在这趟扫描中，java虚拟机对字节流进行数据流分析，这些字节流代表的是类的方法。
			字节码流代表了java的方法，有单子节的操作码和多个操作数组成。
			每个线程都有自己的java栈，这个栈由不同的栈帧构成。
			每个方法调用获得一个自己的栈帧--栈帧其实就是一个内存片段，其中存储着局部变量和中间计算结果。
			在栈帧中，用于存储中间结果的部分被称为该方法的操作数栈。
			操作吗的操作数可能是指操作数栈中的数据，或存储在方法栈帧中的局部变量中的数据。
			字节码检验器要进行大量的检查，包括但不只是：
				1。任何路径在字节码流中都将得到一个具体的操作码
				2。局部变量初始化前不能被访问
				3。类的字段被赋予正确的值
				4。方法被传递正确的参数
				5。操作吗和操作数是合法的
			在第一二三趟扫描后，可以保证倒入的class文件结构合理，内在一致，符合java语言的限制条件，包含的字节码可以被虚拟机安全的执行
		第四趟：符号引用的验证
			java虚拟机的延迟装载策略，直到类真正被程序使用时才装载。例如，虚拟机在预先装在中找不到某个被引用类，并不在当时抛出ClassNotFoundException，而是直到这个类被运行时程序首次使用时才抛出。
			动态链接是一个将符号引用解释为直接引用的过程。
			在解析时，虚拟机执行两个基本任务：
				1。查找被引用类
				2。将符号引用替换为直接引用
			虚拟机可以记住这个直接引用，当以后有相同的引用时，可以直接使用。
		二进制兼容
			由于java程序是动态链接的，因此class文件检验器在进行第四趟扫描时，需要检查引用的兼容性。
			为了能方便的修改类库中的代码，java语言被设计成可以对一个类进行多个修改，但是并不要求重新编译依赖它的类。这样就可能导致兼容性问题。
			java语言规范声明了二进制兼容型规则，可以防止兼容性问题的发生。
	Java虚拟机中内置的安全特性
		在执行字节码时，除了第四趟扫描中对符号引用的检验，还进行其他一些内置的安全机制的检查。如：类型转换、结构化的内存访问、垃圾收集、数组边界、空引用
		java虚拟机的另一个安全特性：并未指明运行时数据空间在java虚拟机内部是如何分布的。运行时数据空间用来存储运行java程序所需要的的数据：java栈（一个线程一个），一个存储字节码的方法区，以及一个垃圾收集堆（它用来存储由运行的程序创建的对象）。
		对于每个java虚拟机的实现，由它的设计者决定用什么数据结构来表示运行时数据空间，并且将他们放在内存的哪个位置。
		调用本地方法时，java沙箱将不起作用。因此安全管理器中包含一个方法，来指明一个程序是否能装载动态链接库，因为调用本地方法时，动态链接库是必须的。
		另一个保证安全的机制是异常的结构化错误处理。
	安全管理器和java api
		安全管理器用于保护虚拟机的外部资源不被虚拟机内部运行的恶意的或有漏洞的代码侵犯。它在访问控制，对外部资源的访问控制，中其中枢作用。
		当java api进行任何可能不安全的操作时，都会向安全管理器请求许可，从而强制执行自定义的安全策略。
		java应用程序启动时，默认没有安全管理器。可以通过System.setSecurityManager()来安装。
		一般来说，如果一个受检查的动作被禁止，安全管理器的check方法将抛出一个安全异常，否则就简单的返回。
		版本1.2中的类java.lang.SecurityManager是安全管理器的默认实现。可以显式实例化并安装或者自动安装--在命令行使用-Djava.security.manager来指明安装安全管理器。
		策略文件为ASCII文件，由它来为代码来源赋予权限。代码来源由代码库的URL和签名组成。权限由类指定。
		当创建安全管理器时，解析策略文件，创建SourceCode（代码来源）和Permission（权限对象），这些对象被封装在Policy对象中，它代表了运行时的策略。
		任何时刻只能有一个Policy对象被安装。
		类装载器将类型放到保护域中，保护域封装了授予代码来源的所有权限，这些代码来源由被装载的类型代表。在版本1.2中，每一个被装载进虚拟机的类型都只属于一个保护域。这个保护域将被保存，以便在判断代码权限时使用。
		当安全管理器的chenk方法被调用时，它们中的大多数都将请求转发到一个称为AccessController的类，AccessController使用了保护域中的对象的信息。
		在版本1.2中新式的权限判定使用许可类。如checkPermission(Permission)
		安全管理器的checkPermission方法只是简单的调用AccessController的静态checkPermission方法，并将Permission传给它。因此安全管理器中真正负责安全策略的是AccessController对象。
	代码签名和认证
		用私钥对要签名的内容的散列码进行加密，并将结果和要签名的内容一起发送。
		证书机构用证书机构的私钥对公钥进行加密，得到的数字序列成为证书。由证书机构所做的签名就叫证书。
	一个代码签名示例
		jar命令示例：jar cvf friend.jar com/artima/security/friend/*.class
		jarsinger工具对jar文件进行签名
		keystore文件用来存储签名者的公/私钥对和它们的别名，这些信息都被密码保护，要访问这些信息必须要有密码。
		keytool用来生成公/私钥对，关联别名，并用密码保护这些信息。
		keytool -genkey -alias friend -keypass friend4life -validity 10000 -keystore ijvmkeym。friend为公私钥对的别名，friend4life为访问公私钥的信息需要的密码，validity为有效期10000天，ijvmkeym为生成的keystore文件的名字。另外keystore文件也可以有密码保护，当访问keystore文件时需要提供密码
		jarsinger -keystore ijvmkeym -storepass ijvm2ed -keypass friend4life friend.jar friend。使用名为ijvmkeym的keystore中的别名为friend的密钥对的私钥对friend.jar进行加密。keystore文件的访问密码是ijvm2ed，friend密钥对的访问密码为friend4life。
	策略
		java安全体系结构可以对代码授予不同层次的信任度来部分的访问系统。代码可以被授予只对他需要的资源进行访问的有限权限。
		在版本1.2的安全模型中，权限是授给代码来源的。
		访问控制策略是由抽象类java.security.Policy的子类的单个实例来表示的。
		一个应用程序只能有一个Policy对象。
		可以通过Policy.setPolicy()来改变当前的Policy。
		类装载器使用Policy来决定在将一段代码倒入虚拟机时应该给他什么样的权限。
		代码来源java.security.CodeSource，包含一个代码库java.net.URL和一个证书数组java.security.cert.Certificate。
		Certificate对象表示一个人到一个公钥的绑定（可能是代码作者和其公钥），以及另一个为这个绑定做担保的人（证书机构）。
		所有和安全管理器有关的工具和访问控制体系结构都只对证书起作用。
		keytool程序在生成密钥对时会自动生成一个自签名的证书。
		java.security.Permission对象有三个属性：类型、名字和可选的操作。类型由Permission类的名字指定。名字被封装在Permission内，可能是文件名，socket地址等。
		可以自定义Permission类
		和CodeSource关联的Permission对象被封装在java.security.PermissionCollection中
		策略文件
			安全策略是在一个ASCII策略文件中用上下文无关的文法描述的。
			一个策略文件包含多个grant子句，每个grant子句将一些权限授给一个代码来源。
			策略文件示例：
				keystore "ijvmkeym"
				grant singedBy "friend" {
					permission java.io.FilePermission "question.txt","read";
					permission java.io.FilePermission "answer.txt","read";
				}
			表示授予名为ijvmkeym的keystore中别名为friend的密钥对签名的代码段读取question.txt和answer.txt的权限。由于CodeSource中存储的是证书，所以流程可能是这样的，读取证书机构的公钥，对证书解密，拿到其担保的公钥，然后和策略文件中指定别名的密钥对中的公钥比较，来确定这段代码是不是被friend签名。更进一步可能使用该公钥和代码的签名来判断代码是否被更改过。
	保护域
		保护域定义了授予一段特定代码的所有权限，被载入虚拟机的类型都属于且仅属于一个保护域。
		类装载器知道它装载的所有类和接口的代码库和签名者。
		ProtectDomain对象由CodeSource和相应的PermissionCollection组成。将它传递给类装载器的defineClass方法，来将一段代码导入到虚拟机。defineClass定义了方法区中的类型数据和保护域的关联。该关联信息作为类型数据的一部分。
		虽然Policy对象定义了从代码来源到权限的映射，但最终还是由类装载器决定代码执行时将获得什么权限。它可以忽略权限、追加权限等。
		CodeSource可以指定代码来源以及这段代码是被什么签名的（证书）
	访问控制器
		类java.security.AccessController提供了默认的安全策略执行机制，通过栈检查来决定潜在的不安全的操作是否被允许。它的核心方法是checkPermission()，如果允许操作，简单返回，否则，抛出异常。
		每个线程有一个调用栈，栈中的每个栈帧代表一个方法，每个方法都在类中定义，类又属于某个保护域，保护域定义了类的权限。因此栈帧间接的和权限关联。关联的权限必须隐含或包含传递给checkPermission()方法的权限时，才被允许。
		checkPermission()方法自顶向下检查栈，当它遇到一个没有权限的栈帧时，就抛出异常。
		implies()方法
			implies()方法在Permission、PermissionCollection、ProtectDomain中声明，接受一个Permission类型的参数，来决定传递的Permission对象是否隐含在Permission、PermissionCollection、ProtectDomain中。
			当AccessController判断线程是否具有某个权限时，它将在该线程调用栈的每个栈帧相关联的ProtectDomain上调用implies()方法。
		栈检查示例
		一个回答“是”的栈检查
			BOOTSTRAP保护域代表了所有由启动类装载器装载的代码的权限，该保护域中的代码被赋予java.lang.AllPermission
			启动启用栈检查的应用程序命令示例：java -Djava.security.manager -Djava.security.policy=policyfile.txt -Dcom.artime.ijvm.cdrom.home=d:\books\InsideJVM\manuscript\cdrom -cp .;jars/friend.jar;jars/stranger.jar Example2a。java.security.manager代表启用安全管理器。
		一个回答“不”的栈检查
		doPrivileged()方法
			属于权限较少的保护域的方法无权调用属于较高权限的保护域的方法，相反，如果属于较高权限保护域的方法调用属于权限较低保护域的方法，就意味着它必须自动放弃某些权限。
			AccessController严格坚持要求调用栈中的所有栈帧都含有执行被请求操作的权限。
		doPrivileged()的一个无效使用
			当调用doPrivileged()方法时，就跟调用其他方法一样，都会将一个新的栈帧压入栈。在由AccessController执行栈检查时，一个doPrivileged()方法调用的栈帧标识了检查过程的提前终止。如果和调用doPrivileged()的方法（调用doPrivileged()方法的方法的保护域很关键）相关联的保护域拥有执行被请求操作的权限，AccessController将立即返回，该操作将被允许，即使栈下层（这里的栈下层相当于调用链的起始端）的代码可能没有执行这个操作的权利。
			一个方法不能授予它自己比它现在已经用doPrivileged()调用所得到的权限更多的权限。如果一个方法调用了doPrivileged()方法，相当于告诉AccessController它实现其权限的职责，AccessController将忽略它的调用者的权限。
	Java安全模型的不足和今后的发展方向
		目前，java安全模型还不能解决恶意移动代码的两个可能的活动：
			1。不断分配内存直到内存耗尽
			2。不断生成线程导致每件事都很慢
		另一个没有放入安全模型的领域是将权限映射到系统用户，代码以这个用户的名义运行。
		Java认证和授权服务（JAAS）的目的在于使得访问控制不仅仅基于授予代码库和签名者的权限，还能基于授予用户（那些执行代码的用户）的权限。
	和体系结构无关的安全性
	

网路移动性
	为什么需要网络移动性
	一种新的软件模式
	java体系结构对网络移动性的支持
		java体系结构对网络移动性的支持是和它对平台无关性和安全性的支持密不可分的。
		java体系结构为网络移动性带来的好处就是把一个单一的大二进制文件分割成小的class文件，这些class文件可以按需加载（动态链接）。
		除了动态链接外，java程序也允许动态扩展。
		class文件格式被设计的很紧凑。被称为字节码是因为每条指令只占据一个字节。
		class文件的紧凑性隐含着另外一个含义，那就是java编译器不会做太多的优化。优化常常是在代码大小和执行速度之间折中。java编译器常常把优化工作交给java虚拟机。
		jar文件可以压缩，使得可以一次在网络上传送多个class文件，大大减少了网络握手时间。
		因此，除了平台无关性和安全性对网络移动性有利外，java体系结构主要的着眼点就是减少class文件在网络的传输时间。动态链接和动态扩展允许按需下载class文件，class文件的紧凑性较少网络传输的时间，jar允许一次传输多个class文件。
	applet：网络移动性代码的示例
	Jini服务对象：网络移动对象的示例
		对象在网络上穿梭，携带定义自己的类加上表示对象状态的快照数据。
		通过对象序列化和远程方法调用（RMI），java提供了一个在本地对象模型上扩展而成的分布式对象模型。
		Jini系统是以“查找服务”为中心的，其他服务在查找服务中注册，客户从查找服务中获取一个服务对象的拷贝。
		Jini是什么
			jini的思维中，网络是由服务组成的。
		Jini如何工作
			运行时基础结构在网络的三个部分存在：网络上的查找服务、服务提供者和客户机
			运行时基础结构采用一种网络级协议--称为“探索”，以及两种对象级服务--“加入”和“查找”
			探索过程：一连上网，服务提供者就开始广播一个关于自己存在的通知，具体方法是向一个公开的端口发送组播包。在存在通知中，它会通报自己的ip和端口。查找服务在公开端口上监听存在通知。通过存在通知包，来判断是否和服务提供者取得联系。通过通知包中的ip和端口和服务提供者提供直接的TCP连接。查找服务使用RMI来发送一个叫做服务注册器的对象给服务提供者。服务注册器对象用来和查找服务建立更进一步的联系。服务提供者通过服务注册对象向查找服务发出join或lookup的操作。
			加入过程：服务提供者通过调用服务注册对象的register()方法来完成注册，它传递一个服务条目作为参数，服务条目中包含一些描述这个服务的对象。register()方法将服务条目的一个拷贝传递回查找服务，查找服务负责保存所有的服务条目。服务条目包含几个对象，其中一种是服务对象，服务对象通常实现一个或多个接口，客户机藉此和服务提供者交互。
			查找过程：客户机通过调用服务注册器上的lookup()方法来进行查找。客户机给lookup()方法传递一个叫做服务模板的参数，这是一个表示搜索条件的对象。服务模板可以包含一个指向class对象数组的引用，这些class对象表明客户机需要的服务对象的java类型。服务模板可以包含一个服务编号（唯一的指定服务对象），或属性（必须和服务条目中列出的属相相同）。服务模板的任何字段都可以包含通配符。一般来说，客户机通过java类型（通常是接口）来查找服务。
		服务对象的优点
			Jini系统中，网络移动对象可以移动到任何地方。
			Jini体系带来的一个基本优点是：接口和实现分离
			Jini体系的一个重要推论是：在服务对象代理和远程服务器之间使用的网络协议，客户机无需关心。完全由服务对象屏蔽。它只需和服务对象实现的公开接口打交道，服务对象负责任何需要进行的网络交流。
			Jini试图提升分布式系统编程的抽象级别，从网络协议级别提升到对象接口级别。
			通过为分布式系统编程提升抽象层次和提供清晰的分离接口和实现，Jini带来了面向对象的好处。
	网络移动性：Java设计的中心
		网络移动的java代码需要自定义的类装载器进行装载，提供单独的命名空间来防止恶意代码，通过安全管理器和控制器来建立网络代码的安全政策。
		
			
Java虚拟机
	Java虚拟机是什么
		当提到java虚拟机时，可能是三种不同的东西：1。抽象规范	2。一个具体的实现	3。一个运行中的虚拟机实例
	Java虚拟机的生命周期
		每个java程序都运行在它自己的虚拟机实例中
		现实中一个java虚拟机实现的例子是Java SDK的java程序。
		Java虚拟机内部有两种线程：守护线程和非守护线程
	Java虚拟机的体系结构
		在Java虚拟机规范中，一个虚拟机实例的行为是分别按照子系统、内存区、数据类型以及指令这几个术语来描述的。
		class文件-->类装载器子系统<-->运行时数据区（方法区、堆、java栈、pc寄存器、本地方法栈）<-->执行引擎<-->本地方法<--本地方法库。本地方法也需要和运行时数据区打交道。执行引擎负责执行装载的类的方法的指令。
		运行时数据区结构上的细节，大多由具体实现的设计者决定。
		每个虚拟机实例都有一个方法区和堆，它们是所有线程共享的。方法区存放类型信息，堆中存放创建的对象。
		每个线程都有自己的pc寄存器和java栈。线程执行java方法（非本地方法）时，pc寄存器指向下一条将要执行的指令，java栈存储线程中java方法调用的状态，包括局部变量、参数、返回值、中间结果等。本地方法的调用状态则是以依赖于具体实现的方式存储在本地方法栈中，也可能是寄存器或其他某些与特定实现相关的内存中。
		java栈是由许多栈帧组成，每个栈帧包含一个java方法的调用状态。
		正在执行本地方法的线程的pc寄存器的值是不确定的。
		java虚拟机没有寄存器（不同于前面提到的pc寄存器），其指令集使用java栈来存储中间数据。这样设计一方面保持了指令集尽量紧凑，另一方面便于虚拟机在那些只有很少通用寄存器的的平台上实现，另外也有助于某些虚拟机实现的即时编译器和动态编译器的代码优化。
		数据类型
			数据类型和运算是由虚拟机规范严格定义的。
			虽然java虚拟机把boolean当作基本类型，但指令集对boolean只有很有限的支持。当编译器把源码编译成字节码时，会用int或byte表示boolean。在java虚拟机中
			false是由整数零来表示的，所有非整数零都表示true。设计boolean值的操作则会使用int。另外，boolean数组是当作byte数组来访问的，但是在堆区，它也可以被表示为位域。
			java虚拟机还有一个只在内部使用的基本类型：returnAddress，它被用来实现java程序的finally子句。它的值是同一方法中，某操作码的地址。
			三种引用类型：类类型、接口类型、数组类型。在虚拟机中数组是个真正的对象。null是一种特殊的引用。
			虚拟机规范定义了每种基本类型的取值范围，但并没有定义它们的位宽。占位宽度由具体实现决定。
		子长的考量
			java虚拟机中最基本的数据单元就是字（word），它的大小有实现者决定。通常根据底层主机平台的指针长度来选择字长。
			运行时数据区的大部分内容，都是基于字的。比如，关于栈帧的两个部分：局部变量和操作数栈，都是按照字定义的。
			java程序不能侦测虚拟机字长的大小，同样，字长的大小也不会影响程序的行为。
		类装载器子系统
			类装载器子系统负责查找和装载类型。
			虚拟机有两种类装载器：启动类装载器和用户自定义类装载器。不同类装载器装载的类型放在不同的命名空间。
			装载、连接以及初始化
				装载：查找并装载类型
				连接：验证（验证合法性）、准备（为类变量分配内存，并将其初始化为默认值）、解析（把类型中的符号引用转换为直接引用，可选）
				初始化：把类变量初始化为正确的值
			虚拟机规范未规定启动类装载器如何查找class文件，由具体实现决定。
			在JDK1.2中，启动类装载器只在系统类（java api）的安装路径中查找要装入的类。查找classpath目录的任务，由系统类装载器完成，它也是一个自定义装载器，在虚拟机启动时自动创建。
			每个虚拟机实现必须保证ClassLoader的defineClass方法能够把新类型导入到方法区。
			ClassLoader.findSystemClass()在版本1.2以前指定由启动类装载器来装载指定类，在版本1.2和以后指定由系统类装载器来装载指定类。
			当defineClass方法返回一个class实例时，表示该类型已经被装载到方法区，但是不一定被连接和初始化了。ClassLoader.resolveClass()接受Class的实例，对其进行连接操作。
			装载器在装载类型时，在其前面加上装载该类型的装载器的标识（指明它所属的命名空间）
		方法区
			类型中的静态变量也存储在方法区中
			因为方法区是所有线程共享，对它的访问被设计为线程安全的。
			方法区的大小不必是固定的，也不必是连续的，它可以在堆中（甚至是虚拟机自己的堆中）自由分配。
			方法区也可以被垃圾收集
			在虚拟机和class文件中，类型名总是以全限定名出现。
			对于装载的类型，虚拟机在方法区存储如下信息：
				这个类型的全限定名
				这个类型的直接超类的权限定名
				这个类型的直接超接口的权限定名的有序列表
				这个类型是接口还是类
				这个类型的访问修饰符	
			除了上面的基本信息外，虚拟机还会为被装载的类型存储：
				该类型的常量池
				字段信息
				方法信息
				除常量以外的所有类（静态）变量
				一个到类ClassLoader的引用
				一个到Class类的引用
			常量池
				虚拟机为每个类型维护一个常量池，常量池中包括直接常量（String、float等）和对其他类型、字段和方法的符号引用。池中的数据项像数组一样通过索引访问。
			字段信息
				字段在方法区中保存字段名、字段的类型、字段的修饰符。字段在接口或类中的声明顺序也会被保存。
			方法信息
				方法信息的清单：
					方法名
					方法的返回类型
					方法参数的类型和数量（按声明顺序）
					方法的修饰符
				方法的声明顺序也应保存
				如果方法不是抽象的或本地的，还应保存：
					方法的字节码
					操作数栈和该方法的栈帧中局部变量区的大小
					异常表
			类（静态）变量
				虚拟机在使用类之前，必须在方法区中为类变量分配空间
				对于编译时常量（用final修饰或用编译时已知的值初始化的类变量），每个使用它的类都会将它们拷贝到自己的常量池或嵌入到它的字节码流中，因此他们也在方法区中。但一般的类变量作为声明他们的类型的一部分而保存，编译时常量作为使用它们的类型的一部分而保存。
			指向ClassLoader类的引用
				如果类型是由自定义装载器装载的，虚拟机必须在类型信息中存储对该装载器的引用。这是作为方法表中类型数据的一部分而保存的。虚拟机会在动态连接期间使用这个信息，当动态装载类型时，需要使用发起请求的类型的装载器去装载。
			指向类Class的引用
				对每个被装载的类型，都会在堆区创建一个java.lang.Class的实例，并将其和方法区中的类型信息关联起来。
				可以通过forName和getClass方法来得到相应的Class对象
				Class.getClassLoader()返回装载改类型的ClassLoader对象的引用，如果类型是由启动类装载器装载的，返回null。
			方法表
				为了加快访问原始类型信息的速度，虚拟机为每个非抽象类型生成一个方法表，作为类型信息的一部分存储在方法区。方法表是一个数组，它的元素是所有它的实例可能被调用的实例方法的直接引用，包括从超类继承过来的实例方法。
				虚拟机执行方法时，它会一直持有当前类的常量池（方法区中的数据结构）的指针。
				虚拟机规范并未规定必须使用方法表。
			示例
				Class Volcano{ public static void main(String[] args){Lava lava = new Lava();} }
				这个程序在运行时，首先加载Volcano，执行其main方法。main方法的第一条指令是为位于常量池中第一项的类分配内存。虚拟机根据常量池指针找到其第一项，发现为对类Lava的符号引用，就在方法区查找Lava的类型信息，如果没有就装载。将常量池第一项中的符号引用替换为直接引用（这个过程称为常量池解析）。根据Lava的类型信息决定在堆中为该类型分配多大空间。最后将指向堆中实例的引用压入栈中。
		堆
			虚拟机规范并没有强制规定垃圾收集器，他只是要求虚拟机必须实现以某种方式管理自己的堆空间。
			堆空间的管理（包括垃圾收集）问题由设计者决定
			堆空间不必是连续的内存区。程序运行时可以动态扩展和收缩。
			虚拟机规范并没有规定java对象在堆中如何表示
			由于需要通过对象引用访问类型数据，因此对象中通常会有到方法区的指针。
			一种可能的堆空间设计：把堆分为两部分：句柄池和对象池。一个对象引用就是一个指向句柄池的指针。句柄池的每个条目由两部分组成：一个是指向对象实例变量的指针，一个是指向方法区类型数据的指针。这种设计的优点是有利于碎片整理。当移动对象池中的实例时，只需要改变句柄池中相应的指针。缺点是每次访问对象实例都需要进行两次指针传递。
			另一种可能的堆空间设计：对象引用直接指向一组数据，这组数据包括对象实例的引用和类型数据的引用。这种设计的优缺点正好和前面的相反。优点是可以直接访问对象实例，缺点是在移动对象实例时，需要改变所有对该对象实例的引用。
			类型转换、instanceof、实例方法的动态绑定都要求对象实例中包含对类型数据的引用。
			每个对象实例都包含一个指向特殊数据结构的指针，这个特殊的数据结构位于方法区，由两部分组成：一个指向方法区对应类型数据的指针，一个是此对象的方法表。
			方法表是个指针数组，方法表存储的实例方法数据包含以下信息：
				该方法的操作数栈和局部变量区的大小
				该方法的字节码
				该方法的异常表
			堆上的对象数据还有一个逻辑部分就是对象锁。锁数据可以在需要时才分配。
			除了实现锁所需的数据外，每个java对象逻辑上还与实现等待集合（Object的wait, notify, notifyAll）的数据相关联。虚拟机实现可以将对象数据和等待集合数据分开，并在需要时再分配。
			垃圾收集器有关的数据也可以作为堆中对象数据的一部分。比如标记对象的引用状况，其终结方法是否运行过了等。具体的数据结构依垃圾收集算法而定。
			java语言规范指出垃圾收集器只能对对象调用一次终结方法，但允许终结方法复活该对象，即使该对象再次被引用。这样当这个对象再次被回收时，就不用再调用其终结方法。
			数组的内部表示
				数组也拥有一个相关联的Class实例，所有具有相同维度和类型的数组都是同一个类的实例，而不管数组的长度。
				数组类的名称由两部分组成：每一维用一个方括号“[”表示，用字符或字符串表示元素类型。如byte类型的三维数组为“[[[B”
				数组的直接超类为Object
				堆中的数组对象必须保存的数据包括：指向数组类数据的指针、数组的长度、数组的数据。
		程序计数器
			每个线程都有自己的pc寄存器。pc寄存器的大小是一个字长，因此既能持有一个本地指针，也能持有一个returnAddress。当线程执行java方法时，它总是指向下一条将要执行指令的地址。这里的地址可以是一个本地指针，也可以是方法字节码中相对于方法起始指令的便宜量。当线程执行本地方法时，pc寄存器中的值是undefined。
		java栈
			虚拟机只会直接对java栈执行两种操作：以帧为单位的压栈和出栈
			当虚拟机遇到栈内操作指令时，它对当前帧内数据执行操作
			java方法可以以两种方式返回：return和抛异常。无论哪种方式，虚拟机都会将当前帧弹出java栈并释放掉。
			java栈和栈帧在内存中也不必是连续的。表示栈和栈帧的数据结构有设计者决定。某些实现允许用户指定java战的起始大小和最大、小值。
		栈帧
			栈帧由三部分组成：局部变量区、操作数栈和帧数据区。局部变量区和操作数栈的大小是对应的方法而定，它们是按字长计算的，编译器在编译时就确定了这些值并放在了class文件中。帧数据区的大小依赖于具体的实现。
			当虚拟机调用java方法时，从方法区的类型数据信息中得到局部变量区和操作数栈的大小，并据此分配栈帧内存，压入栈中。
			局部变量区
				局部变量区被组织成一个以字长为单位，从0开始计数的数组。字节码指令根据索引使用其中的数据。类型为int的占据一项，类型为byte、short、char的值在存入数组前被转化为inti型，double和long型占据两项。
				局部变量区包含对应方法的参数和局部变量。编译器按声明的顺序把这些参数放入局部变量数组。注意实例方法中的第一个参数为隐含参数this。
				虽然虚拟机对byte、short、char类型是直接支持的，但在局部变量区和操作数栈中它们都会被转化成int类型的值，只有被存储在堆或方法区时，才会转换会原来的类型。
				java方法的参数严格按照声明顺序放入局部变量区，对于真正的局部变量，可以任意决定放置顺序，甚至可以用一个索引指代两个局部变量（当两个局部变量的作用域不重叠时）。
				和其他运行时数据区一样，虚拟机实现者可以决定为局部变量区设计任意的数据结构。
			操作数栈
				操作数栈也被组织成以字长为单位的数组，但它不是通过索引来访问，而是通过标准的栈操作--压栈和出栈
				数据在操作数栈中的存储方式和局部变量区一样。
				java虚拟机的指令是从操作数栈中取得操作数的，而非寄存器。虽然指令也可以从其他地方取得操作数，比如字节码流中跟在操作码后面的字节或常量池中，但主要是从操作数栈中取得。
				虚拟机把操作数栈作为它的工作区--大多数指令从这里弹出操作数，执行运算，将结果压回栈中。
				将两个int型的局部变量相加，再把结果保存在第三个局部变量中：
					iload_0		将局部变量区中索引为0的int值压入操作数栈
					iload_1		将局部变量区中索引为1的int值压入操作数栈
					iadd		因为int类型的add操作需要两个操作数，因此从操作数栈中弹出两个int，相加后，将结果压入操作数栈
					istore_2	从操作数栈弹出一个int值，并存放在局部变量区中索引为2的项中
			帧数据区
				帧数据区中的数据用来支持常量池解析、正常方法返回以及异常派发机制。
				当虚拟机执行某个需要用到常量池数据的指令时，都会通过帧数据区中指向常量池的指针来访问它。
				java虚拟机的大多数指令都涉及到常量池入口。有些指令需要从常量池中获取数据、有些需要根据常量池中的数据来指示实例化的类、数组的类型、字段或方法，有些需要根据常量池中的数据来判断某个对象是否属于某个类或实现了某个接口。
				帧数据区帮助虚拟机处理java方法的正常退出和异常终止：
					正常退出：虚拟机需要恢复发起调用的方法的栈帧，包括设置pc寄存器，将方法返回值压入调用方法的操作数栈中。
					抛出异常：帧数据区保存有对该方法异常表的引用。异常表的每一项包括：被catch子句保护的代码的起始和结束位置，可能被catch的异常类在常量池中的索引，catch子句内的代码开始的位置。当抛出异常时，如果在异常表中匹配到了相应的catch子句，就交给其处理。如果没有，方法会立即异常终止。虚拟机使用帧数据区中的信息恢复发起调用的方法的帧，然后在发起调用的方法的上下文中重新抛出同样的异常。
				java栈的可能实现方式
					1。在堆中单独分配栈空间
						和引用其他类的字段和方法一样，对同一类的字段和方法的引用初始时也是符号，因此在使用之前需要解析。
					2。从一个连续的栈中分配
						这种方式允许相邻方法的栈帧可以相互重叠。比如调用者的操作数栈（包含传递给被调用者的参数）就成了被调用者的局部变量区的底层。
		本地方法栈
			当线程调用本地方法时，它就进入了一个全新的，不受虚拟机限制的世界
			本地方法可以通过本地方法接口来访问虚拟机的运行时数据区
			当调用本地方法时，虚拟机不会在栈中压入栈帧
			任何本地方法接口都会使用某种本地方法栈
			如果虚拟机的本地方法接口是使用C连接模型，那么它的本地方法栈就是C栈
			本地方法接口回调虚拟机中的java方法时，线程会保存本地方法栈的状态并进入到另一个java栈
			本地方法栈占用的内存区也不是固定大小的
		执行引擎
			虚拟机规范中，执行引擎的行为使用指令集来定义。
			执行引擎术语可以有三种解释：一个是抽象的规范，一个是具体的实现，一个是正在运行的实例
			运行中java程序的每一个线程都是一个独立的虚拟机执行引擎的实例。
			一个线程可能通过解释或使用芯片级指令直接执行字节码，或者通过即时编译器执行编译过的本地代码。
			虚拟机的实现可能使用一些对用户程序不可见的线程，比如垃圾收集，这些线程不需要是实现的执行引擎的实例。所有属于用户运行程序的线程，都是在实际工作的执行引擎。
			指令集
				方法的字节码流是由java虚拟机的指令序列构成。每个指令包含单字节的操作码和0个或多个操作数。
				操作码本身就已经规定了是否需要操作数，以及操作数的类型和个数
				当执行指令时，操作数可以是常量池中的项、局部变量区中的项和当前帧操作数栈顶端的值。
				执行引擎遇到本地方法调用的指令时，虚拟机试着发起本地方法调用
				可以将本地方法看成是虚拟机指令集的一种可编程扩展
				执行一条指令包含的任务之一就是决定下一条要执行的是什么指令
				使用javap可以查看任何class文件中方法的字节码助记符。
				java虚拟机指令集的设计遵循几个不同的目标，但他们之间是有冲突的：平台无关性、网络移动性和安全性。平台无关性是影响指令集设计的最大因素。
				class文件中保存的字节码，除了两个处理表跳转的指令外，都是按照字节对齐的。假如字节码流是以字对齐而不是字节对齐，某些实现可能得到更好的性能。
				指令集设计的另一个目标就是进行字节码验证的能力。在装载字节码的时候使用数据流分析器进行一次性验证，而非在运行时验证，可以提高效率。
				操作数栈中的数据必须按照适合他们类型的方式被使用。比如将4个int型的值当作两个long型使用是非法的。
				并不是所有类型上都支持所有的操作。很多操作对byte、short、char都不支持，因此这些类型压入栈帧时转化为int，放到堆或方法区时再转换回原来的类型。
			执行技术
				实现可以使用多种执行技术：解释、即时编译、自适应优化、芯片级直接执行。
				方法调用会使优化器的有效性降低，因为优化器在不同的方法调用间不能有效工作。这个问题的标准解决方案就是内嵌，缺点是需要更多的运行时内存。而且面向对象语言的内嵌难度更高，因为它里边有动态派发。
				内嵌一个动态派发的方法调用，一种解决方案是把所有可能派发的方法都内嵌进去，这会导致代码变大。自适应编译比静态编译的优点就在于，自适应编译时运行时进行的，在运行时可以得到更多的信息，从而减少可能派发的方法的个数，较少了优化后代码的大小。
			线程
				Java线程模型的一个目标就是使实现的设计者，在可能的情况下使用本地线程。使用本地线程可以使java的线程在多个处理器上并行执行。
				java线程的折中之一是优先级的规范考虑最小公分母问题。10个优先级，1为最低。
				虚拟机规范对不同优先级线程的行为，只规定了高级别的优先级会得到大多数的cpu时间。较低级别的线程只有在所有比它优先级高的线程都阻塞的情况下才能保证得到cpu时间。级别低的线程在级别高的线程没有阻塞的情况下也可能得到cpu时间，但这没有任何保证。
				任何java虚拟机的线程实现都必须支持同步的两个方面：对象锁定和线程等待通知，即互斥和协作。
				虚拟机规范中，java线程的行为是通过术语--变量，主存和工作内存来定义的。每个虚拟机实例都有一个主存，来保存所有的程序变量（对象的实例变量、数组元素、类变量等）。每个线程都有个工作内存，来保存它所使用或赋值的变量的“工作拷贝”。
				虚拟机规范定义了很多规则，来管理线程和主存之间的低层次交互行为。比如：声明所有对基本数据类型的操作，除某些对long和double类型的操作之外，都必须是原子级的。
				对于没有被声明为volatile的long或double变量，某些实现可能把他们作为两个原子性的32位值对待，而非一个原子性的64位值。这样就可能会出错。
				基本上，管理底层线程行为的规则，规定了一个线程何时可以做和何时必须做以下的事情：
					1。把变量的值从主存拷贝到工作内存
					2。把工作内存中的值拷贝到主存。
		本地方法接口
			本地方法接口，或称JNI，是为可移植性准备的。它使开发者在一个特定的主机平台上，把同样的本地方法二进制形式连接到任何支持JNI的虚拟机实现。
			为了取得更好的性能，实现设计者可以提供他们自己的低层本地方法接口，以便和他们所使用的特定实现结构更加紧密的结合。也可以提供比JNI层次更高的本地方法接口。
			为了实现可移植性，本地方法接口在指针和指针之间，指针和方法之间使用了很多间接方法。
			为了做好工作，本地方法必须能够和Java虚拟机实例的某些内部状态有某种程度的交互。
	真实机器
		所有的子系统、运行时数据区和java虚拟机规范定义的内部行为都是抽象的。

			
Java Class文件
	Java Class文件是什么
		一个class文件只能包含一个类或接口。
		java class文件是8位字节的二进制流，占据多个字节空间的项按照高位在前的顺序分为几个连续的字节存放。
	Class文件的内容
		class文件中出现的各项的有序列表：
			魔数
				占4个字节，用来判断是否是class文件
			minor_version和major_version
				主次版本号
				class文件的主版本号与java平台主发布版的版本号保持一致，次版本号与特定主平台发布版的版本号保持一致。
			constant_pool_count与constant_pool
				注意：原书中关于常量池入口的说法可能是指常量池entry，我觉得可能是作者的翻译问题。
				在整个class文件中，指示常量池入口在常量池列表中位置的整数索引都指向这些常量池入口。索引从1开始，但constant_pool_count仍然将索引0考虑在内，所以constant_pool_count的值总是比实际的常量池入口的个数多1。
				每个常量池入口都从一个字节的标志开始，它指明该入口中包含的常量类型。
				常量池标志：
					入口类型							标志值								描述
					CONSTANT_Utf8						1									Utf8编码的unicode字符串
					CONSTANT_Integer					3									int型常量
					CONSTANT_Float						4                                   float常量
					CONSTANT_Long						5									long常量
					CONSTANT_Double						6									double常量
					CONSTANT_Class						7									类或接口的符号引用
					CONSTANT_String						8									String类型字面值
					CONSTANT_FieldRef					9									字段的符号引用
					CONSTANT_MethodRef					10									类中方法的符号引用
					CONSTANT_InterfaceMethodRef			11									接口中方法的符号引用
					CONSTANT_NameAndType				12									字段或方法的部分符号引用
				字段描述符用来指定字段的类型，方法描述符用来指定方法的返回值、参数的数量、顺序和类型。
				class文件并不知道它的内部组件的最终内存布局，因此类、字段、方法不能被class文件中的字节码直接引用。因此通过常量池，通过运行时解析来实现。
			access_flags
				指示该class文件中定义的类或接口的信息
				access_flags项的标志位：ACC_PUBLIC, ACC_FINAL, ACC_SUPER, ACC_INTERFACE, ACC_ABSTRACT.
			this_class
				this_class项的内容是一个指向常量池入口列表的索引，它指向的入口列表需要是CONSTANT_CLASS类型。CONSTANT_CLASS类型的入口包含两项内容：一个是用来标识该入口类型的标签，一个是指向存储该类和接口全限定名的CONSTANT_Utf8类型的入口的索引。
			super_class
				super_class项的内容是一个指向常量池入口列表的索引，它指向的入口列表需要时CONSTANT_CLASS类型。对于Object类，super_class项的值为0。对于接口，在常量池入口super_class位置的项为java.lang.Object。
			interfaces_count和interfaces
				该class文件指定的类直接实现的接口，或接口直接继承的父接口。interfaces数组中包含的项是指向CONSTANT_CLASS类型的常量池入口的索引。顺序按直接接口声明的顺序。
			fields_count和fields
				只包含由该class文件声明的字段，不包括父类或父接口中声明的字段。
				可能会包含一些在源文件中没有叙述的字段。这些字段是编译器在编译时添加的。比如对于内部类，会添加对外部类实例的引用。这些字段使用Synthetic属性标识。
			methods_count和methods
				只包括在类或接口中显式定义的方法，不包括通过继承得到的。
			attributes_count和attributes
				给出该class文件中所定义的属性的基本信息。
				java虚拟机规范定义了几种属性，也允许用户自定义。虚拟机需要忽略不能识别的属性。
				java虚拟机实现定义了两种属性--SourceCode和InnerClasses
	特殊字符串
		常量池中的符号引用由三种特殊的字符串组成：全限定名、简单名称和描述符。所有的符号引用都包括类或接口的全限定名。字段和方法的符号引用除了全限定名外还有字段名称或方法名称和描述符。
		全限定名
			在class文件中，全限定名中的点用斜线取代了。
		简单名称
		描述符
			字段的描述符给出字段的类型，方法的描述符给出方法的返回值、参数的数量、顺序和类型
			实例方法的方法描述符不包括隐含参数this
			方法描述符只能包含255个字长以内的参数
	常量池
		常量池是一个可变长度的cp_info表的有序序列。cp_info表中的tag项是一个无符号的byte类型值，指明该cp_info表的类型和格式。cp_info表共有11种类型。
		CONSTANT_Utf8_info
			使用一种utf-8格式的变体来存放一个常量字符串。字符串类型包括文字字符串、全限定名、简单名称、描述符、属性相关的描述符等。
			该表的格式包括3部分：tag、length、bytes。tag的值为CONSTANT_Utf8（1），指明了该表的类型。length指明bytes部分的长度。bytes中存放字符串的各个字符。
			bytes项中的utf8编码和标准utf8编码的区别是：在标准utf8编码中，空字符null使用一个字节表示。而在bytes项使用的utf8编码中，空字符使用两个字节表示。
			对于空字符null的双字节表示，意味着bytes项的值不可能为0，另一方面bytes项中只使用了标准utf8编码中的单字节、二字节和三字节的部分，较长的格式并未使用。
		CONSTANT_Integer_info
			该表只存储int类型值，不存储符号引用。
			该表的格式包括2部分：tag、bytes。tag的值为CONSTANT_Integer（3）。bytes部分以高位在前的形式存储int类型的值。
		CONSTANT_Float_info
		CONSTANT_Long_info
		CONSTANT_Double_info
			这三个表的格式同Constant_Integer_info表。
		CONSTANT_Class_info
			无论指向类、接口、字段和方法，所有的符号引用都包括一个CONSTANT_Class_info表。
			该表的格式包括2部分：tag、name_index。tag的值为CONSTANT_Class。name_index项给出了包含类或接口全限定名的CONSTANT_Utf8_info表的索引。
			对于数组类型，name_index项指向的CONSTANT_Utf8_info表包含该数组的描述符，描述符可作为数组类的名称。
			java数组最多只能有255维。
		CONSTANT_String_info
			该表用来存储文字字符串的值，该值亦可表示为String类的实例。
			该表的格式包含2部分：tag、string_index。tag的值为CONSTANT_String。string_index项给出了包含文字字符串值的CONSTANT_Utf8_info表的索引。
		CONSTANT_Fieldref_info
			固定长度，描述了指向字段的符号引用
			该表的格式包含3部分：tag、class_index、name_and_type_index。tag的值为CONSTANT_Fieldref。class_index项指向声明了该字段所属类或接口的CONSTANT_Class_info表的索引。name_and_type_index项指向声明该字段简单名称和描述符的CONSTANT_NameAndType_info表的索引。
			如果类使用其它类的静态final这种编译时常量，那么该类中将不会包含对这些字段的符号引用。类中将保存这些编译时常量的副本。比如类使用了接口中声明的float类型的静态final字段，该类将在它自己的常量池中拥有一个表示该float值的CONSTANT_Float_info表。但是如果接口中声明的静态final字段的值只有在运行时才能计算出，那在使用该字段的类型的常量池中将会有一个对该接口中的字段进行符号引用的CONSTANT_Fieldref_info表。
		CONSTANT_Methodref_info
			使用符号引用来表明类中声明的方法，不包括接口中的方法。
			该表的格式分为3部分：tag、class_index、name_and_type_index。tag的值为CONSTATN_Methodref。class_index项指向声明该方法所属类的CONSTANT_Class_info表的索引。name_and_type_index项指向声明该方法简单名称和描述符的CONSTANT_NameAndType_info表的索引。
			如果一个方法的简单名称开始于"<"，该方法必须为一个实例初始化方法，该方法的简单名称必须为<init>，返回值为void类型。
		CONSTANT_InterfaceMethodref_info
			使用符号引用来表明接口中声明的方法，不包括类中的方法。
			该表的格式分为3部分：tag、class_index、name_and_type_index。tag的值为CONSTANT_InterfaceMethodref。
		CONSTANT_NameAndType_info
			该表用来表示指向字段或方法的符号引用的一部分。
			该表的格式分为3部分：tag、name_index、descriptor_index。tag的值为CONSTANT_NameAndType。name_index项的值为表明简单名称的CONSTANT_Utf8_info表的索引。descriptor_index项的值为表明描述符的CONSTANT_Utf8_info表的索引。
	字段
		类或接口中声明的每一个字段都由class文件中一个名为field_info的可变长度的表进行描述。
		field_info表的格式：access_flags, name_index, descriptor_index, attributes_count, attributes.
		access_flage:
			声明字段时使用的修饰符存放在该项中。可能的值为ACC_PUBLIC, ACC_PROTECTED, ACC_PRIVATE, ACC_STATIC, ACC_FINAL, ACC_VOLATILE, ACC_TRANSIENT。
			类中声明的字段只能使用ACC_PUBLIC, ACC_PROTECTED, ACC_PRIVATE中的一个。ACC_STATIC和ACC_VOLATILE不能同时使用。接口中的字段有且只能有ACC_PUBLIC, ACC_STATIC, ACC_FINAL。
		name_index
			提供指向简单名称的CONSTANT_Utf8_info表的索引
		descriptor_index
			提供指向描述符的CONSTANT_Utf8_info表的索引
		attributes_count和attributes
			java虚拟机定义的三种可能出现在此项中的属性是：ConstantValue, Deprecated, Synthetic。java虚拟机唯一需要识别的是ConstantValue。
	方法
		在java源文件的同一个类中，如果声明了两个具有相同名称、参数数量、顺序、类型，但返回值不同的方法，将不能通过编译。但class文件中这两个方法却可以和谐存在。
		有可能出现在class文件中的由编译器生成的方法是：实例初始化方法<init>和类或接口初始化方法<clinit>。
		method_info表的格式：access_flags, name_index, descriptor_index, attributes_count, attributes.
		access_flags
			access_flags的可能的值为：ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL, ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT, ACC_STRICT。
			ACC_STRICT表明该方法中的所有表达式都必须使用FP-strict模式进行计算。
			如果设定了一个方法的ACC_ABSTRACT标志，那么ACC_PRIVATE, ACC_FINAL, ACC_STATIC, ACC_SYNCHRONIZED, ACC_NATIVE, ACC_STRICT标志都必须清楚。
			接口中声明的方法必须是ACC_PUBLIC和ACC_ABSTRACT标志，除此之外接口方法不能使用其它标志，但接口初始化方法<clinit>方法可以使用ACC_STRICT标志。
			由于类和接口的初始化方法<clinit>只能由虚拟机进行调用，所以<clinit>方法的access_flags标志位除了ACC_STRICT之外都应被忽略。
		name_index
			提供指向简单名称的CONSTANT_Utf8_info表的索引
		descriptor_index
			提供指向描述符的CONSTANT_Utf8_info表的索引
		attributes_count和attributes
			java虚拟机定义的四种可能出现在此项中的属性是：Code, Deprecated, Exception, Synthetic。java虚拟机只需要识别的是Code和Exception属性。
	属性
		Java虚拟机规范定义了9种属性（Code, ConstantValue, Deprecated, Exceptions, InnerClasses, LineNumberTable, LocalVariableTable, SourceFile, Synthetic）。为了正确的解释java class文件，所有的虚拟机实现都必须能够识别三个属性：Code、ConstantValue、Exception。为了实现java和java2平台类库，所有虚拟机实现都必须识别InnerClasses和Synthetic属性。
		属性均以attribute_info表的形式表示。attribute_info表的格式包括3部分：attribute_name_index, attribute_length, info.
		属性格式
			attribute_name_index项的值为表明该属性名称的CONSTANT_Utf8_info表的索引。
			attribute_length项的值为出去attribute_name_index和attribute_length之外，attribute_info表的长度。
			info项包含属性数据
		Code属性
			可变长度的Code_attribute表定义了方法的字节码序列和其他信息。在所有不是抽象或本地的方法的method_info表中都存在一个Code_attribute。
			Code_attribute表中的各项如下：
				attribute_name_index
					给出包含字符串“Code”的CONSTANT_Utf8_info的表的索引
				attribute_length
					项给出除attribute_name_index和attribute_length项之外，Code_attribute表的长度
				max_stack
					给出该方法操作数栈的最大长度
				max_locals
					给出该方法的局部变量所需存储空间的长度
				code_length和code
					指出该方法字节码流的长度和字节码流。
				exception_table_length和exception_table
					exception_table是exception_info表的列表。exception_table_length指明exception_info表的个数。exception_table中exception_info表的顺序按照程序运行抛出异常时，java虚拟机检查匹配异常处理器的顺序进行排列。
					固定长度的exception_info表描述了一个异常表项。
					exception_info表的格式如下：
						start_pc指从代码数组起始处到异常处理器起始处的偏移量。
						end_pc指从代码数组起始处到异常处理器结束后一个字节的偏移量
						handler_pc项指出一条指令从代码数组起始处跳转到异常处理器的第一条指令的偏移量。
						catch_type指向表示被捕获异常的CONSTANT_Class_info表的索引。如果catch_type的值为0，那么异常处理器将处理所有异常。一个值为0的catch_type用于实现finally字句。
				attributes_count和attributes
					attributes项是一个attribute_info表的列表。java虚拟机规范定义了两种可以出现在此处的属性：LineNumberTable和LocalVariableTable。
		ConstantValue属性
			固定长度的ConstantValue属相出现在值为常量的字段的field_info表中。在包含ConstantValue属性的field_info表内的access_flags字段必须设定ACC_STATIC。当虚拟机初始化一个具有ConstantValue属性的字段时，将常量赋给该字段。赋值操作发生在声明该类或字段的类或接口的初始化方法之前。
			ConstantValue_attribute表的各项如下：
				attribute_name_index
					指向常量池中表示“ConstantValue”的CONSTANT_Utf8_info表的索引
				attribute_length
					这个值恒为2
				constantvalue_index
					给出提供常量值的入口的常量池索引。
			常量值属性的常量池入口类型：CONSTANT_Integer, CONSTANT_Long, CONSTANT_Float, CONSTANT_Double, CONSTANT_String。
		Deprecated属性
			固定长度的Deprecated属性存在于field_info，method_info和ClassFile表内的attributes项中，它是一个可选项。
			Deprecated_attribute表的各项如下：
				attribute_name_index
					常量池中表明"Deprecated"字符串的CONSTANT_Utf8_info表的索引
				attribute_length
					必须为0
		Exceptions属性
			Exceptions_attribute表出现在每个可能抛出已检查异常的方法的method_info表中
			Exceptions_attribute表中各项如下：
				attribute_name_index
					常量池中表明"Exceptions"字符串的CONSTANT_Utf8_info表的索引
				attribute_length
					除去attribute_name_index和attribute_length，Exceptions_attribute表的长度
				number_of_exceptions和exception_index_table
					exception_index_table是一个列表，该列表有number_of_exceptions项元素，每个元素都是到表示某异常类的CONSTANT_Class_info表的索引。
		InnerClasses属性
			如果类和接口的代码指向一个嵌入类型，那么该类的常量池中需要包含一个表示该嵌入类型的CONSTANT_Class_info表。并且此类或接口的class文件必须包含一个InnerClasses_attribute表。此表存在于它自身的ClassFile的attributes项中。
			InnerClasses_attribute表的各项如下：
				attribute_name_index
					指向常量池中表示字符串"InnerClasses"的CONSTANT_Utf8_info表的索引
				attribute_length
					除去attribute_name_index和attribute_length，InnerClasses_attribute表的长度
				number_of_classes和classes
					classes项是一个成员为inner_class_info表的数组。
					InnerClasses属相的classes项将会为每一个在常量池中CONSTANT_Class_info表中陈述的内嵌类型包含一个inner_class_info表。
					定义了内嵌类型的class文件中的InnerClasses属性将会为它所有的外围类型（不只是直接外围类，也包括间接外围类）包含一个inner_class_info表。
					inner_class_info表位于InnerClasses属性的classes项中，每一个inner_class_info表表示一种类型，该类型或者为外围类型，或者为内嵌类型，或者两者都是。
					inner_class_info表的格式如下：
						inner_class_info_index
							指向表示内嵌类型的CONSTANT_Class_info表的索引
						outer_class_info_index
							如果inner_class_info表不是对内嵌类型进行描述，那么outer_class_info_index的值必须为0。因为inner_class_info可以描述非内嵌类型，因为inner_class_info表描述的类型或者为内嵌类型，或者为外围类型。当它描述的是最外围类型时，该类型将再没有外围类。所以outer_class_info_index的值为0。
						inner_name_index
							如果内部类为匿名类，该值为0。否则为一个CONSTANT_Utf8_info表的索引
							通过inner_class_info_index可以查出inner_class_info表示的类型的名称，无论是匿名的（源代码没有类名，编译器会生成）还是非匿名的。因此获得类名时并不一定需要inner_name_index。因此inner_name_index可以用来区分源代码中是匿名类还是非匿名类。
						inner_class_access_flags
							该项给出对inner类的访问标志
							该项的值有：ACC_PUBLIC, ACC_PROTECTED, ACC_PRIVATE, ACC_STATIC, ACC_FINAL, ACC_INTERFACE, ACC_ABSTRACT
		LineNumberTable属性
			该属性建立了方法字节码流偏移量和源代码行号之间的映射关系。该属性可能会出现在Code_attribute表中的属性部分中
			该表各项如下：
				attribute_name_index
					"Line_Number_Table"的CONSTANT_Utf8_info表的索引
				attribute_length
					除去attribute_name_index和attribute_length，LineNumberTable_attribute表的长度
				line_number_table_length和line_number_table
					line_number_table是一个成员为line_number_info表的数组。该数组中的表可以按任何顺序排列，也可能出现多个表对应一个行号的情况。
					line_number_info表的格式如下：
						start_pc
							指明新行开始时的代码数组的偏移量。该值必须小于Code属性中code_length项的值。
						line_numger
							指明start_pc对应的行号
		LocalVariableTable属性
			该属性建立了方法的栈帧中局部变量部分内容与源代码中局部变量的名称和描述符的映射关系。该属性可以存在于Code_attribute表中的属性部分。
			LocalVariableTable_attribute表的格式如下：
				attribute_name_index
					字符串“LocalVariableTable”的CONSTANT_Utf8_info表的索引
				attribute_length
					除去attribute_name_index和attribute_length，LocalVariableTable_attribute表的长度
				local_variable_table_length和local_variable_table
					local_variable_table是一个成员为local_variable_info的数组
					local_variable_info表建立起源代码中局部变量的名称、类型和局部变量在二进制字节码中的作用域、栈帧内局部变脸的索引之间的映射关系。
					local_variable_info表的格式如下：
						start_pc和length
							start_pc给出代码数组中指令开始位置的偏移量。length给出从start_pc开始的、所有局部变量有效地代码的长度。
						name_index
							包含局部变量名称的CONSTANT_Utf8_info表的索引
						descriptor_index
							包含局部变量描述符的CONSTANT_Utf8_info表的索引
						index
							指出该局部变量在方法栈帧中的索引
		SourceFile属性
			该属性存在于ClassFile表的属性项中，表明产生该class文件的源文件的名称。
			SourceFile_attribue表的格式如下：
				attribute_name_index
					字符串“SourceFile”的CONSTANT_Utf8_info表的索引
				attribute_length
					该值恒为2
				sourcefile_index
					表示源文件名称的CONSTANT_Utf8_info表的索引，文件名称不包括目录路径。
		Synthetic属性
			该属性可能存在于field_info, method_info和ClassFile表内的attributes项中，它指明了由编译器产生的字段、方法和类。
			Synthetic_attribute表的格式如下：
				attribute_name_index
					表示字符串"Synthetic"的CONSTANT_Utf8_info表的索引
				attribute_length
					恒为0

					
类型的生命周期
	类型装载、连接和初始化
		连接是把装载进虚拟机的二进制形式的类型数据合并到虚拟机的运行时状态中。
		连接阶段分为3个步骤：
			验证：确保java类型数据格式正确和能被虚拟机使用
			准备：负责为该类型分配它所需的内存。
			解析：负责把常量池中的符号引用解析为直接引用。虚拟机的实现可以推迟解析这一步，它可以在运行中的程序真正使用某个符号引用时再去解析它。
		所有虚拟机实现必须在某个类或接口首次主动使用时初始化。
		六种符合主动使用的情形：
			1。当创建某个类的新实例时。（或者通过new关键字，或者通过不明确的创建、反射、克隆和反序列化）
			2。当调用某个类的静态方法时（即在字节码中执行invokestatic指令时）
			3。当使用/设置某个类或接口的静态字段（即在字节码中执行getstatic/putstatic指令时）。用final修饰的静态字段除外，它被初始化为一个编译时的常量。
			4。当调用java api中的某些反射方法时。比如类Class中的方法或者java.lang.reflect中的类的方法
			5。当初始化某个类的子类时（某个类初始化时，要求它的超类已经初始化了）
			6。当虚拟机启动时，某个被表明为启动类的类（即含有main()的那个方法）
		除上述6种方式外，其他使用java类型都属于被动使用，不会导致java类型的初始化。
		一个接口的初始化，并不要求它的祖先接口预先被初始化。只有当该接口声明的非常量字段被使用时，该接口才会被初始化。当实现了接口的类被初始化时，不需要初始化接口，但接口必须被装载。
		装载
			装载阶段由三个基本动作组成：
				通过改类型的完全限定名，产生一个表示该类型的二进制数据
				解析这个二进制数据为方法区内的数据结构
				产生一个表示该类型的Class类的实例
			装载步骤的最终产品就是这个Class类的实例，它成为java程序和内部数据结构之间的接口。
			如果一个类装载器在预先装载时遇到问题，无论如何，它应该在该类型首次主动使用时报告该问题。
		验证
			虚拟机的实现者可以决定何时以及如何验证类型。虚拟机规范列出了可以抛出的异常以及何种条件下必须抛出他们。
			有可能，确保除了Object类外，其它类都有一个超类，这个验证是在装载阶段完成的，因为虚拟机在装载一个类时，必须确保它的所有超类已经被装载了。
			在大部分虚拟机实现中，对符号引用的存在性和访问权限的检查可能发生在验证阶段之后。
			验证阶段需要完成的检查中，确保各个类之间二进制兼容的检查：
				检查final类不能有子类
				检查final方法不能被覆盖
				确保类和超类之间没有不兼容的方法声明（比如两个仅返回类型不同的方法）
				检查所有常量池入口类型相互之间一致（比如CONSTANT_String_info表的name_index指向的必须是CONSTANT_Utf8_info表的索引）
				检查常量池中的所有特殊字符串是否符合格式（类名、方法名、字段名、方法描述符、字段描述符）
				检查字节码的完整性
			虚拟机实现没有强求在验证阶段进行字节码验证。但虚拟机指令集设计的一个目标就是使字节码流可以通过一次性使用一个数据流分析器进行验证。在连接过程中一次性验证字节码流，而非在运行时，将提高程序的运行速度。
			当通过一个数据流分析器验证字节码时，虚拟机可能不得不为了确保符合java语言的语义而装载其他类。
		准备
			在准备阶段，虚拟机为类变量分配内存，并根据其类型设置默认初始值。准备阶段不会执行java代码。
			在准备阶段，虚拟机实现可能会为一些数据结构分配内存，目的是提高运行程序的性能。这种数据结构的例子如方法表。
		解析
			把常量池中的符号引用解析为直接引用的过程
		初始化
			为了准备让一个类或接口首次被主动使用，最后一个步骤是初始化，为类变量赋于程序员所希望的初始值。
			java代码中一个正确的初始值是通过类变量初始化语句（类变量声明后面的等号或表达式）或静态初始化语句（以static开头的程序段）给出的。
			所有的类变量初始化语句和静态初始化器被编译器收集到一起，放到一个特殊的方法内。这个方法对于类叫做类初始化方法，对于接口叫接口初始化方法。在类和接口的class文件中，这个方法被称为'<clinit>'，这个方法只能被java虚拟机调用。
			初始化一个类包含两个步骤：
				如果类存在直接超类，且直接超类还没被初始化，就先初始化直接超类。
				如果类存在一个类初始化方法，就执行该方法
			虚拟机需要确保初始化过程被正确的同步。
			类变量初始化语句和静态初始化器在<clinit>方法中执行的顺序同它在原代码中出现的顺序一致。
			只有那些的确需要执行java代码来赋予类变量正确初始值的类才有类初始化方法。如类中只包含静态final变量的类初始化语句，并且类初始化语句采用编译时常量表达式，类不会有类初始化方法。这样的字段没有作为类变量保存在方法区中。
			当一个类中包含静态final类型的字段，并且以编译时常量进行初始化，那么其他类在使用该字段时，不会包含一个指向该字段的引用。而是，当该字段的值小于short的范围时，将其直接嵌入到字节码中，当该字段的值超过short的范围时，在常量池中用CONSTANT_Integer_info表来表示。
			如果接口包含任何不能在编译时解析为常量的字段初始化语句，它就将包含一个'<clinit>'方法。
			使用一个非常量的静态字段，只有当类或接口的确声明了这个字段时才是主动使用。当通过子类、子接口、实现接口的类来使用父类、父接口、接口中的非常量静态字段时，属于对子类、子接口、实现接口的类的被动使用，不会触发他们的初始化语句。
			如果使用一个类的静态、final的、用编译时常量初始化的字段时，不属于对声明该字段的类的主动使用，不会导致该类的初始化。
	对象的生命周期				
		类实例化
			实例化一个类有4种途径：
				1。显式调用new()方法
				2。调用Class或java.lang.reflect.Constructor类的newInstance()方法
				3。调用现有对象的clone()方法
				4。调用java.io.ObjectInputStream的getObject()方法反序列化
			会发生隐含实例化对象的情形有：
				1。虚拟机在装载类型后会生成一个相应的Class类的实例。
				2。虚拟机装载常量池中包含CONSTANT_String_info入口的类时，会为这些String创建相应的实例，从而可以在解析时，将符号引用转化为直接引用。
				3。字符串连接操作时，用于中间处理的String和StringBuffer会被创建。
			当虚拟机创建一个类的新实例时的步骤；
				首先在堆中分配内存
				根据类变量的类型赋予默认初始值
				为实例变量赋正确的初始值。根据创建对象的方式不同而有不同的方法：如果是clone方法，则从其他对象拷贝；如果是getObject，则从输入流中读入；否则调用实例初始化方法<init>。
				一个<init>方法要么以调用同类中另一个<init>方法开始，要么以调用超类中的<init>方法开始。
				<init>方法不允许捕获由他们所调用的<init>方法抛出的任何异常。
		垃圾收集和对象终结
			因为终结方法是一个普通的java方法，可以被java程序直接调用。这种形式的直接调用不会影响垃圾收集器的自动调用过程。
			垃圾收集器调用finalize()方法抛出的任何异常都将被忽略。
			垃圾收集器可以用任意方式调用finalize()方法。
		卸载类型
			在很多方面，java虚拟机中类的生命周期和对象的生命周期很相似。
			使用启动类装载器装载的类型永远是可触及的，所以永远不会被卸载。
			如果某个类型的Class实例被发现无法通过正常的垃圾收集堆触及，那么这个类型就是不可触及的。
			判断Class实例是否可触及有两种情况：
				1。程序明确持有Class实例的引用
				2。如果在堆中存在一个可触及的对象，在方法区中它的类型数据指向一个Class实例，那么这个Class实例是可触及的。

				
连接模型
	驱动java连接模型的引擎是解析过程
	动态连接和解析
		class文件把它所有的引用符号保存在常量池中。每个class文件都有一个常量池。被装载的类或接口都有一份内部版本的常量池--运行时常量池
		使用符号引用的虚拟机指令指定位于常量池中的符号应用的索引
		虚拟机为每一个装载的类或接口保存一份独立的常量池。
		连接不仅包括将符号引用替换为直接引用，而且包括检查正确性和权限。
		对于特定的java虚拟机来说，不论何时执行解析，都在程序执行过程中第一次实际试图访问一个符号引用的时候才抛出错误。
		解析和动态扩展
			通过传递类型名字倒Class.forName()方法或调用用户自定义类装载器的loadClass()方法，可以动态扩展java程序
			public static Class forName(String className)使用当前类装载器，即调用forName()的类的类装载器，并且装载的类型会被初始化。
			public static Class forName(String className, boolean initialize, ClassLoader loader).initialize为false时，装载指定类型，该类型可能被连接，但不会被forName()方法明确的初始化。当loader为null时，使用启动类装载器进行装载。
			forName() vs loadClass()：
				1。如果没有特别要指定类装载器的要求，或许应该用forName()
				2。如果需要请求的类型在装载时就初始化的话，只能使用forName()。
				3。loadClass()方法试图将类型装载到调用时传递的用户自定义类装载器的命名空间，forName()方法如果调用时不传递类装载器，类型将被使用当前装载器（装载调用forName()的类型的装载器）装载到当前命名空间。
			JDBC驱动程序使用forName()来装载就是因为驱动程序在被装载并初始化后才能使用。因为驱动程序在其静态初始化器中向DriverManager中注册该驱动程序
		类装载器与双亲委派模型
			每一个用户自定义类装载器被创建时都被分配一个双亲类装载器。如果没有显式的传递一个双亲类装载器给用户自定义类装载器的构造函数，系统类装载器就默认被指定为双亲。如果双亲类装载器可以显式的传递给自定义类装载器，如果传递null，启动类装载器就是双亲。
			在java术语中，要求某个类装载器去装载一个类型，但是却返回了其他类装载器装载的类型，这种装载器称为那个类型的初始类装载器。而实际定义那个类型的装载器被称为该类型的定义类装载器。
			任何被要求装载类型，并能够返回Class实例的类装载器，都是这个类型的初始类装载器。
		常量池解析
			术语“当前类装载器”指的是定义类装载器，它的常量池包含正被解析的符号引用。“当前命名空间”指的是定义类装载器的命名空间，由所有认为当前类装载器为其初始类装载器的类组成。
		解析CONSTANT_Class_info入口
			CONSTANT_Class_info用来表示指向类或接口的符号引用
			根据类型是否是数组，或者引用的类型是由启动类装载器还是用户自定义类装载器装载的，解析的细节会有不同。
				1。数组类
					如果当前类装载器已经被记录为被解析的数组类的初始类装载器，就使用同样的类。否则执行下列步骤：如果数组的元素类型是一个引用类型，虚拟机用当前类装载器去解析元素类型。然后创建一个Class实例来表示该类型。如果是关于引用的数组，数组会被标记为由定义他的元素类型的类装载器定义的。如果是关于基本类型的数组，数组类会被标记为是由启动类装载器定义的。
				2。非数组类和接口
					解析这种类型的符号引用分为多步：
						1a。装载类型或者任何超类型
							对于每个类装载器，虚拟机维护一张列表，其中记录了所有其初始类装载器为该装载器的类型的名字。这个列表就组成了装载器内部的命名空间。
							loadClass()会调用defineClass()使虚拟机试图解析二进制数据，变为方法区中的内部数据结构。
							一旦引用类型被装载了，虚拟机检查二进制数据，用同样的方法装载超类。如此递归，直到Object类。在从Object类返回的路上，检查类实现了哪些接口，并装载这些接口。被装载器装载的接口再递归的装载其父接口。
							用户自定义类装载器通过调用findSystemClass()委派启动类装载器来装载
							通过这个步骤，虚拟机确认该类、它的所有父类和父接口都被装载了。这些类型没有被连接和初始化，仅仅是被装载。
						1b。检查访问类型的权限
							如果发起引用的类型没有访问被引用类型的权限，就抛出IllegalAccessException异常。
							该步骤是校验的一部分，但并非在正式校验阶段完成。
						2。连接并初始化类型和任何超类
							超类必须在子类之前被初始化
							类型在初始化之间必须被连接
							只有超类必须被初始化，超接口是不必的。
						2a。校验类型
							校验过程可能要求虚拟机装载新的类型来确认字节码符合java语言的语义。
						2b。准备类型
							为类型分配内存
						2c。可选的步骤，解析类型
						2d。初始话类型
							从最顶层超类，自顶向下执行类初始化方法。
		解析CONSTANT_Fieldref_info入口
			要解析类型为CONSTANT_Fieldref_info的常量池入口，首先要解析class_index项指向的CONSTANT_Class_info入口。如果CONSTANT_Class_info解析成功，虚拟机在此类型和它的超类型上搜索需要的字段。如果找到需要的字段，还需要检查权限。
			搜索过程如下：
				1。虚拟机在被引用的类型中查找具有指定名字和类型的字段
				2。查找直接实现或扩展的接口， 以及递归检查他们的超接口
				3。检查直接超类，以及递归检查所有超类
				4。否则，字段搜索失败。
		解析CONSTANT_Methodref_info入口
			要解析类型为CONSTANT_Methodref_info的常量池入口，首先要解析class_index项指向的CONSTANT_Class_info入口。如果CONSTANT_Class_info解析成功，虚拟机在此类型和它的超类型上搜索需要的方法。如果找到需要的方法，还需要检查权限。
			搜索过程如下：
				1。如果被解析的类型是一个接口，而非类，虚拟机抛出IncompatibleClassChangeError异常
				2。在被解析的类型中查找
				3。检查直接超类，以及递归检查所有超类
				4。检查直接接口，以及递归检查所有超接口
				5。否则，字段搜索失败。
			如果方法不存在抛出NoSuchMethodError；如果方法是个抽象方法抛出AbstractMethodError；如果方法没有权限访问抛出IllegalAccessError。
		解析CONSTANT_InterfaceMethodref_info入口
			要解析类型为CONSTANT_InterfaceMethodref_info的常量池入口，首先要解析class_index项指向的CONSTANT_Class_info入口。如果CONSTANT_Class_info解析成功，虚拟机在此类型和它的超类型上搜索需要的方法。虚拟机不需要进行权限检查，因为接口中的方法都是隐含公开的。
			搜索过程如下：
				1。如果被解析的类型是一个类，而非接口，虚拟机抛出IncompatibleClassChangeError异常
				2。在被解析的接口类型中查找
				3。检查直接接口，以及递归的检查所有超接口
				4。否则，抛出NoSuchMehtodError
		解析CONSTANT_String_info入口
			解析CONSTANT_String_info入口就是将一个指向内部字符串的引用放置到要被解析的常量池入口数据中去。
			每个java虚拟机需要维护一张内部列表，它列出了所有在运行程序的过程中已被“拘留(intern)”的字符串对象的引用。要拘留CONSTANT_String_info表所代表的字符串序列，虚拟机要检查内部拘留列表中这个字符序列是否已经存在，如果已经存在，虚拟机使用已经存在的字符串对象的引用。否则创建一个新的字符串对象，并把它加入到拘留列表中。
			在java程序中可以通过调用String类的intern()方法来拘留一个字符串。所有字面上表达的字符串，都在解析CONSTANT_String_info入口的过程中被拘留了。
		解析其他类型的入口
			CONSTANT_Utf8_info和CONSTANT_NameAndType_info类型的入口永远不会被指令直接引用。他们只有通过其他入口类型才能被引用，并且在那些引用入口被解析时才被解析。
		装载约束
			如果引用类型和被引用类型并非由同一初始类装载器装载，虚拟机必须确保在字段或方法描述符中提及的类型在不同的命名空间中保持一致。
			装载约束中的每一个约束基本上都表明了一个命名空间中的某个名字必须和另一个命名空间中的同一个名字指向同一类型数据。每个虚拟机都需要维护一个这些约束的列表，当虚拟机遇到一个类型引用另一个类型的字段或方法，但这两个类型有不同的装载器装载时，虚拟机就会在约束列表中添加一个相应的约束。
		编译时常量解析
			被初始化为编译时常量的静态final变量的引用，在编译时被解析为常量值得一个本地拷贝，这对于所有基本类型和String类型都是正确的。
			常量值的本地拷贝使得静态final变量可以用于switch语句的case表达式。因为case值不支持运行时解析。
			隐藏在常量的特殊处理后面的另一个动机是条件编译。
		直接引用
			指向类型、类变量、类方法的直接引用可能是指向方法区的本地指针。
			指向实例变量和实例方法的直接引用都是偏移量。实例变量的直接引用可能是从对象的映像开始算起到这个实例变量位置的偏移量。实例方法的直接引用可能是方法表的偏移量。
			当通过接口引用来访问实例方法时，直接引用不能保证得到方法表偏移量。不管何时虚拟机从接口引用调用一个方法，它必须搜索对象的类的方法表来找到一个合适的方法。
	_quick指令
		是一种用来加速字节码解释的技术。如果常量池入口已经被解析过，使用常量池入口的操作就会被一个“_quick”操作码取代。
		虚拟机的核心指令集包括200条单字节操作码，在class文件中只会见到这200条操作码，使用“_quick”技术的虚拟机实现内部还另外使用25条"_quick"单字节操作码
	示例：Salutation程序的连接
	示例：Greet程序的动态扩展
	使用1.1版本的用户自定义类装载器
	使用1.2版本的用户自定义类装载器
		java.lang.ClassLoader类中的loadClass()的工作方式
			1。查看请求的类型是否已经被这个类装载器装载进命名空间了
			2。否则，委派到该类装载器的双亲类装载器
			3。如果双亲装载器未能装载，调用findClass().findClass()会试图寻找一个字节数组，内容采用java calss文件格式。如果成功，findClass()把这个字节数组传递给defineClass()，defineClass()试着导入该类型到内部的数据结构，并返回一个Class实例。
			4。否则，findClass()抛出异常来中止处理，loadClass()也抛出同样的异常来中止。
	示例：使用forName()的动态扩展
	示例：卸载无法触及的Greeter类
	示例：类型安全性与装载约束

	
垃圾收集
	为什么要使用垃圾收集
		在一个虚拟内存系统中，增长的堆所需要的额外分页（或交换）空间会影响运行程序的性能。在内存较小的嵌入式系统中，碎块导致虚拟机产生不必要的“内存不足”的错误
		使用垃圾收集堆，有一个潜在的缺陷是它加大了程序的负担，可能影响程序的性能。
	垃圾收集算法
		垃圾收集算法做两件事：1。检测出垃圾对象	2。回收垃圾对象所占用的堆空间并还给程序。
		垃圾检测通常通过建立一个根对象的集合并且检查从这些根对象的可触及性来检测。
		java虚拟机的根对象集合根据实现的不同而不同。它包括以下来源：
			1。类变量、局部变量中的对象引用和栈帧的操作数
			2。被加载的类的常量池中的对象引用。比如表示类型名字的字符串
			3。传递到本地方法中，没有被本地方法释放的对象引用
			4。java虚拟机运行时数据区中从垃圾收集的堆中分配的部分。比如在某些实现中，方法区中的类型数据所占的空间从垃圾收集的堆中分配，这样类型数据也可以被垃圾回收。
		区分活动对象和垃圾的两个基本方法是引用计数和跟踪。跟踪垃圾收集器是追踪从根节点开始的引用图，在追踪中遇到的对象打上标记，追踪结束时，未被标记的对象就是不可触及的。
	引用计数收集器
		好处：可以很快的执行，交织在程序的运行中
		坏处：1。无法检测出循环引用的情况 2。维护引用计数会带来额外开销
	跟踪收集器
		要么在对象本身设置标记，要么用一个独立的位图来设置标记。
		基本的追踪算法被称作“标记并清除”。在java虚拟机中，清除步骤必须包括对象的终结
	压缩收集器
		标记并清除收集器在对付堆碎块时通常使用的两种策略是压缩和拷贝。这两种方法都是快速移动对象来减少堆碎块。
		压缩收集器把活动的对象越过空闲区滑动到堆的一端。在这个过程中，堆的另一端出现一个大的连续空闲区。
	拷贝收集器
		拷贝垃圾收集器把所有活动对象移动到一个新的区域。
		这种方法的好处是可以在从根对象开始的遍历过程中随着发现而被拷贝，不再有标记和清除之分。
		一般的拷贝收集器算法被称为“停止并拷贝”。在这个方案中，堆被分为两个区域，任何时刻都只是用其中的一个区域。当一个区域消耗完后，中止程序，进行拷贝。
	按代收集的收集器
		简单拷贝收集器浪费效率的一个主要原因是每次拷贝都针对所有的活动对象进行，这样会把一些生命周期很长的对象来回拷贝，消耗大量的时间。
		按代收集的收集器，堆被划分为两个或更多的子堆。每一个子堆为一“代”对象服务。最年幼的那一代进行最频繁的垃圾收集。如果一个年幼对象在经过多次收集后仍存活，就被移动到寿命更高的代的堆中。
	自适应收集器
		自适应算法监视堆中的情形，并且对应的调整为合适的垃圾收集技术。可能简单调整收集算法的参数，或者切换到另外一种收集算法，或者把堆划分为多个子堆，不同的子堆用不同的收集算法。
	火车算法
		垃圾收集算法和明确释放对象比起来有一个潜在的缺点，即垃圾收集算法中程序员对安排cpu时间进行垃圾收集缺乏控制。要精确预测出何时进行垃圾收集，需要多长时间都是不可能的。
		为了使垃圾收集对程序运行的影响尽可能的小，可以采用渐进式收集算法。渐进式垃圾收集器并不是试图一次性发现并回收所有的不可触及对象，而是每次发现并回收一部分。
		如果有这样一个采用渐进收集方法的收集器，每次收集可以保证不超过一个最大时间长度，就可以让java虚拟机适合实时环境。
		通常渐进式收集器都是按代收集的收集器。
		在按代收集的收集器中，除了最高寿的年龄层（成熟对象空间）之外，可以为每一个子堆给定一个最大尺寸，按代收集的收集器可以保证在一个最大时间值之内渐进的收集所有的对象（最高寿的除外）。最高寿的年龄层（成熟对象空间）无法给定最大尺寸，因为任何其他年龄层中不再适合的对象总要有个去处，他们没有其他地方可去。
		关于“成熟对象空间“、按代收集和火车算法之间的关系：成熟对象空间指的是按代收集器中最高寿的年龄层。有上面可知，这一部分不能指定最大尺寸，因此可能会变得很大，对垃圾回收来说是个问题，因此成熟对象空间的组织以及垃圾回收的方法就很重要。火车算法就详细的说明了按代收集的垃圾收集器的成熟对象空间的组织，火车算法的目的是为了在成熟对象空间提供限定时间的渐进收集。
		火车算法是用来替代按代收集策略的吗？不是的，可以说，火车算法是对按代收集策略的一个有力补充。我们知道按代收集策略把堆划分为多个”代“，每个代都可以指定最大size，但是”成熟对象空间“除外，”成熟对象空间“不能指定最大size，因为它是”最老“对象的最终也是唯一的归宿，除此之外，这些”老家伙“无处可去。而你无法确定一个系统最终会有多少老对象挤进”成熟对象空间“。
		车厢、火车和火车站
			火车算法把成熟对象空间划分成固定长度的内存块，算法每次在一个块中单独执行。
			”火车算法“的名字来源于算法组织成熟对象空间（火车站）中这些块的方式，每个块（车厢）属于一个集合（火车），集合中的块排了序，这些集合本身也排了序。
			对象从较低年龄层的子堆中提取出来进入到成熟对象空间，或者附加到已经存在的火车上（最小号码的火车除外），或者加入到专为容纳他们而创建的一列或多列火车中。
		车厢收集
			每一次火车算法执行时，要么收集最小数字火车中的最小数字车厢，要么收集整列最小数字火车。
			一次收集最小数字火车的情况：
				如果不存在最小数字火车之外的引用指向它包含的对象，那么最小数字火车内的对象都是垃圾。这种一次收集一列火车的情况有两个好处：1。一次完成较大块内存的回收	2。可以回收那些无法在一个块中容纳的循环数据结构，这个需要算法如何移动火车内的对象的配合。
			一次收集一个车厢的情况：
				当无法一次收集整列火车时，算法将注意力集中到最小数字火车的最小数字车厢。在最小数字车厢的处理过程中，算法或者释放或者移动车厢中的对象。
				算法将被最小数字车厢外部引用的对象移动到其他车厢中去，这样最小车厢中剩下的就都是没有被引用的垃圾。
			保证整列火车没有循环数据结构的关键是算法如何移动对象。算法移动对象的步骤如下：
				1。如果正在被收集的车厢中存在来自成熟对象空间之外的引用，该对象被移动到正在被收集的火车之外的其他车厢中。
				2。如果正在被收集的车厢中存在来自成熟对象空间内其他火车的引用，该对象被移动到相应的火车中，然后检查被移动的对象是否包含对正在被收集的车厢内的对象的引用，如果存在，也将该被引用对象移动到引用它的火车中。如此递归，直到没有其他火车到被收集车厢的引用。如果相应的火车没有空间了，算法会创建一个新的车厢，附加到火车的尾部。
				3。如果正在被收集的车厢中存在来自相同火车的其他车厢的引用，被引用对象被移动到该火车的最后一节车厢中。然后检查被移动的对象，查找对原被收集车厢的引用，任何新发现的被引用对象也被转移到同一列火车的尾部。如此递归，直到没有同列火车其他车厢到被收集车厢的引用。
				4。算法释放最小数字车厢内的剩余对象
			火车算法最重要的方面之一是它保证大型的循环数据结构会完全被收集，即使他们不能放置在一个车厢内。因为对象引用被移动到引用他们的火车中，相关的对象会变得集中。增大循环数据结构的大小，只会增大最后组成一列火车的车厢数。
		记忆集合和流行对象
			为了促进收集过程，火车算法使用了记忆集合。记忆集合是一个数据结构，记录了所有对一节车厢或一列火车的外部引用。算法为成熟对象空间内的每节车厢和每列火车都维护一个记忆集合。
			当火车算法把一个对象移动到另一节车厢或另一列火车时，记忆集合中的信息有助于它更高效的更新所有指向被移动对象的引用，他们就可以指向新的位置。
			虽然火车算法每次执行时需要拷贝的字节总数受限于块的大小，但移动一个被很多对象引用的对象所需要的工作也是不确定的。因为移动对象需要更新所有指向它的引用。
	终结
		存在终结方法时，垃圾收集器处理需要一些额外的步骤：
			1。首先检测出所有不再被引用的对象
			2。检查不再被引用的对象是否声明了finalize方法，如果时间允许，可能在这个时候就开始着手处理这些终结方法。
			3。当所有终结方法运行完后，收集器从根节点再次检测不再被引用的对象。这个步骤是必要的，因为终结方法可能复活了某些不再被引用的对象。最后，垃圾收集器才释放那些在第一次和第二次扫描均被标记为不再被引用的对象。
		为了加快内存释放的速度，垃圾收集器可以在检测出不再被引用对象拥有终结方法和运行这些终结方法之间，插入一个可选的步骤。它运行一次小型的追踪，立即释放那些满足下面条件的对象--从根节点不可触及（第一次扫描发现）以及从将要被释放的对象开始不可触及，因为这些对象不可能在执行终结方法时复活。
	对象可触及性的生命周期
		在版本1.2之前，在垃圾收集器看来，堆中的每个对象都处于三种状态之一：可触及的、可复活的以及不可触及的。
			可触及的：从根节点开始，可以追踪到该对象，它是可触及的
			可复活的：从根节点开始追踪不可触及，但有可能是垃圾收集器执行终结方法时可触及。在执行了所有终结方法后，垃圾收集器把可复活对象或者转化为可触及的，或者转化为不可触及的
			不可触及的：不再被触及，并且不可能被复活。可以回收这部分对象。
		在版本1.2中对原来的可触及性扩充了3个新的状态：软可触及、弱可触及和影子可触及。原来状态中的“可触及的”在1.2中被称为“强可触及”。任何从强可触及对象可触及的对象也是强可触及的。
		引用对象
			可触及性的三个扩充状态和在版本1.2中加入的新的实体--引用对象有关。引用对象封装了指向其他对象的连接。所有引用对象都是抽象类java.lang.ref.Reference的子类。它包含了三个直接子类：SoftReference（软引用）, WeakReference（弱引用）, PhantomReference（影子引用）。
			强引用和较弱形式的引用--软引用、弱引用和影子引用--之间最基本的差别是，强引用禁止引用目标被垃圾收集，而软引用、弱引用和影子引用不禁止。
			要创建一个软、弱和影子引用，只需要把强引用传递到对应对象引用的构造方法中去。如果一个对象只有软、弱和影子引用指向它，那么该对象就是软、弱和影子可触及的。
			一旦一个引用对象创建后，他就维持一个到引用目标的软、弱和影子引用，直到它被程序或者垃圾收集器清除。要清除一个引用对象，程序和垃圾收集器只需要调用引用对象的clear方法。调用了clear方法就切断了引用对象和引用目标之间的关联。
		可触及性状态的变化
			引用对象的目的是为了能够指向某些对象，这些对象仍然随时可以被垃圾收集器收集。
			如果想要跟踪引用目标的可触及性变化，可以在构造引用对象时传递一个引用对列。当引用目标的可触及性发生变化时，垃圾收集器将相应的引用对象加入到相关联的引用对列中去。
			为了把引用对象加入到引用对列中去，垃圾收集器调用引用对象的enquence()方法。只有当引用对象关联引用对列，并且该引用对象第一次调用enquence()方法时，才把引用对象放入到引用对列。
			有两种方法从引用对列获得引用对象：poll()和remove()。poll()是非阻塞的，remove()是阻塞的。
			六种可触及性状态转化的情况如下：
				强可触及：只要有根节点或强可触及对象引用它，它就是强可触及的。垃圾收集器不会试图回收强可触及对象占据的空间。
				软可触及：垃圾收集器可能回收软可触及的对象所占据的内存。如果这发生了，它会清除所有到该软可触及对象的软引用，然后马上或者在过后的某一时间，将该引用对象加入到关联的引用对列。
				弱可触及：垃圾收集器必须归还弱可触及对象所占据的内存。如果这发生了，它会清除所有到该弱可触及对象的弱引用，然后马上或者在过后的某一时间，将该引用对象加入到关联的引用对列。
				可复活的：对象不是强、软、弱可触及的，但可能通过执行某些终结方法复活到这几种状态之一。
				影子可触及：对象不是强、软、弱可触及，并且被断定不能被任何终结方法复活（如果它自己定义了终结方法，它的终结方法已经被运行过了），并且只能通过一个或多个影子引用对象触及。一旦某个影子引用指向的引用对象的状态变为影子可触及，垃圾收集器立即把该影子引用加入到关联的引用对列。垃圾收集器不会清除影子引用，所有的影子引用必须有程序进行清除。如果一个引用目标到了影子可触及状态，它不可能再被复活。
				不可触及：不可触及的对象已经准备好被回收了
			垃圾收集器把软引用和弱引用对象加入引用对列是在垃圾收集器回收引用目标，引用目标的可触及性状态发生变化，并且引用对象被清除之后。把影子引用加入引用对列是在引用目标进入影子可触及性状态时。垃圾收集器不会清除影子引用。
		缓存、规范映射和临终清理
			垃圾收集器对待软、弱和影子引用的方式不同，使他们可以为程序提供不同的服务。
				软引用可以创建内存中的缓存，它与程序的整体内存需求有关。
				弱引用可以用来创建规范映射，比如哈希表，它的关键字和值在没有程序其他部分的引用时可以从映射中清除。
				影子引用可以使你实现除终结方法以外的更加复杂的临终清理政策。
			可以通过调用软、弱引用的get方法得到引用目标。当软、弱引用被清除后，get方法将返回null。影子引用不管是否被清除，其get方法都返回null。
			虚拟机实现需要在抛出OutOfMemoryError之前清除软引用。软引用可以让你在内存缓存那些费时从外部数据源取回的数据。
			对于弱引用，垃圾收集器必须在判断出引用目标处于弱可触及状态时就立即清除弱引用。
			java.util.WeakHashMap类就是用弱引用来提供规范映射。在WeakHashMap中，key是用一个关联到引用对列的弱引用来实现的。如果垃圾收集器发现某个key对应的引用目标是弱可触及的，就会将该引用对象加入到引用对列。当下次访问WeakHashMap时，它从引用对列中获得所有垃圾收集器放入的弱引用对象，清除WeakHashMap中任何关键字属于引用对列中的弱引用的键值对。
			当把一个键值对加入到WeakHashMap中后，在程序显式的是用remove或垃圾收集器检测出关键字对象处于弱可触及状态之前，键值对会一直保留在WeakHashMap中。
			可以利用引用对列中影子引用的到来来触发一些希望在对象生命周期的最后时刻需要完成的动作。因为无法获得影子可触及对象的强引用，因此无法完成那些需要访问影子目标的实力变量的动作。在完成了影子可触及对象的临终清理后，程序需要自己清除影子引用。影子引用被清除后，其引用目标从影子可触及状态转化到不可触及状态。
		一个模拟：Heap of Fish

		
栈和局部变量操作
	常量入栈操作
		操作码在执行常量入栈操作之前，使用如下三种方式指明常量的值：
			1。常量值隐含的包含在操作码内
			2。常量值在字节码中如同操作数一样紧随在操作码之后
			3。从常量池中获得常量
		因为常量池是每个class文件独有的，但堆在虚拟机中只有一个。因此对于不同类中的相同字符串，他们存在于各自的class文件的常量池中。但虚拟机只会为他们在堆中创建一个String对象。
	通用栈操作
		尽管指令集中的大多数指令都只处理一种特定的类型，但还有一些指令可以进行类型无关的栈操作。
	把局部变量压入栈
	弹出栈顶部元素，将其赋给局部变量
	wide指令
		无符号8位局部变量索引，将方法中局部变量数限制在256个。wide指令可以将8位的索引扩展8位，从而将局部变量数扩展到65536个。
		跟随在wide操作码和修改过的操作码之后的两个字节组成指向局部变量的16位索引，比如wide iload 257。
		跳转指令不允许直接跳转到被wide指令修改过的操作码处。即wide操作码和被修改的操作码是一个整体。

		
类型转换
	转换操作码
		虚拟机有许多进行基本类型转换工作的操作码，这些操作码后面没有操作数，操作的值从栈顶获得，并将转换的结果压入栈顶。
		byte、short、char类型值在压入栈时已经转换为int类型值了
		涉及byte、short、char类型值的运算操作，现将其转换为int，用int值进行运算，最后得到int类型的结果。比如byte a = 1; byte b = 2; byte c = a + b;是错误的，应该是int c = a + b;

		
整数运算
	二进制补码运算
		java虚拟机所支持的所有整数类型--byte, short, int, long,他们都是带符号的二进制补码数。
		能够被二进制补码方案表示的数的范围为：2的总位数次幂。
		负数的补码可以通过将负数与2的总位数次幂相加得到。
		在带符号的二进制补码数上进行的加法运算与在无符号的二进制数上进行的加法运算一样。两个数相加（忽略溢出），结果被解释为一个带符号的二进制补码数。
		java虚拟机中进行的整数运算的溢出并不会抛出异常，其结果只被简单的截短以符合数据类型。
		如果long类型的长度仍不能满足需求，可以使用java.match.BigInteger，这个类可以描述任意长度的整数。
	运算操作码
逻辑运算
	逻辑操作码
		java虚拟机中并不存在本地的boolean类型，java虚拟机使用int类型表示boolean类型。
		布尔运算针对整数值的每一位进行操作。
浮点运算
	浮点数
		java虚拟机的浮点支持符合IEEE-754 1985浮点标准，该标准定义了23位和64位浮点数的格式及这些浮点数的运算。
		浮点数由符号、尾数、基数和指数组成。符号*尾数*基数的指数次幂。尾数永远为正数。指数可以为正也可以为负。
		java虚拟机中的浮点数使用2为基数。
		Java虚拟机中浮点数的尾数使用二进制来表示。它并不是二进制补码数。
		对于float和double，符号位是最高有效位，尾数在float类型中占最低有效位的23位，在double类型中占最低有效位的52位。指数位于符号位和尾数之间，在float类型中占8位，在double类型中占11位。
		指数位的解释有三种方式：
			1。指数位全为1，表示该数为乘法或减法所产生的特殊值之一--无穷大或非数字（NaN）。NaN是某种特殊操作，诸如0除以0的结果。
			2。指数位均为0，表示该数为一个非规范化浮点数
			3。其他类型的指数位均表示该数为一个规范化浮点数。
		将一个浮点数表示为标准格式的步骤为（以11.375为例）：
			1。将浮点数表示为二进制格式。11.375 = +1011.011
			2。将二进制格式表示成标准形式，即整数部分为1。+1011.011 = +(1.011011) * 2 ^ 3。注意二进制中乘以2的几次幂就表示小数点移动多少位。
		尾数区域包含一位附加精度。比如float类型的位数域有23位，但它又24位精度。由于浮点数是否是规范化的和其尾数的最高有效位（尾数的整数部分）有关。若浮点数是规范化的，则最高有效位为1，否则为0。而虚拟机中的浮点数的指数指明该数是否为规范化的，因此其尾数的最高有效位是可以预知的，所以没有划入尾数的范围。这个最高有效位就是所说的附加精度位。如果指数全为0，则该浮点数是非规范化的，可知尾数的最高有效位为0。否则浮点数为规范化的，可知尾数的最高有效位为1。
		IEEE754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字。
		虚拟机在任何浮点操作中都不抛出异常。用特殊值（正/负无穷大或NaN）来作为可以操作的结果返回。
		指数位全为1表示特殊的浮点值：
			指数位全为1，而尾数位全为0，表示无穷大。无穷大的符号由符号位决定。
			指数位全为1，而尾数位不全为0，表示NaN。虚拟机总为NaN产生相同的尾数：除了尾数位的最高位为1外，其余位均为0。
		如果指数位既不全为0，也不全为1，则该浮点数为规范化的。
		可以通过把指数位看作是一个正数，然后从这个正数中减去一个偏移量的方法来确定2的幂指数。对于float类型，偏移量为127。对于double类型，偏移量为1023。
		指数位全为0表示尾数为非规范化的，意味着尾数位的隐含最高有效位为0，而非1。此时2的幂指数与规范化尾数的2的幂指数最小值相等。对于float，该值为-126（因为规范化尾数的指数部分既不全为0，也不全为1）。
		指数位全为0。这时，浮点数的指数E等于1-127（或者1-1023），有效数字M（尾数）不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。
		当指数位全为0时，其2的幂指数与规范化尾数的2的幂指数的最小值（-126/-1022）相等。这个规定使渐进式下溢成为可能。
		关于渐进式下溢和突然式下溢（来自维基百科）：
			IEEE 754-1985标准采用非规约浮点数，源于70年代末IEEE浮点数标准化专业技术委员会酝酿浮点数二进制标准时，Intel公司对渐进式下溢出(gradual underflow)的力荐。当时十分流行的DEC VAX机的浮点数表示采用了突然式下溢出(abrupt underflow). 如果没有渐进式下溢出，那么0与绝对值最小的浮点数之间的距离(gap)将大于相邻的小浮点数之间的距离。例如单精度浮点数的绝对值最小的规约浮点数是1.0*2^-126, 它与绝对值次小的规约浮点数之间的距离为2^-126*2^-23=2^-149。如果不采用渐进式下溢出，那么绝对值最小的规约浮点数与0的距离是相邻的小浮点数之间距离的倍！可以说是非常突然的下溢出到0。这种情况的一种糟糕后果是：两个不等的小浮点数X与Y相减，结果将是0. 训练有素的数值分析人员可能会适应这种限制情况，但对于普通的程序员就很容易陷入错误了。采用了渐进式下溢出后将不会出现这种情况。例如对于单精度浮点数，指数部分实际最小值是(-126)，对应的尾数部分从1.1111...11,1.1111...10 一直到0.0000...02, 0.0000...01，相邻两小浮点数之间的距离(gap)都是2^-126*2^-23=2^-149；而与0最近的浮点数(即最小的非规约数)也是2^-126*2^-23=2^-149。
	浮点模式
		java虚拟机规范第二版略微放松了对于java虚拟机中浮点操作的控制。最初的规范要求：所有单精度和双精度浮点运算都必须符合IEEE 754所规定的单精度和双精度格式。虚拟机规范第二版在某些特定条件下允许在浮点运算中使用扩展精度格式。
		新的浮点规则规定：每个方法都要有一个浮点模式，该方法的ACC_STRICT标志的值决定其浮点模式。如果设定了一个方法的ACC_STRICT标志，其浮点模式为FP-strict，反之，其浮点模式为not FP-strict。新的浮点规则还为java语言引入了新的关键字-strictfp。
		浮点值集合
			第二版规范还允许虚拟机实现支持两种扩展的浮点值集：float-extended-exponent值集和double-extended-exponent值集。
			相比相应的标准值集而言，扩展的浮点值集允许使用更大的指数来表示一个值，但符号位和尾数位的长度不变。
		浮点值集的转换
			新的浮点规则允许虚拟机实现使用扩展值集表述操作数栈上的float和double类型的特定表达式。当使用FP-strict模式时，必须使用标准值集，反之，允许使用扩展值集。
			从扩展值集向标准值集转换时可能会发生上溢或下溢。如果发生上溢，结果将是与原值相同符号的无穷大。如果发生下溢，结果可能是比原值精度更差的非规范化浮点数，也可能是与原值符号相同的0。
		相关规则的本质
			由于放松了对浮点规则的限制，java虚拟机规范第二版也不再严格承诺“java程序将在任何虚拟机上有同样的表现”。因为有可能有些虚拟机使用扩展值集，有些没有使用。
			运算时只有当在FP-default中会上溢或下溢，而在FP-strict中不会发生时，这两种模式下的结果才会不同。
	浮点操作码

	
对象和数组
	关于对象和数组的回顾
		只有对象引用和基本类型可以在java栈中作为局部变量存在。java栈不能容纳对象。
		虽然数组引用和对象引用相同，虚拟机仍然使用特殊的操作码来处理数组。
	针对对象的操作码
		大多数指令都涉及常量池入口。
		new操作码后面跟连个字节的操作数，该操作数代表常量池的索引。
	针对数组的操作码
		对于boolean类型的数组，虚拟机实现可以用位的方式来实现，也可以用byte数组的方式来实现。无论用那种方式实现，都会使用存取byte数组元素的操作码访问boolean数组的元素。
		
		
控制流
	条件分支
		方法中可以使用if, if-else, while, do-while, for和switch来进行基本的控制流。在字节码中，出switch之外，java编译器使用相同的操作码集。
		对于所有的条件分支操作码，虚拟机都通过同样的过程来决定下一条将要被执行的指令。虚拟机首先执行由操作码所决定的比较。如果比较失败，虚拟机将将继续执行条件分支语句右面的语句。如果比较成功，虚拟机使用紧随操作码之后的2个字节来产生16位的偏移量。虚拟机给当前pc寄存器加上这个偏移量来获取目标地址。
	无条件分支
		虚拟机根据紧随goto指令后的两个字节，得到有符号的16位偏移量，然后给当前pc寄存器加上这个偏移量来获取目标地址。
	使用表的条件分支
		tableswitch和lookupswitch指令都包含一个默认的分支偏移量和一组可变长度的“case值/分支偏移量”。这两个指令是整个虚拟机指令集中仅有的考虑了边界对齐的多字节指令。


异常
	异常的抛出与捕获
		所有Error和RunntimeException子类的异常都是未检验异常，程序即使可能抛出此异常，方法中也可以不在throws语句中声明对此异常的处理。
	异常表
		每当抛出异常，虚拟机在异常表中查找异常，跳转到实现catch字句的字节码序列。
		每个捕获异常的方法都与异常表相关联，该异常表与方法的字节码一起送到class文件中
		每一个被try语句块捕获的异常都与异常表中的一个入口相对应。
		异常表中每个入口包括四个部分的信息：try块的起点、try块的终点、将要跳转到字节码序列中的字节码指针偏移量、被捕获的异常类的常量池索引。
		每当异常抛出时，虚拟机用当前pc寄存器的值去异常表中和每个入口的起点和终点比较。虚拟机按照每个入口在异常表中出现的顺序进行检测。当匹配到第一项时，就修改pc寄存器的值为异常表中将要跳转到字节码序列中的字节码指针偏移量。如果没有匹配项，虚拟机终止当前方法的执行，返回调用当前方法的方法，并抛出同样的异常。
	

finally子句
	微型子例程
		字节码内的finally子句在方法内部的表现很像“微型子例程”。java虚拟机在每个try语句块和与其相关的catch语句块的结尾处都会“调用”finally子句的子例程。finally子句结束后（这里的结束是指finally子句的最后一条语句正常执行结束，不包括抛出异常，执行return, continue, break等情况）。隶属于这个finally子句的微型子例程执行“返回”操作。程序在第一次调用微型子例程的地方继续执行后面的语句。
		虚拟机在“调用”finally子句的子例程时，将返回地址压入栈，然后开始执行finally子句的子例程。当子例程执行完后，再通过刚才的返回地址，继续执行。
	不对称的调用和返回
		你也许会认为，finally子句的子例程应该从栈中弹出返回地址，因为返回地址在进入finally子句的子例程时被压入栈中。其实不是这样的。在每一个子例程开始处，返回地址都被从栈中弹出，存储在局部变量中，当finally子句的子例程执行完后，从该局部变量获得返回地址。这种对返回地址的不对称的工作方式是必要的，因为finally子句本身可能抛出异常，执行return, continue, break等语句。由于这种可能性，这个返回地址需要立即从栈中移除，这样当finally子句通过抛出异常或执行return, continue, break等语句退出时，就不需要考虑这个问题了。
		无论使用break, continue, return或抛出异常的方式退出finally子句，finally子句子例程的最后通过获取保存的返回地址进行返回的操作都不会被执行了。
		方法和字节码示例：
			class Nostalgia{
				static int giveMeThatOldFashionedBoolean(boolean bVal){
					try{
						if(bVal){
							return 1;
						}
						
						return 0;
					} finally{
						System.out.println("Get Old Fashioned.");
					}
				}
			}	
			方法giveMeThatOldFashionedBoolean()被编译为如下的字节码：
				//The byte code sequence for the try block
				0	iload_0			//Push local variable 0(vVal parameter)
				1	ifeq 11			//Pop int, if equal to 0, jump to 11(just past the if statement):if(bVal){}
				4	iconst_1		//Push int 1
				5 	istore_1		//Pop an int(the 1), store into local variable 1
				6	jsr 24			//jump to the mini-subroutine for the finally clause
				9	iload_1			//Push local variable 1(the 1)
				10 	ireturn			//Return int on top of the stack(the 1): return 1;
				11	iconst_0		//Push int 0
				12 	istore_1		//Pop an int(the 0), store into local variable 1
				13	jsr 24			//jump to the mini-subroutine for the finally clause
				16	iload_1			//Push local variable 1(the 1)
				17	ireturn			//Return int on top of the stack(the 0): return 0;
				
				//The byte code sequence for a catch clause that catches any kind of exception thrown from within the try block
				18	astore_2		//Pop the reference to the thrown exception, store into local variable 2
				19	jsr	24			//jump to the mini-subroutine for the finally clause
				22 	aload_2			//Push the reference(to the thrown exception) from local variable 2
				23	athrow			//Rethrow the same exception
				
				//The miniature subroutine that implements the finally block
				24	astore_3		//Pop the return address, store into local variable 3
				25	getstatic #7 <Field java.io.PrintStream out>	//Get a reference to java.lang.System.out
				28	ldc	#1 <String "Got old fashioned."> 	//Push reference to "Got old fashioned." String from the constant pool
				30	invokevirtual #8 <Method void println(java.lang.String)>		//Invoke System.out.println()
				33 	ret	3			//Return to return address stored in local variable 3
			该字节码说明的问题有：
				1。对只有try和finally语句的代码，编译期会生成一个可以捕获所有异常的catch块。在该catch块中，现将要抛出的异常存到局部变量中，再调用finally子句子例程，从finally子句返回后，再抛出异常。
				2。当try块中有return语句时，先将return的值存到局部变量中，然后调用finally子句的子例程，从finally子句正常返回后，从局部变量中得到return的值，再返回。所以在finally子句中再改变return的值不会对返回值有影响。
				3。在执行finally子句子例程时，现将返回地址存储到局部变量，finally最后一条语句正常执行完后，返回时，从局部变量中获取返回地址返回。如果finally子句非正常返回，最后一条ret语句不会执行，finally语句可能就返回不到刚开始调用它的地方了。
			
		
方法的调用与返回
	方法调用
		实例方法使用动态绑定，类方法使用静态绑定。
		方法调用指令后跟2个字节的操作数，它们是指向常量池的16位无符号索引。
		方法调用指令的参数，需要在方法调用指令执行前，被其他指令压入所调用方法的操作数栈。
		java方法的调用
			方法的栈帧中的局部变量和操作数栈的大小在编译时计算出来，并放置到class文件中。
			在调用实例方法时，虚拟机从调用方法的栈帧内的操作数栈中弹出objectref(this)和args(其他参数)。虚拟机把objectref(this)作为局部变量0放到所调用方法的栈帧中，args（其他参数）放到所调用方法的栈帧的局部变量1，2。。。中。
		本地方法调用
			当调用一个本地方法时，虚拟机不会将一个栈帧压入栈。当线程进入本地方法的那一刻，它就将java栈抛在身后，直到从本地方法返回后，java栈才被重新使用。
	方法调用的其他形式	
		java虚拟机总是直接调用类初始化方法<clinit>，类初始化方法永远不会被任何字节码调用。
		方法调用指令有四种：
			invokevirtual	调用实例方法
			invokestatic	调用类方法
			invokespecial	调用实例初始化方法<init>，私有方法，使用super关键字调用的方法
			invokeinterface	通过接口引用调用方法
	指令invokespecial
		invokespacial和invokevirtual的区别在于：invokespecial通常通过根据引用的类型选择方法，而不是根据对象的类选择。也就是说它是采用静态绑定，而非动态绑定。
		指令invokespacial和<init>方法
			使用new创建一个对象的过程可以大致分为两步：首先创建一个到对象的引用，并压入栈（对象未被完全初始化）。然后通过该对象引用调用实例初始化方法。
		指令invokespecial和私有方法
		指令invokespecial和super关键字
			当使用super关键字来调用方法时，尽管当前类重载了该方法，但使用者真正希望调用的是超类的方法。
			当使用super关键字调用超类的方法时，它会动态搜寻当前类的超类，找到离得最近的超类中的该方法的实现。
	指令invokeinterface
		指令invokevirtual和invokeinterface的功能相同：调用实例方法并使用动态绑定。它们的区别在于当引用的类型为类时，使用invokevirtual，当引用的类型为接口时，使用invokeinterface。
		对于类引用来说，无论对象实际的类是什么，方法在方法表中始终占据相同的位置。但对于接口来说，不同类中的同一方法占据的位置是不同的，尽管它们实现了同一个接口。因此调用接口方法比调用实例方法要慢。
	指令的调度和速度
		最快的是invokespecial和invokestatic。最慢的是invokeinterface，因为每次都要解析方法表。
	方法调用的实例
	从方法中返回
		从方法返回的操作吗没有操作数。如果有返回值，它必须被放置在操作书栈中。返回值从操作数栈中弹出，被压入到调用方法栈帧的操作数栈中。
	
	
线程同步
	java所使用的同步机制是监视器
	监视器
		java中的监视器支持两种线程：虚拟机通过对象锁实现互斥，通过Object的wait和notify来实现同步。
	对象锁
		java虚拟机中，每个对象和类在逻辑上都是和一个监视器相关联的。对对象来说，相关联的监视器保护对象的实例变量。对于类来说，相关联的监视器保护类的类变量。
		类锁实际上是通过对象锁实现的。当锁住一个类的时候，实际上锁住的是类的Class对象。
		一个线程允许多次对同一个对象上锁。
	指令集中对同步的支持
		同步语句
			方法内的同步语句块会使用：monitorenter和monitorexist这两个操作码。
			编译器会为同步语句生成一个catch子句（异常表），保证同步语句中抛出异常时，锁被释放。
		同步方法
			当虚拟机解析方法的符号引用时，判断该方法是否是同步方法，如果是，在方法将要被调用时获得锁，在方法执行完毕时，无论是正常返回还是抛出异常，都会释放该锁。
			编译器不会为同步方法生成异常表（catch子句），释放锁的动作由虚拟机保证，无论方法是正常退出还是异常退出。
	Object类中的协调支持
		关于Object类的wait和notify方法，只有在同步方法或同步语句中才能调用这些方法。也就是说这些方法被调用时，相关对象必须已经获得了锁。
