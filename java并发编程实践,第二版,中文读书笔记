序
	这本书的内容可以分为4个部分:
		1. 基础.
			第2-5章专注于并发和线程安全的基本概念,以及在不使用类库提供的并发构建模块(concurrent building blocks provided by class library)的情况下如何构造一个线程安全的类.
			第2章(线程安全)和第3章(共享变量)组成了这本书的基础.基本所有的解决并发缺陷,构造线程安全的类,以及判定是不是线程安全的规则都在这里.
			第4章(组合对象)介绍了组合一些线程安全的类成一个大的线程安全的类的技术.
			第5章(构建模块(building blocks))介绍了平台类库提供的并发构建模块:线程安全的容器和同步器(synchronizers).
		2. 构建并发应用.
			第6-9章描述了如何充分利用线程来提高并发应用的吞吐量和响应能力
			第6章(任务执行(task execution))介绍了如何找出可并行执行的任务并在任务执行框架(task-execution framework)中执行他们.
			第7章(取消和终止)介绍了如何让任务和线程在他们正常结束之前终止.程序如何处理取消和终止通常是区分健壮的并发程序的一个因素.
			第8章(应用线程池)介绍了任务执行框架的一些先进功能.
			第9章(图形用户界面的应用)专注于提高单线程子系统(single-threaded subsystems)的响应能力.
		3. 存活性(liveness),性能和测试.
			第10-12章涉及到确保并发程序确实在做预期想做的事,并且以可以接受的性能.
			第10章(避免存活性危险(avoiding liveness hazards))介绍了如何避免那些阻碍程序向前执行的存活性失败(liveness failure).
			第11章(性能和可扩展性)介绍了提高并发代码性能和可扩展性的技术
			第12章(测试并发程序)介绍了测试并发代码正确性和性能的技术
		4. 高级主题.第13-16章介绍了一些有经验的开发感兴趣的主题:显式锁(explicit locks),原子变量,非阻塞算法,以及开发自定义的同步器(synchronizers).

第一章 介绍			
	1.1 并发的简短历史
		最早的时候,计算机没有操作系统,它只运行单一的一个程序,该程序直接访问该计算机的所有资源.昂贵的和稀缺的计算资源得不到充分利用.
		操作系统允许多个程序同时运行,每个程序运行在一个进程中.进程之间是隔离的,独立的.由操作系统为进程分配资源,比如内存,文件指针,安全证书等.进程之间的沟通通过粗粒度的通信机制:socket, signal handlers, shared memory, semaphores, and files.
		一些因素激励操作系统允许多个程序同时运行:
			1. 资源利用. 当程序进行外部操作,如输入和输出时,cpu处于空闲状态,可以利用这段时间让其他程序运行.
			2. 公平. 应该通过细粒度的时间分片来让多个程序同时运行,而不是一个运行完另一个再开始运行.
			3. 方便性. 编写多个程序,每个程序处理一个任务,这些程序彼此之间相互合作要比只写一个程序来处理所有任务更容易或更是我们想要的.
		促进进程发展的激励因素同时也激励着线程的发展.线程允许多个程序控制流共同存在于一个进程中.它们共享进程范围内的资源,比如内存和文件指针.但是每个线程有自己的程序技术器,文件指针和本地变量.线程为多处理器机器的硬件并行机制提供了一个自然的分解(Threads also provide a natural decomposition for exploiting hardware parallelism on multiprocessor systems).一个进程内的线程可以同时被调度到多个cpu上.	
		线程有时被称作轻量级的进程.一些现代操作系统以线程为基本的调度单元,而不是进程.
		由于线程共享其所属的进程的内存地址空间,同一个进程内的所有线程能够访问同一个堆中的相同变量和为对象分配内存,从而相对于进程间的通信可以提供细粒度的数据共享.
		但如果不使用显式的同步控制,也可能导致不可预期的结果.
	1.2 线程的好处
		1.2.1 充分利用多处理器
		1.2.2 简单的建模
			每个线程只专注于处理某一种类型的任务,从而将任务的业务和调度,交错控制,异步IO,资源等待等隔离开.每个线程独立运行自己的逻辑,只有在某个指定的同步点进行交互.
		1.2.3 简化异步事件的处理
			如果只有一个线程处理请求,那么当其阻塞时,它将不能响应其他请求.但如果是多线程,其中一个线程接受请求,为每一个请求创建单独的线程来处理,那么即使某一个线程阻塞,也不会影响其他请求.
		1.2.4 用户界面更好的可响应性
	1.3 线程的风险
		1.3.1 安全危险
			线程安全是想不到的微妙,因为在没有足够同步时,多个线程的操作的执行顺序是不可预期的,甚至是奇怪的.
		1.3.2 存活性危险
			如果安全意味着"没有什么坏的事情发生",那么存活性考虑的就是"一些好的事情最终发生了".当一个活动到达了一个不可能再继续向前执行的状态时就意味着存活性失败发生了.
			在单线程程序里,当有无限循环时会出现这种情况.在多线程程序里,可能发生在线程A等待线程B占有的锁,但线程B一直没有释放该锁,导致线程A不能向前执行.
			死锁,饥饿,活锁(live lock)都有可能导致存活性失败(liveness failure)
		1.3.3 性能危险
			上下文切换-调度器临时阻塞活跃的线程，从而让另一个线程可以运行,在一个多线程的应用里是很平常的,并且有明显的开销:保存和恢复执行上下文,本地变量的丢失,cpu的时间花费在了调度线程而不是执行线程.
			当多个线程共享数据时,他们必须使用同步器机制,而该机制将禁止编译器优化,flush or validate memory cache, and create synchronization traffic on the shared memory bus.
	1.4 多线程无处不在
		一些框架在自己拥有的线程中,访问应用中的组件时,会将并发问题引入到应用中.应用中的组建总是会访问应用的状态,因此所有访问该应用状态的代码路径都必须是线程安全的.
		下面是一些应用中的代码被并非由应用管理的线程调用的例子,这些都会将并发问题引入到应用中:
			1. Timer
				TimerTasks是运行在由Timer管理的线程中,而不是应用管理的线程中.因此TimerTasks访问的数据也可能同时被应用中的线程访问.通常最简单的解决办法是保证被TimerTasks访问的对象本身是线程安全的.
			2. Servlet and JSP
				Servlet规范要求servlet能够被多个线程同时调用,因此servlet必须是线程安全的.
				Servlets,JSPs,servlet filters,以及存储在制定范围的容器(对于application scope范围的变量存放在ServletContext里,对于session scope范围的对象存放在HttpSession里)里的对象,都需要是线程安全的.
			3. RMI
				RMI允许我们调用运行在另一个虚拟机内的对象的方法.
				远程对象的调用是发生在由RMI管理的线程中的. 因此远程对象不仅要协调对于和其他对象共享的状态的访问,而且要协调对它自己的状态的访问,因为有可能多个线程同时访问其状态.
			4. Swing和AWT
				Swing和AWT为每个组件创建一个独立的线程,称为event thread,来处理用户出发的事件并更新显示.
				如果应用想在event thread之外操作组件,那么它必须让这些代码在event thread内执行.
				如果event thread想要访问被多个线程共享的应用状态时,必须以一种线程安全的形式来操作.
	

第一部分:基础
	第二章 线程安全
		编写线程安全的代码,其核心在于管理对共享的,可变的状态的访问
		如果多个线程在没有同步控制的情况下,同时访问同一个可变的状态,你的程序就可能有问题.有3个方法解决它:
			不要在线程间共享该状态变量
			使该状态变量是不可变的
			用同步来控制对该共享变量的访问
		当设计线程安全的类时,面向对象的技术-封装,不可变性和清楚的不可变的规范,都是你最好的朋友.
		2.1 什么是线程安全
			一个类是线程安全的,当它在多线程访问的情况下,不论运行环境下的调度和与其它线程的交错执行,在不需要调用代码做额外的同步或协调操作的情况下,能够持续的保持正确性.
			2.2.1 例子:一个无状态的servlet
				无状态的对象永远是线程安全的
		2.2 原子性
			2.2.1 竞争条件
				最常见的竞争条件的类型是check-then-act.
			2.2.2 例子:延迟初始化中的竞争条件
			2.2.3 组合动作
				组合动作:一连串必须要被原子执行的操作.
				在实践中,使用已经存在的线程安全的类,如AtomciLong来管理类的状态.推测已经存在的线程安全的类的可能的状态及其状态转移情况要比任意状态变量的类简单.并且也使维护和鉴定线程安全变得简单.
				当给一个无状态的类添加单一元素的状态时,如果该单一元素状态完全被线程安全的类管理,那么这个无状态的类仍然是线程安全的.但状态元素从1个变到多个远没有从0个变到1个那么简单.
		2.3 锁
			为了保持状态一致,在一个原子操作内更新相关的状态变量
			2.3.1 固有锁(Intrinsic Locks)
				一个synchronized块包含两个部分,一个是对将要作为锁的对象的引用,一个是该锁保护的代码块.
				一个synchronized方法是一种特殊形式的synchronized块,它的作用范围是整个方法.它使用的锁是调用该方法的对象.如果是静态方法,那么该锁是该方法对应的类的Class对象.
				每一个java对象都可以隐式的作为锁.java内嵌的锁又叫做intrinsic lock或monitor lock.它在进入同步代码块时自动获得,在离开时自动释放.
			2.3.2 重入
				java的synchronized相关的对象锁是可重入的,java中线程获得对象锁的操作是以每线程为粒度的.其实现方法是为每个锁关联一个线程持有者和计数器，当计数器为0时表示该锁没有被任何线程持有，那么任何线程都可能获得该锁而调用相应的方法；当某一线程请求成功后，JVM会记下锁的持有线程，并且将计数器置为1；此时其它线程请求该锁，则必须等待；而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增；当线程退出同步代码块时，计数器会递减，如果计数器为0，则释放该锁。
				如果java的synchronized相关的锁是不可重入的,那么子类重写父类的方法,并调用父类的方法时,会出现死锁.因为当调用父类方法,需要获得锁时,发现锁已经被拥有,但不可重入.
		2.4 用锁来保护状态
			所有对可变状态变量访问的线程,以任何方式访问该可变变量,不只是写,读也需要,都必须持有同一个锁.
			事实上每个对象都有内嵌锁只是为了便利我们不需要创建对象锁.
			对象锁和它自身的状态之间没有关系.
			一个常用的锁的惯例是封装所有的可变状态变量到一个对象中,使用该对象的固有锁来同步所有对可变状态变量的访问.
			对于含有多于一个变量的不变式,该不变式中的所有变量都必须被同一个锁保护.
		2.5 存活性和性能
			简单性和性能通常是互斥的两端.当实现同步策略时,我们拒绝过早的牺牲简单性来换取性能的提高.先保证正确性和可用性,在通过重构来优化性能.
			避免在长时间的计算或有风险不能快速完成的操作中,如网络和I/O,持有锁.这会增加死锁的风险.
			
			
	第三章 共享对象
		这章介绍如何共享和发布对象,以使它们能够被多线程安全的访问.
		一个通常的错误认识是synchronized只是应用于原子操作或划分重要代码的区域.同步还有一个明显的,微妙的方面:内存可见性.我们不仅要保证对可变共享状态的互斥访问,而且要保证一个线程共享状态的改变,对另一个线程可见.如果不使用同步,这个可见性可能不会发生.
		3.1 可见性
			重排序:线程中操作的执行顺序和其代码的顺序的一致性是没有保证的,只要这个重排序对本线程是不可探测的就行,即使该重排序对其他线程是明显的.
			在没有同步的情况下,编译器,处理器和运行时会对代码的执行顺序做一些奇怪的事情.在一个没有充分同步的多线程程序中尝试推断的内存操作一定会发生的顺序,在多数情况下会是错误的.
			3.1.1 不新鲜的数据
				一个线程可能会看到一个变量的最新值,却看到另一个之前更新的变量的不新鲜的值.
			3.1.2 非原子的64位操作
				java内存模型要求取和存操作都要是原子的,但是对于没有声明为volatile类型的long和double变量,java虚拟机允许将一个64位的操作以两个32位的操作来实现.
			3.1.3 锁和可见性
				固有锁可以用来保证一个线程可以看见另一个线程的修改.
				线程A执行一个代码块,接着线程B执行另一代码块,这两个代码块都被同一个对象锁保护,那么对于线程A在释放锁之前所作的修改,线程B在获得该锁后能保证看到。
				锁不仅仅用于排他性访问，同时也用于内存可见性.为了保证所有的线程都能看到最新的共享可变变量,所有的读和写线程都需要在同一个锁上同步.
			3.1.4 不稳定变量(volatile variables)
				java语言提供了另一种较弱形式的同步,volatile变量,来确保对该类型变量的修改可以可预期的传播到其他线程.当一个字段被声明为volatile类型时,编译器和运行时会被通知该变量是共享的,且对该变量的操作与对其他变量的操作顺序不进行重排序.volatile变量不会被缓存在寄存器,缓存等被其他线程看不到的地方,所以对volatile类型变量的读总是返回其最新值.
				volatile变量的可见性作用超过了volatile变量本身.当线程A向volatile变量写,接下来线程B去读该volatile变量,A线程中所有其他在往volatile变量中写时可见的变量的值,在B变量读该volatile变量时都是可见的.所以从内存可见性的角度看,写一个volatile变量相当于离开一个同步块,读一个volatile变量相当于进入一个同步块.但是,不建议过度依赖这种类似于额外作用的可见性,这种情况用锁更直观和易于理解.
				锁可以保证原子性和可见性,但是volatile变量只能保证可见性
				当下面的条件满足时,我们可以使用volatile变量:
					1. 对该变量的写不依赖于该变量当前的值,或者你能确保只有一个线程更新该变量的值.
					2. 该变量不与其它变量共同构成某个对象的状态变量
					3. 或由于某些原因,对该变量的访问不需要锁
		3.2 发布和泄漏
			发布一个对象意味着让它对当前范围之外的代码可见.比如存储一个指向它的指针,让其他代码能够找到它;将它从一个非私有方法中返回;或将它传递给另一个类的方法.在一些情况下我们希望确保对象和它的内部状态没有被发布,在另一些情况下,我们希望发布一个对象来常规使用,要以线程安全的形式实现这个就需要使用同步.
			发布内部变量会破坏封装性,并且使不变性的维护更困难.在一个对象完全构造完成之前发布它会破坏线程安全.一个对象在它不能被发布时被发布,就称为泄漏.
			发布一个对象同时也发布了该对象非私有字段所引用的对象.
			发布一个对象的内部类也会导致该对象和其内部状态被发布,因为内部类隐式含有对外部类的引用.
			3.2.1 安全构造实践
				一个对象只有当其构造函数返回后,才会处于一个可预测的,一致的状态.因此在构造函数中发布对象会发布一个没有完全构造的对象. 这个是真实的即使发布语句处于构造函数的末尾.如果this引用在构造过程中泄漏,就认为改对象没有被恰当的构造.
				不要允许this引用在构造函数中泄漏.
				一个常见的泄漏this引用的错误是在构造函数中启动一个线程.当在一个对象的构造函数中创建一个线程时,该对象和创建的线程共享其this引用,不论是显式的传递给线程的构造函数,或者是隐式的(因为Thread和Runnable是该对象的内部类).该线程可以在该对象完全构造之前看到它.
				在构造函数中创建一个线程没有问题,但是最好不要立即启动它.相应的,暴露一个start或initialize方法来启动该线程.
				在构造函数中调用一个可被重写的对象方法(即不是private也不是final),也会导致this引用被泄漏.
				如果想要在构造函数中启动一个线程,那么可以通过私有构造函数和一个公有的工厂方法来避免不恰当的构造.使用工厂方法返回对象时,可以确保该对象被完全构造.
		3.3 线程限制
			访问可变的共享的对象需要同步.其中一种解决办法就是不要同步.如果数据只被一个线程访问,就不需要同步.这种技术叫做线程限制,是实现线程安全的最简单方式.当一个对象被限制在一个线程范围内时,这种用法自动就是线程安全的,即使该对象不是线程安全的.
			一个常见的线程限制的应用是JDBC连接池的使用.JDBC规范并没有要求连接对象是线程安全的.连接池在连接对象被返回之前不会将它分配给其他对象.这种模式的连接管理隐式的将连接对象,在请求的过程中,限制在一个线程内.
				java语言和核心类库提供了一种机制,ThreadLocal,来实现线程限制.
			3.3.1 Ad-hoc线程限制
				Ad-hoc线程限制是指当维护线程限制的责任完全落在了实现上.Ad-hoc线程限制是脆弱的,因为没有语言的功能,比如可视性修饰符或本地变量,来帮助将对象限制在目标线程内.
				使用线程限制的决定通常是由实现一个特殊的子系统的决定产生的.比如GUI,作为一个单线程子系统.
				线程限制一个特殊的例子是应用于volatile变量,当你能确定只有一个线程对共享,可变volatile进行写操作时,对该变量执行读-修改-写的操作是线程安全的.
				因为Ad-hoc是脆弱的,因此应该谨慎使用.如果可能,使用更健壮形式的线程限制-栈限制(stack confinement)和ThreadLocal
			3.3.2 栈限制
				栈限制是一种特殊形式的线程限制,它是指对象只能通过本地变量来访问.就像封装使维持不变性更容易一样,本地变量使限制对象在一个线程内更容易.
				维护对象引用的栈限制,要求确信该对象引用没有被泄漏.
				使用一个线程不安全的对象在线程上下文内(within-thread context)是线程安全的,但是这个设计要求:1.对象要被限制在执行线程内;2.该对象是非线程安全的,都必须在代码编写时注视下来.
			3.3.3 ThreadLocal
				一个更正式的维护线程限制的方式是ThreadLocal.
				ThreadLocal通常被用来在那些基于可变单例或全局变量的设计中防止共享.比如数据库连接对象是非线程安全的,使用ThreadLocal对象来存放数据库连接对象可以防止共享.
				ThreadLocal通常也被用在当一个频繁的操作中需要使用一个临时变量,比如buffer,但又不想每次调用时进行分配的情况.
				如果你正在暴露一个单线程应用到多线程环境中,那么在全局变量语义允许的情况下,可以通过将全局变量转化为thread-local变量来保持线程安全.
				一个应用范围内的缓存将不再那么有用当它可以转化为thread-local范围内的缓存时.
				ThreadLocal被广泛应用于实现应用框架,比如,J2EE容器在EJB调用中,关联一个事务上下文当正在执行的线程.
				ThreadLocal很容易被滥用,比如将线程限制的特性当作使用全局变量的通行证或创建隐藏方法参数的一种形式.像全局变量一样,thread local变量降低了可重用性,在类之间引入了隐式的耦合,因此应该小心使用.
		3.4 不变性
			一个不可变对象是指它的状态在构造后就不会被改变.
			不可变对象总是线程安全的.
			java语言规范和java内存模型都没有正式定义不可变性,但是不可变性并不简单等于将所有字段都定义为final的.一个所有字段都是final的对象仍然可能是可变的,因为fianl字段可能保存指向可变对象的引用.
			一个对象是不可变的,如果:
				1. 它的状态在构造之后不可变
				2. 它的所有字段都是fianl的
				3. 它被合适的构造(该对象的引用不会在构造过程中泄漏)
			3.4.1 final字段
				final在java内存模型中有一个特殊的语义,它能够保证初始化安全,以使不可变对象在不需要同步的情况下,可以自由的被访问和共享.
				就像如果字段不需要有更近一步的可见性时,将其声明为private是一种好的实践一样,如果字段不需要改变,就将其声明为final也是一种好的实践.
			3.4.2 使用volatile来发布不可变对象
				访问和更新多个相关变量的条件竞争可以通过使用一个不可变对象来持有所有的相关变量来消除.当一个线程拥有了一个对不可变对象的引用,它就不需要担心其他线程更改它.当这个不可变对象的状态需要改变时,可以创建一个新的不可变对象,来封装所有的相关变量.
				通过结合使用一个不可变对象持有某一不变式相关的所有变量,并且使用volatile引用指向该不可变对象来保证实时可见性,来在没有显式锁的情况下保证线程安全.
		3.5 安全发布
			到目前为止,我们专注于确保一个对象不被发布,例如,假设被限制在一个线程或另一个对象内.有时候我们想要在线程见共享变量,这种情况,我们必须安全的实现它.
			3.5.1 不恰当的发布:当好的对象变坏
				不恰当的发布对象,可能导致两方面的问题:
					1. 其他线程可能看到一个旧的对象引用,比如null或者相对于新的对象引用的旧值.
					2. 其他线程可能看到最新的对象引用,但是看到该对象的旧的状态.
				一个线程可能第一次访问时看到一个字段的旧值,接下来访问时看到该字段的最新值.
			3.5.2 不可变对象和安全初始化
				因为不可变对象如此重要,java内存模型为共享不可变对象的安全初始化提供了特殊的保证.就像我们看到的,一个对象引用对其他线程可见并不能保证该对象的状态也同时对其他线程可见.为了保证对象状态的一致可见性,同步是必须的.
				不可变对象能被安全的访问,即使在发布该对象引用时,没有使用同步.为了保持这种安全初始化的保证,所有不可变性相关的需求都需要满足:状态不可修改,所有字段为final,并且被恰当的构造.
				不可变对象能够在不需要同步的情况下,被其他线程安全的使用,不论在发布该对象时有没有使用同步.
				如果final字段引用的是可变对象,那么对其状态的访问,仍然需要同步.
			3.5.3 安全发布习语
				要安全发布一个对象,指向对象的引用和该对象的状态要同时对其他线程可见.一个恰当构造的对象能被安全发布,通过:
					1. 在静态初始化器里初始化一个对象的引用
					2. 将对象的引用存储在volatile变量或AtomicReference中
					3. 将对象的引用存储到一个恰当构造的对象的final字段
					4. 将对象的引用存储到一个被锁恰当保护的字段
				线程安全容器中的内部同步意味着存放一个对象到线程安全的容器中,比如Vecotr或synchronizedList,满足上面的需求中的最后一条.如果线程A存放对象X到线程安全的容器中,线程B随后获取X对象,线程B保证能够看到线程A存放的X对象的状态.
				线程安全的容器类库提供了下面的安全发布的保证:
					1. 存放一个键或值到HashTable,synchronizedMap,或Concurrent-Map,会安全发布到从map中获取它的线程.
					2. 存放一个元素到Vecotr,CopyOnWriteArrayList,CopyOnWrite-ArraySet,synchronizedList,或synchronizedSet,会安全发布该对象到任何从容器中读取它的线程.
					3. 存放一个元素到BlockingQueue或ConcurrentLinkeQueue,会安全发布该对象到任何从队列中读取它的线程.
				类库中的其他传送机制(例如Future和Exchanger)同样也可以保证安全发布.
				静态初始化器是在类初始化时由JVM执行,由于JVM内部的同步机制,这种机制能够保证这种形式初始化的对象能够安全发布.
			3.5.4 有效的不可变对象
				安全发布对于那些,其他线程在不使用同步的情况下安全访问发布后就不再改变的对象,是足够的.安全发布机制保证对象的状态及该对象的引用对于其他线程同时可见,如果状态不再被改变,那么就可以保证访问是安全的.
				使用有效的不可变对象可以简化开发,并且由于减少了同步的使用而可以提高性能
				安全发布的有效的不可变对象,能够在不使用同步的情况下,被任何线程安全的访问.
				比如Date对象是可变对象,但是如果Date对象在创建后即不再改变,那么它就是有效的不可变对象,我们可以不使用同步来安全的使用它.
			3.5.5 可变对象
				如果对象在发布后可能被修改,安全发布只能确保刚发布后的状态的可见性.
				同步必须被使用,不仅在发布一个可变对象时,而且在每次对象被访问时,以保证后续修改的可见性.
				为了安全的共享可变对象,他们必须被安全的发布并且或者是线程安全的,或者被锁保护.
				发布一个对象的需求依赖于它的可修改性:
					1. 不可变对象可以以任何机制被发布
					2. 有效的不可变对象必须被安全发布
					3. 可变对象必须被安全发布,并且必须是线程安全的或被锁保护
			3.5.6 安全的共享对象
				当你获得一个对象的引用,你需要知道你允许对它作什么.在使用它之前是否需要获取锁?你是否被允许修改它,还是仅仅读取?许多并发错误起源于没有正确的理解关于共享对象的约定的规则.当你发布一个对象,你需要注释该对象应该被如何使用.
				在并发程序里,使用或共享对象的有用的策略为:
					1. 线程限制.一个线程限制的对象被排他性的拥有,并且被限制在一个线程内,能够被拥有它的线程修改
					2. 以只读的形式共享.一个只读的对象能够在不需要同步的情况下,被多线程同步的访问,但不能被任何线程修改.共享的只读对象包括不可变对象和有效的不可变对象
					3. 线程安全的共享.线程安全的对象在其内部使用同步机制,所以多线程可以在不需要同步的情况下,自由的访问它的公共接口.
					4. 被保护.一个被保护的对象只有在持有特定锁的情况下才能被访问.被保护的对象包括那些被封装在其他线程安全的对象内的对象,那些已知的被特定锁保护的,发布的对象.
	
		
	第四章 组合对象
		本章覆盖了如何构造一个类来使它变得线程安全更容易,以及如何维护他们来防止意外的安全保证的降低.
		4.1 设计一个线程安全的类
			封装使判断一个类是否为线程安全而不需要分析整个程序成为可能.
			设计线程安全的类的步骤包含下面3个元素:
				1. 确定构成对象状态的变量
				2. 确定约束状态变量的不变式
				3. 建立一个管理并发访问对象状态的政策
			一个对象的状态来自于它的字段.如果所有的字段都是基本类型,那么这些字段组成了它所有的状态.如果有些字段是对其他对象的引用,那么它的状态也应该包含被引用对象内的字段.
			4.1.1 收集同步需求
				使一个类线程安全意味着确保它的不变式在并发访问时能够保持,这就需要推断它的状态.
				状态的约束,或状态依不变式转变以及后置条件会产生额外的封装和同步需求.如果某一指定状态是无效的,那么相应的状态变量就必须被封装,否则客户端代码可能会使该对象处于非法状态.如果一个操作会导致无效的状态转换,那么它必须是原子的.
				换句话说,如果一个类没有类似的约束,那么我们可以放松对封装和同步的需求,以获得更好的灵活性和性能提升.
				你不可能在不理解对象的不变式和后置条件的情况下保证线程安全.有效值上的约束和状态变量的状态转换均会产生原子性和封装的需求.
			4.1.2 依赖于状态的操作
				类的不变式和方法的后置条件约束着对象的有效状态和状态转换.
				一个拥有基于状态的前置条件的操作被称为状态依赖的(state-dependent).
				在一个单线程程序里,如果前置条件不满足,那么操作只能失败.但在并发程序里,前置条件可能因为其他线程的操作在后面变为true.并发程序等待直到前置条件变为ture的可能性.
				内嵌的,有效地等待条件变为true的机制,wait和notify,紧紧的和固有锁绑定在一起,很难被正确的使用.更简单的方法是使用已经存在的类库,比如阻塞队列和信号量,来提供想要的状态依赖操作.
			4.1.3 状态所有权(state ownership)
				一个对象的状态是以该对象为根的对象树的字段的子集.
				给定状态变量的所有者来决定维护状态变量完整性的锁协议.所有权暗含着控制,一旦你发布了一个指向可变对象的引用,你就不再拥有它的排他性控制,最好的情况,你可能拥有共享的所有权.
				一个类并不拥有传给它的方法或构造函数的对象,除非这个方法是设计来显示的转换传给它的对象的所有权的.(例如同步容器包装器的工厂方法)
				集合类通常展示为一种分解的所有权,集合拥有集合框架的状态,客户端代码拥有集合中存储对象的状态.比如servlet框架中的ServletContext,ServletContext为servlet提供了一个类map的容器服务,你可以通过名字,使用setAttribute和getAttribute来注册和获取application对象.
				servlet容器实现的ServletContext必须是线程安全的,因为它将会被多个线程访问.servlet调用setAttribute和getAttribute时不需要同步,但是在使用ServletContext中存储的对象时必须同步.
		4.2 实例限制
			封装通过提升实例限制来简化使类变得线程安全.当一个对象被封装在另一个对象里时,所有的访问该封装对象的代码路径都是已知的,并且更容易分析.
			封装数据到一个对象,限制了对数据的访问到该对象的方法.使我们更容易确认对该对象的访问是否都持有适当的锁.
			限制的对象不会从他们预定的范围内泄漏.一个对象可能被限制在一个类实例的范围(例如一个私有的类成员),一个字面范围(例如一个本地变量),或一个线程(例如一个对象在一个线程的方法之间传递,但是不会被多个线程共享)
			实例限制是最简单的构造线程安全的类的方法.它同时允许锁策略选择的灵活性.允许不同的状态变量被不同的锁保护.
			在平台类库中有很多限制的例子,包括一些专门用来转化非线程安全的类到线程安全的类的类.基本的集合类,比如ArrayList和HashMap,不是线程安全的,但是类库提供了包装器工厂方法(Collections.synchronizedList),以使他们在多线程环境中被安全的使用.
			这些工厂使用了装饰器模式来包装集合到一个同步的包装对象,包装器对象以同步形式实现了适当接口的所有方法,并将请求转发给底层的集合对象.只要只有包装器对象拥有一个对底层集合的引用,那么包装器对象就是线程安全的.所有对底层集合的访问都必须通过包装器对象来完成.
			当然,仍然有可能通过发布一个假设的,限制的对象来违背限制.如果一个对象预定是被限制在某一个范围内,那么如果将该对象泄露到该范围之外就是一个bug.被限制的对象也可能通过发布其他对象,比如迭代器或内部类对象,间接的被发布.
			4.2.1 Java监视器模式
				java监视器模式和一个真正的监视器有明显的不同.进入和离开一个同步锁的字节指令叫做monitorenter和monitorexit,java的固有锁有时候也被叫做监视器锁或监视器.
				一个遵守java监视器模式的对象封装它的所有可变状态,并且用该对象的固有锁保护它.
				java监视器模式被很多类库使用,比如Vector和HashTable.java监视器模式最主要的优点就是简单.
				使用一个私有的对象锁要比使用对象自己的固有锁或其他公共的可访问的锁更好.使用一个私有的对象锁可以防止客户代码获取该锁,一个公共的可访问的锁会导致客户代码或正确或错误的参与同步策略.客户代码不恰当的获取其他对象的锁可能会导致生存性问题.鉴定一个公共可访问锁是否被恰当的使用需要分析整个程序,而不只是一个类.
			4.2.2 快速车辆的跟踪
		4.3 委托线程安全(Delegating Thread Safety)
			如果类的组件已经是线程安全的了,我们是否还需要额外添加一层来保证线程安全.答案是看情况,有些情况下,线程安全的类的组合仍是线程安全的,有些情况下,则不是.
			4.3.1 例子:使用委托的车辆跟踪器
			4.3.2 独立的状态变量
				委托的例子目前只是委托到单一的,线程安全的状态变量.我们也可以委托线程安全到多个底层的状态变量,只要这些状态变量之间是相互独立的.意味着组合对象不包含涉及多个状态变量的不变式.
			4.3.3 当委托失败时
				多数组合类都会有涉及多个状态变量的不变式.
				如果一个类有组合操作,只使用委托不能保证线程安全,在这种情况下,类需要使用锁来确保组合操作是原子的.
				如果一个类是由多个相互独立的,线程安全的状态变量组成,并且没有操作会导致无效的状态转换,那么可以委托线程安全到底层的状态变量.
			4.3.4 发布底层的状态变量
				当你要委托线程安全到一个对象的底层状态变量时,在什么情况下,你能发布这些变量以使其他类也能修改这些变量?答案在于你的类给这些变量强加了哪些不变式.例如,计数器类的底层状态变量只能是正数,并且增加操作中下一个值被现有的值限制.如果将该底层变量暴露给客户代码,那么客户代码将可能使该值处于非法状态.
				另一方面,如果一个底层变量展示的是当前的温度或最后一个登陆用户的id,那么允许其他类在任何时候修改该值都不会破坏不变式,所以发布这种类型的底层变量是可以接受的.但这仍然不是一个好的想法,发布可变状态变量会影响以后的开发.
				如果一个状态变量是线程安全的,没有参与限制其值的不变式,对于任何其相关的操作没有任何禁止的状态转换,那么它就可以被安全的发布.
			4.3.5 发布其状态的车辆跟踪器
		4.4 添加功能到已经是线程安全的类
			最安全的添加一个原子操作的方法是修改原来的类来添加想要的操作,但并不是所有时候都是可能的,因为你或许不能访问源代码或不能自由的修改它.如果你能修改原来的类,你需要理解它的实现的同步策略,以便于能根据和原来的设计一致的方式来改进它.直接在类添加方法意味着实现同步策略的所有代码都在同一个源文件中,更容易理解和维护.
			另一种方法是扩展原来的类,扩展比直接修改类的代码更脆弱,因为实现同步策略的代码现在分布到了多个独立维护的源文件中.如果父类选择不同的锁,修改了它的锁策略,那么子类就不知觉的被破坏,因为它不再使用正确的锁来同步对父类状态的同步访问.
			4.4.1 客户代码方面的锁
				第三个策略是通过将扩展代码放到helper类中来扩展类的功能,而不是通过继承类.
				Vector和同步包装器类都可以通过使用他们自己(Vector和同步包装器类)的固有锁来支持客户段锁,虽然是拐弯抹角的.
				如果说通过继承一个类来添加原子性的操作是脆弱的,因为它将一个类的锁相关的代码分布到了对象层级的多个类中.客户代码方面的锁更脆弱,因为它使得针对类C的锁相关的代码被放到了和类C完全不相关的类中.
			4.4.2 组合
				添加原子操作到一个已经存在的类中,有一个不是那么脆弱的方法:组合.
				像Collections.synchronizedList和其他集合包装器,客户端代码一旦将集合传递给包装器,就不再直接访问底层的集合,而是所有操作都通过包装器来执行.
		4.5 将同步策略写成文档
			文档是管理线程安全的强大的工具之一.
			记录一个类的线程安全保证为它的客户;记录它的同步策略为他的维护者.
			4.5.1 解释含糊的文档
				
				
	第五章 构建模块
		5.1 同步集合
			同步的集合类包括Vector和HashTable,他们是原来JDK的一部分;以及他们的堂兄弟,由Collections.synchronizedXxx工厂方法创建的同步包装器类.
			这些类都通过封装他们的状态和同步所有的公共方法,以使某一个时间只有一个线程访问集合的状态,来保证线程安全
			5.1.1 同步集合的问题
				同步集合是线程安全的,但是有时候你需要额外的客户端锁来保护组合操作.集合上常见的组合操作有迭代(重复取集合中的元素直到取完),导航(以某一顺序取当前元素的下一元素),以及条件操作,比如put-if-absent(检查map中是否有键K,如果没有,再存放(K,V)影射).对于一个同步的集合,这些组合操作在没有客户端锁的情况下,技术上是线程安全的.但是如果有其他线程并发的修改该集合,它就不会表现得像你期待的那样了.
				因为同步集合属于支持客户端锁的同步策略.只要我们知道使用哪个锁,那么在尊重其他集合操作的基础上添加新的原子操作是可能的.
				同步集合类使用它自己的固有锁来保护它的每一个方法.
				不可靠迭代的问题可以通过客户端锁来解决,在客户端代码中,当迭代时获取集合类的固有锁,以使其他线程不能修改集合类.
			5.1.2 同步器和并发修改异常
				从同步集合返回的迭代器,在设计时没有处理同步修改的情况,他们是快速失败的.意味着只要在迭代的过程中检测到集合被修改了,就抛出未检查异常-同步修改异常
				快速失败迭代器的设计不是为了简单,而是为了在有诚意的努力的基础上捕获并发错误,表现为并发错误的提前预警的指示器.它的实现是为集合关联一个修改次数,如果在迭代的过程中修改次数发生了变化,next或hasNext就会抛出ConcurrentModificationException.因为对修改次数的检查是没有同步的,因此有一定的风险看到过期的修改次数,因此迭代器可能意识不到修改已经发生.
				这个深思熟虑的设计权衡了降低并发修改检测代码对性能的影响.
				解决迭代的过程中锁住集合的问题,有一个解决方法是复制集合,并在复制的基础上进行的迭代.复制集合的过程需要锁保护.复制集合有可能会影响性能.
			5.1.3 隐式迭代
				既然通过锁可以防止迭代时抛出ConcurrentModificationException,那么就得记住在所有可能迭代的地方都使用锁.比如当集合的toString()方法被调用时,它会隐式的迭代集合,并调用每个元素的toString()方法.
				一个真实的教训是状态离保护它的同步越远,就越容易忘记在访问状态时使用恰当的同步.
				集合的equals()和hashCode()方法也会间接调用迭代器.而这些方法在集合作为其他集合的元素或键时,均会被调用.相似的,containsAll, removeAll, retainAll,以及以集合作为构造函数参数,均会隐式迭代集合.
		5.2 并发集合
			java 5.0通过提供多个并发集合类来改进同步集合.同步集合的线程安全是串行化所有对集合状态的访问.这样做的代价是很差的并发性.
			并发集合是被设计用在多线程的并发访问.java 5.0添加了ConcurrentHashMap,是对同步的,基于hash的map的实现的替代.在遍历是最频繁操作的情况下,CopyOnWriteArrayList是对同步的List实现的替代.新的ConcurrentMap接口添加了对常用的组合操作的支持,比如put-if-absent.
			使用并发集合来替换同步集合,能够在很小的风险下,提供明显的可扩展性提升.
			java 5.0添加了两种新的集合类型:Queue和BlockingQueue.Queue用来持有一些等待处理的临时的元素.
			很多实现被提供,比如ConcurrentLinkedQueue,一个传统的FIFO对列.PriorityQueue,一个(非并发的)以优先级排序的队列.Queue的操作不会阻塞,如果Queue是空的,那么就立即返回null.
			Queue相对于List,通过减少并发访问的需求来获得更有效的并发实现.
			BlockingQueue继承自Queue,添加了阻塞插入和获取操作.阻塞队列对生产者-消费者模式极其有用.
			就像ConcurrentHashMap是同步的,基于hash的map的并发替代一样,java 6添加了ConcurrentSkipListMap和ConcurrentSkipListSet,来作为同步的SortedMap和SortedSet(比如使用synchronizedMap包装的SortedMap和SortedSet)的并发替代.
			5.2.1 ConcurrentHashMap
				同步集合在每一个操作过程中都持有锁.
				ConcurrentHashMap是一个基于hash的map,就像HashMap一样.但是它使用完全不同的锁策略来提供更好的并发性和扩展性.不是使用同一个锁来同步所有的方法,以使一次只能有一个线程访问,它使用一种称为锁拆分的细粒度的锁机制,来允许更高层级的共享访问.任意数量的读线程能并发访问它.读线程和写线程可能并发访问它.一定数量的写线程能够并发修改它.结果是并发访问下更高的吞吐量和单线程访问时微小的性能损耗.
				ConcurrentHashMap和其他并发集合一样,对同步集合的进一步改进是提供了不抛出ConcurrentModificationException的迭代器,因此避免了迭代时加锁的需要.
				ConcurrentHashMap返回的迭代器是弱一致性,而不是快速失败的.弱一致性能够容忍并发修改,遍历迭代器生成时存在的元素,可能(但不保证)会反映迭代器生成后的修改.
				伴随着改进,也有一些折中.针对整个map进行操作的方法的语义,比如size或isEmpty,被轻微的减弱.因为size的结果在它计算出来时可能已经过期了,它只是一个估算,因此size被允许返回一个近似值,而不是精确值.这个起初看上去会很不适应,但是像size和isEmpty在并发环境中基本很少有用,因为他们的值都是不断变化的.因此这些操作的需求被减弱,以提升其他更重要操作的性能,比如get,put.
				另外一个同步的map实现提供,但ConcurrentHashMap没有提供的功能是锁住整个map来实现排他性访问.对于Hashtable和synchronizedMap,获取map的锁将阻止其他线程访问它.
			5.2.2 额外的map相关的原子操作
				由于ConcurrentHashMap不能被锁定来获取排他性访问,我们不能使用客户端锁的方式来创建新的原子性操作,因此,他相应的提供了一些常见的组合操作,比如put‐if‐absent, remove‐if‐equal, and replace‐if‐equal等的实现.
			5.2.3 CopyOnWriteArrayList
				CopyOnWriteArrayList是同步的List的一个并发替代品.在通常情况下,它提供了更好的并发性,排除了在迭代时使用锁或复制集合的必要性.相似的,CopyOnWriteArraySet也是同步Set的一个并发替代.
				copy‐on‐write集合的线程安全来源于只要有效的不可变对象被恰当的发布,访问它使就不再需要同步.他们通过每次在被修改时,创建和发布一份新的集合的拷贝,来实现可变性.对copy‐on‐write集合的迭代保持一个对迭代开始时后端数组的一个引用,由于它将不再改变,所以使用同步主要是为了确保数组内容的可见性.多个线程可以迭代该集合而不会受到其他线程或想要修改集合线程的干扰.copy‐on‐write集合返回的迭代器不会抛出ConcurrentModificationException,返回的元素是迭代器被创建时的元素,不管迭代器创建后的修改.
				很明显,每次当集合被修改时复制后端的数组需要一定的开销,特别是当数组较大时.copy‐on‐write集合只有在迭代比修改更频繁时才适合使用.这种特点很符合事件-通知系统:传递一个通知需要迭代链表中注册的监听器,并且调用它们.在很多情况下,注册和取消注册一个事件监听器远没有传递事件平常.
		5.3 阻塞队列和生产者-消费者模式
			阻塞队列提供了阻塞的put和get方法,以及相应的限时的offer和poll方法.如果队列是满的,put方法阻塞直到队列中有空间;如果队列是空的,get方法阻塞直到队列中有元素可用.队列可以是由范围的或没有范围的,没有范围的队列将永远不会满,因此在没有范围的队列上的put操作将用于不会阻塞.
			生产者-消费者模式简化了开发,因为它移除了生产者和消费者类的代码的依赖性,通过解耦可能以不同速率生产或消费的活动来简化工作量管理.
			一个常见的生产者-消费者模式的设计是线程池和一个工作队列.这种模式体现在Executor任务执行框架中.
			阻塞队列提供了一个offer方法,如果元素不能进入队列,它将返回一个错误标志.这就允许你创建更灵活的策略来处理工作量,比如分散负载,序列化额外的工作并将它们写到磁盘上,减少生产者的个数等.
			有范围的队列是构建可靠应用的强有力的资源管理工具.它能通过节制产生更多的,处理不了的工作来使你的程序更健壮.
			类库包含了很多BlockingQueue的实现.LinkedBlockingQueue和ArrayBlockingQueue是先进先出队列,类似于ArrayList和LinkedList,但是比同步的List具有更好的并发性能.PriorityBlockingQueue是根据优先级排列的队列.当你想要处理元素以一定的顺序而不是先进先出时比较有用.PriorityBlockingQueue能够比较元素通过它们的自然顺序或使用一个Comparator.
			BlockingQueue的另一个实现SynchronousQueue,并不是一个真正的队列,它不为进入队列的元素维护存储空间.相应的,它维护一个等待将元素入队或出队的线程的链表.在它的实现中,生产者直接将元素传递给消费者.这个看起来是一种很奇怪的实现队列的方式,但是它降低了将数据从生产者移动到消费者的延迟,因为工作是由生产者直接传递给消费者的.这种直接的传递也能为生产者反馈更多的关于任务的信息.当传递被接受,生产者就知道有个消费者去负责这个任务,而不是简单的将任务放到队列中.
			因为SynchronousQueue没有存储空间,put和take操作将阻塞直到有其他线程来配合完成传递.SynchronousQueue一般适用于由充足的消费者时,基本上总是有一个消费者准备好去完成任务传递.
			5.3.1 例子:桌面搜索
				生产者消费者模式还有可能提升性能,因为生产者和消费者可以并行运行.例如,它们一个是I/O密集型,一个是CPU密集型,并发执行它们要比顺序执行它们有更高的吞吐量.
			5.3.2 连续的线程限制
				对于可变对象,生产者-消费者的设计和阻塞队列促进了在从生产者向消费者传递所有权时连续的线程限制.
				一个线程限制的对象被单一线程排他性的拥有,但是它的所有权可以通过安全发布来转让,以使其他线程可以获得它的访问权,并且保证发布线程在转让后不再访问它.
				安全发布确保了对象的状态对新的线程可见,并且因为原来的线程不再访问它,所以该对象现在被限制在新的线程内.新的线程可以自由的修改它,因为它拥有排他性访问.
				对象池就使用了连续的线程限制,租借一个对象到请求线程.只要池包含充足的内部同步来安全的发布对象,并且只要客户代码不自己发布池中的对象或在将对象返回池后不再去访问它,所有权就能被安全的从一个线程转让到另一个线程.
			5.3.3 双向队列和任务窃取模式
				java 6提供了两外两种集合类型,Deque和BlockingDeque,它们继承自Queue和BlockingQueue.Deque是允许在队列两端进行插入和删除操作的双向队列.它的实现包括ArrayDeque和LinkedBlockingDeque.
				就像阻塞队列被生产者-消费者模式使用一样,双向队列也被用在任务窃取模式中.在生产者消费者模式中,有一个共享的任务队列被消费者使用,在任务窃取模式中,所有工作线程都有自己的双向队列.如果一个工作线程完成了它的双向队列中的任务,那么它可以从其他工作线程的双向队列的尾端窃取任务来执行.大多数时候它们只访问自己的双向队列,这样能够降低竞争.当一个工作线程需要访问其他工作线程的双向队列时,是从尾端开始,而不是头端,这样也降低了竞争.
				任务窃取模式能够被很好的拥在消费者同时也是生产者的情况,当做一组任务时,可能导致更多任务的产生.例如爬虫程序中处理一个页面通常会导致更多的页面要被爬取.相似的,在很多图搜索算法中,例如垃圾回收时堆的标记,能够被有效的平行化,通过使用任务窃取模式.
				当一个工作线程新产生了一组任务时,把这些任务放到它自己的双向队列的尾端(如果是任务共享的设计,那么也可以放到其他工作线程的双向队列的尾端).当工作线程的双向队列为空时,它会去其他工作线程的双向队列的尾端去找任务,确保每一个工作线程都是忙的.
		5.4 阻塞和可中断方法
			线程可能被阻塞或暂停,因为很多原因:等待I/O完成;等待获取锁;等待从Thread.sleep中醒来,或等待另一个线程的计算结果.当一个线程阻塞时,它通常会被暂停,并被设置一个阻塞状态(BLOCKED,WAITING,或TIMED_WAITING).
			阻塞操作和平常的需要执行很长一段时间才完成的操作的区别在于阻塞线程在继续运行之前必须等待一个不受它控制的事件,I/O完成,锁变为可用,或外部的计算完成,的发生.当外部事件发生时,线程被重新设置为RUNNABLE状态,重新变为可调度.
			BlockingQueue的put和take方法将抛出检查的InterruptedException,就像其他的类库方法一样,比如Thread.sleep.当一个方法会抛出InterruptedException时,说明它是一个阻塞方法,意味着当它被中断时,它能更早的停止阻塞.
			Thread类提供了interrupt方法来中断线程,查询一个线程是否被中断.每个线程都有个boolean变量来表明它的中断状态，中断一个线程就是设置这个状态.
			中断是一个合作机制.一个线程不能强制其他线程停止它现在做的,而去做另一件事.当线程A中断线程B时,线程A只是请求线程B在线程B认为合适的时间点停止,如果线程B有响应中断的机制.
			在API和语言规范中没有要求任何特殊的,应用级别的中断的语义.中断通常被用在取消一个活动.阻塞方法对中断有响应,使它可以更方便的及时取消一个长时间运行的活动.
			当你的代码调用一个可以抛出InterruptedException的方法时,你的方法也变为一个中断方法,因此需要有响应中断的机制.在类库代码中,通常有两种选择:
				1. 传播InterruptedException.如果你不想处理,这是最明智的选择,将InterruptedException异常抛给你方法的调用着去处理.其中包括不捕获InterruptedException,或捕获它,再做一些活动相关的清理,然后重新抛出该异常.
				2. 重新设置中断.有时候你不能抛出InterruptedException,比如你的代码是Runnable的一部分.这种情况下,你就需要捕获InterruptedException,然后通过调用interrupt方法重新设置该线程的中断状态,以使调用栈的更高层能够看到中断发生.
			你不能捕获了InterruptedException,但是不做任何响应.这将剥夺调用栈的上层代码响应中断的机会,因为该线程被中断的线索丢失了.你可以吞掉异常的唯一情况是,你继承了Thread,因此你拥有所有调用栈上层代码的控制.
		5.5 同步器
			同步器可以是通过其状态协调控制线程控制流的任何对象.阻塞队列可以作为同步器,其他类型的同步器包括semaphores, barriers, and latches.
			所有的同步器共享特定的结构属性:它们封装了决定到达同步器的线程是允许通过或强制等待的状态;提供了方法来管理这种状态,提供了方法来有效的等待同步器到达指定的状态.
			5.5.1 闩锁(Latches)
				闩锁是一个同步器,它能够延迟线程的执行直到闩锁达到它的终点状态.闩锁就像一个大门,在闩锁的终点状态到达之前,它一直是关闭的,阻止所有线程通过;当终点状态达到,大门打开,允许所有线程通过.
				一旦闩锁达到它的终点状态,它的状态就不能再被改变,它将一直保持打开状态.
				闩锁能够确保特定的活动不被执行,直到某一个一次运行的活动完成.比如:
					1. 确保计算不开始执行,直到它需要的资源初始化完成.
					2. 确保服务不被启动直到它所依赖的服务都已经启动.
				CountDownLatch是一个灵活的闩锁的实现.它允许一个或多个线程等待一系列事件的发生.闩锁的状态是一个初始化为正整数的计数器,表明需要等待的事件的数量.countDown方法将计数器减一,表明一个事件发生了.await方法等待计数器变为0(当所有事件都发生时).如果计数器非0,那么await调用将阻塞,直到计数器变为0,等待线程被中断或等待超时.
			5.5.2 FutureTask
				FutureTask就像一个闩锁,所有从FutureTask获取结果的线程都将被阻塞,直到闩锁到达终点状态,它的终点状态就是它所对应的线程执行完毕.
				FutureTask所代表的计算是通过Callable来实现的.它可能在三个状态中的一个:等待运行,正在运行和完成.完成包含了一个计算完成的三个方法,包括正常完成,取消和异常.
				FutureTask一旦到达了完成状态,它就永远停留在那个状态.
				Future.get方法的行为依赖于任务的状态.如果任务执行完成,get方法立即返回.否则就阻塞,直到任务状态转换成完成状态,然后返回计算结果或抛出异常.
				FutureTask从执行计算的线程向获取结果的线程传递计算结果.FutureTask的规范保证了结果的传递包括计算结果的安全发布.
				FutureTask被Executor框架使用来表达异步任务,也能使得我们能够在获取结果之前提前执行可能会运行很长时间的计算.
				用来执行任务的Callable可能会抛出检查或未检查异常,所有的代码都可能抛出Error.不论任务代码抛出什么,它都会被包装在ExecutionException,并且随着Future.get的调用而重新抛出.
			5.5.3 信号量(Semaphores)	
				计数信号量通常被用来控制同一时间访问特定资源或执行特定操作的活动的数量.计数信号量通常被用来实现资源池或为集合添加范围.
				一个信号量管理一组虚拟许可证,初始的许可证的数量通过Semaphore的构造函数传递.活动会获取或释放许可证当需要的时候.
				如果没有许可证可用,acquire方法将阻塞直到有一个许可证可用(或被中断,或操作超时).release方法将返回一个许可证到Semaphore.
				计数信号量的一个简化用法是二元信号量,该信号量的初始计数为1.二元信号量可以用来实现一个排他的,不可重入的锁的语义.谁拥有这唯一的许可证,谁就可以排他性访问.
				信号量在被用来实现资源池时很有用.我们很容易构造一个指定大小的池,如果从空的池中获取资源时会失败.但可能我们真正想要的是当从空的池中获取资源时阻塞,直到池中有资源可用.此时我们就可以使用信号量,并将其计数器初始化为池的大小,每次从池中获取资源前,先从信号量获取许可证,每次往池中放回资源后,再将许可证放回信号量.这样就可以通过信号量实现阻塞.
			5.5.4 栅栏(Barriers)
				闩锁只能被使用一次,一旦闩锁到达它的终点状态,它不能被重置.
				栅栏在阻塞一组线程直到某一事件发生这点和闩锁一致.主要的不同是栅栏要求所有的线程在某一时间点都到达某一栅栏点(barrier point)时,才能继续执行.
				闩锁的阻塞是为了等待事件,而栅栏的阻塞是为了等待其他线程.
				CyclicBarrier允许固定数量的政党在一个栅栏点(barrier point)反复的约会,在一些反复执行的,并行的算法中很有用,比如将一个任务分解成固定数量的,相互独立的子任务.
				线程在到达栅栏点时调用await,await调用将阻塞直到所有的线程都到达栅栏点.
				当所有的线程都到达栅栏点,该栅栏就被成功的通过,此时所有的线程都被释放,栅栏被重置以便再次使用.
				如果有一个await的调用超时或被中断,这个栅栏就被认为损坏了,所有对await的调用将抛出BrokenBarrierException.
				如果栅栏被成功通过,await为每一个线程返回唯一的其到达时的索引,这个可以被用来在下一次反复执行时选举一个首领来执行一些特殊的操作.
				CyclicBarrier允许你给构造函数传递一个栅栏操作,该栅栏操作是一个Runnable,它会在栅栏被成功通过之后,阻塞线程被释放之前,在某一个子任务线程中被执行.
				栅栏通常被用在仿真中,计算下一步的工作能够被并行的执行,并且所有的关于制定步骤地工作都必须完成才能进入到下一步.
				Exchanger是另一种形式的栅栏,一个包含两部分的栅栏,这两个部分在栅栏点交换数据.Exchanger很有用当这两部分执行不对称的活动时,例如一个线程向buffer里填充数据,另一个线程从buffer里消费数据.这两个线程可以通过Exchanger来见面并交换填充满的buffer和消费空的buffer.
				当两个线程使用Exchanger来交换对象时,交换的过程包括安全发布交换对象到各个部分中去.
				交换时间依赖于应用对响应的需求.最简单的方法是填充任务在buffer满时交换,消费任务在buffer空时交换.这样最小化交换的次数,但当填充速率不可预测时,可能会延迟一些数据的处理.另一个方法是填充者在buffer满时交换,或者是部分填充,但指定时间过后交换.
		5.6 创建一个有效的,可扩展的结果缓存
			
	
	第一部分的总结
		1. 它是一个可变的状态,愚蠢.
			所有的并发问题都归结于对可变对象的协调访问,越少使用可变对象,越容易实现线程安全.
		2. 使字段为final类型的除非要修改它.
		3. 不可变对象自动是线程安全的.
			不可变对象极大的简化了并发编程,他们简单并且安全,能够在不使用锁和不进行防御性拷贝的情况下,自由的共享.
		4. 封装在管理复杂性上很实用
			封装数据到对象中,使得保持他们的不变性更容易.封装同步到对象中,使得遵从同步策略更容易.
		5. 用锁保护所有的可变变量
		6. 用同一个锁保护一个不变式中的变量.
		7. 在组合操作的过程中一直持有锁.
		8. 一个程序中,如果多个线程在不使用同步的情况下访问一个可变变量,那么该程序就是有问题的.
		9. 不要依赖于推测为什么你不需要同步
		10. 在设计阶段就考虑线程安全,在文档中显式记录你的类不是线程安全的.
		11. 在文档中记录你的同步策略
		
		
第二部分: 构造并发应用
	第六章 任务执行
		大多数的并发应用都是围绕任务的执行来组织.将工作划分成任务能够简化程序的组织,通过提供自然的事务范围来促进问题的发现,通过并发工作的自然结构来促进并发性.
		6.1 在线程中执行任务
			围绕任务的执行来组织程序的第一步是鉴别明显的任务范围.理想状态下,任务都是相互独立的活动.
			很多服务器应用提供了一个任务边界的自然选择:独立的用户请求.
			6.1.1 顺序的执行任务
			6.1.2 显式的为任务创建线程
				每个任务一个线程的方式是对顺序执行的改进.只要请求到达的速率没有超出服务器处理请求的能力,这种方法就能提供更好的响应和吞吐.
			6.1.3 无限制的创建线程的缺点
				线程生命周期的开销.
					线程的创建和销毁不是免费的,为每一个请求创建一个线程会明显的消耗计算资源
				资源消耗.
					活跃的线程要消耗系统资源,特别是内存资源.多线程对CPU的竞争也会导致性能损耗.如果已经有足够的线程使CPU保持忙碌,继续创建更多的线程将不会有帮助,甚至会有损害.
				稳定性
					有多少线程能被创建是有限制的.这个限制根据平台而不同,可能影响该限制值的因素包括:JVM的调用参数,线程的栈大小,底层操作系统对线程数的限制.
		6.2 执行框架(Executor framework)
			java.util.concurrent提供了一个灵活的线程池的实现作为Executor框架的一部分.在java类库中,任务执行的主要抽象不是Thread,而是Executor.
			Executor是一个简单的接口,但它是组成灵活,强大的异步任务执行框架的基础,它提供了很多的任务执行策略.它提供了一个解耦任务提交和任务执行的标准.它使用Runnable执行任务.
			Executor的实现也提供生命周期支持,和添加静态数据收集,应用管理和监控的钩子.
			Executor是基于生产者-消费者模式,任务提交者是生产者,任务执行线程是消费者.
			6.2.1 例子:使用Executor的web服务
			6.2.2 执行策略
				执行策略指定了任务执行的"what, where, when, and how",包括:
					1. 任务将在哪个线程内被执行?
					2. 任务将被以什么样的顺序执行(FIFO,LIFO,优先级顺序)?
					3. 有多少任务能够被并发的执行?
					4. 有多少任务将被排队来等待执行?
					5. 如果任务由于系统过载而被拒绝,哪个任务将是受害者,如何通知应用?
					6. 在执行任务前后应该执行什么操作?
			6.2.3 线程池
				一个线程池和一个持有等待执行的任务的工作队列紧密地绑定在一起.
				线程池使线程可以重用,避免了频繁的生成和销毁线程.因为省去了线程创建的时间,所以提高了响应性.
				类库提供了一个灵活的线程池的实现,伴随着一些有用的配置.可以通过Executors的静态工厂方法来创建线程池:
					newFixedThreadPool.
						一个固定大小的线程池,当任务提交时创建线程,直到线程池的最大大小,然后尝试保持线程池的大小不变(如果有线程因为异常死掉,就添加新的线程).
					newCachedThreadPool.
						一个缓存的线程池有更好的灵活性.当当前池的大小超出了请求的需求时,回收空闲的线程;当有新需求增加时,创建新线程.它不设置线程池大小的限制.
					newSingleThreadExecutor.
						该线程池只有单一的工作线程来处理任务,当该线程意外死亡时,再创建一个来代替它.任务被依据工作队列的顺序(FIFO,LIFO,优先级顺序),被顺序的处理.
					newScheduledThreadPool.
						一个固定大小的线程池,支持延迟和周期性的执行任务.像Timer.
			6.2.4 执行器的生命周期
				JVM不能退出直到所有的非守护线程终止,所以如果停止Executor失败,将阻止JVM退出.
				关闭一个应用,在优雅的关闭(完成已经开始的,但不再接受新的任务)到生硬的关闭(关闭机房的电源),以及他们之间的很多种情况是一个频谱范围.因为Executors为应用提供服务,它也应该可以被关闭,优雅的或生硬的,并且反馈由于关闭而影响到的任务的状态给应用.
				为了解决执行服务生命周期的问题,ExecutorService接口继承自Executor,添加了很多生命周期管理的方法(包括一些任务提交的便利方法)
				ExecutorService的生命周期有3个状态,正在执行,关闭和终止.ExecutorServices在创建时被初始化为正在执行状态,shutdown方法初始化一个优雅的停止,不接受新的任务,但之前提交的任务允许执行完成,包括那些已经接受但还没有开始执行的任务.shutdownNow方法初始化一个生硬的停止,它尝试取消正在执行的任务,并且不再启动任何已经在排队但是还没有开始的任务.
				在ExecutorService关闭后提交的任务由拒绝执行处理器(rejected execution handler)处理.它或许安静的抛弃任务,或许导致execute的调用抛出未检查的RejectedExecutionException.
				一旦所有的任务都完成,ExecutorService就转换到终止状态.可以通过调用awaitTermination来等待ExecutorService到达终止状态,或者通过isTerminated方法来主动获取其是否已经被终止.
				通常的做法是在shutdown方法后跟awaitTermination,来达到同步关闭ExecutorService的效果.
			6.2.5 延迟的和周期性的任务
				ScheduledThreadPoolExecutor可以用来替代Timer,来延迟性的或周期性的执行任务.可以通过构造函数或newScheduledThreadPool工厂方法来生成ScheduledThreadPoolExecutor.
				Timer创建单一的线程来执行定时任务.如果一个定时任务运行的时间过长,其他定时任务的时间精确性就会受到影响.如果有一个每10ms运行一次的重复任务和一个需要运行40ms的任务,那么在40ms的任务结束后,该重复任务会迅速执行4次或完全缺失了4次执行的机会(这依赖于该重复任务是以固定速率还是固定延迟来调度的).Scheduled thread pools通过提供多个线程来执行延迟的或周期性的任务来解决这个问题.
				Timer的另一个问题是当TimerTask抛出未检查异常时,它表现得很差.Timer线程不会捕获异常,所以TimerTask抛出的未检查异常将终止Timer线程.Timer在这种情况下不会自动复活,它错误的以为Timer被取消.在这种情况下,已经被调度但还未执行的任务将不会被执行.新的任务也不会被调度.
				在java 5.0以后很少有理由来使用Timer.
				如果你想要构建自己的调度服务,你可以使用DelayQueue来改进类库.DelayQueue是BlockingQueue的实现,它提供了ScheduledThreadPoolExecutor的调度功能.DelayQueue管理Delayed对象的集合.Delayed对象有一个延迟时间和它相关联,DelayQueue允许你获取一个元素只有在其延迟过期时.元素从DelayQueue返回的顺序根据和其延迟相关的顺序.
		6.3 找到可利用的并行任务
			6.3.1 例子:顺序的页面展现
			6.3.2 注重结果(result-bearing)的任务:Callable和Future
				Executor框架使用Runnable来执行其任务,Runnable是一个相当有限的抽象,它的run方法不能返回值或抛出检查的异常.
				很多任务是有延迟的计算,比如执行数据库查询,获取网络资源,或计算一个复杂的函数.对于这种类型的任务,Callable是一个更好的抽象,它的call方法将返回一个值并且预测其可能抛出一个异常.Executors提供了很多有用的方法,来将其它类型的任务,比如Runnable或java.security.PrivilegedAction包装成Callable任务.
				Executor框架中,已经被提交但还没有开始执行的任务总是可以被取消.已经开始的任务可能可以被取消,这要取决于它是否响应中断.取消一个已经完成的任务是没有作用的.
				Future展示的是任务的生命周期,它提供方法来测试任务是否被完成或被取消,获取它的结果,取消任务.Future的规范暗含的一点是任务的生命周期只能向前走,不能向后退,就像ExecutorService的生命周期一样.一旦任务完成,它将一直保持在那个状态.
				get的行为根据任务的状态(没有开始,正在执行,完成)而不同.当任务完成时,它立即返回或抛出一个异常,否则它将阻塞直到任务完成.如果任务是因为抛出异常完成的,那么get方法将该异常包装在ExecutionException里,并重新抛出它.如果任务是被取消,那么get将抛出CancellationException.如果get方法抛出ExecutionException,那么底层的异常可以通过getCause来获得.
				有很多方法创建一个Future来描述一个任务.ExecutorService的submit方法将返回一个Future,以使我们能提交一个Runnable或Callable到一个Executor,然后获得一个Future来获取执行结果或取消任务.
				可以显式的为一个Runnable或Callable初始化一个FutureTask.因为FutureTask实现了Runnable接口,它可以被提交到Executor去执行,或通过调用它的run方法直接执行.
				到了java 6.0, ExecutorService的实现能够覆盖AbstractExecutorService的newTaskFor方法,来控制为提交的Runnable或Callable初始化Future.默认的实现是创建一个FutureTask.
				提交Runnable或Callable到Executor包括Runnable或Callable从提交线程到最终任务执行线程的安全发布.相似的,设置Future的结果也包括运行结果从任务执行线程到结果获取线程的安全发布.
			6.3.3 例子:用Future来实现页面展现
				Future的get方法是与执行任务的状态相关的,意味着调用者不需要考虑任务的状态.
				围绕着Future.get的异常处理代码要处理两个可能的问题:一个是任务遇到了异常,一个是调用get方法的线程在结果可用之前被中断.
			6.3.4 并行的多样性任务的限制
				分配不同类型的任务到每个工作线程不好扩展.如果有更多的工作线程可用时,这些工作线程如何帮忙,在没有妨碍或不明显重新构造任务的分配时,是不明显的.如果在相似的任务之间无法找到细粒度的并行性,这种方法可能是不讨好的.
				在划分不相似的任务给多线程时的另一个问题是这些任务的大小不同.如果你分配任务A和任务B到两个工作线程,但是任务A要花费的时间是任务B的10倍.那总体上只有9%的速度提升.
				划分一个程序的工作量到多个工作线程的真正的性能回报来自于有大量的独立的,均匀的可以被并发执行的任务.
			6.3.5 CompletionService:Executor遇见BlockingQueue	
				如果你有一组计算任务要提交给Executor,并且想要在他们完成时获取其结果,你就得要维持每个任务相关的Future,并且反复的通过调用0超时的get方法来获取计算结果.这样做是可能的,但是是繁琐的.幸好有个更好的方法:CompletionService.
				CompletionService结合了Executor和BlockingQueue的功能.你可以向它提交Callable的任务来执行,使用类似队列的方法,take和poll,来获取完成的结果.结果在可用时,被封装到Future里.
				ExecutorCompletionService实现了CompletionService,委托它的计算到一个Executor.
				ExecutorCompletionService的实现很直接.它的构造函数创建一个BlockingQueue来维护完成的结果.FutureTask有一个done方法,它在计算完成时被调用.当一个任务被提交,它被封装在QueueingFuture里,QueueingFuture是FutureTask的一个字类,它重写了done方法来将计算结果放到BlockingQueue中.take和poll方法委托给BlockingQueue,如果没有结果可用就阻塞.
			6.3.6 例子:使用CompletionService来进行页面展示
				多个ExecutorCompletionServices能够共享同一个Executor.如果以这种方式使用,一个CompletionService就是一批计算的句柄,和Future一样,Future是一个任务的句柄.
				在使用共享的同一个Executor时,通过记住有多少任务被提交到CompletionService,有多少任务的计算结果被获取,可以知道是否一批任务的所有结果都已经获取.
			6.3.7 为任务设置时间限制
				在指定时间预算内执行任务的主要挑战在于确保你没有等待比时间预算更长的时间来获取答复或证明答复不会产生(or find out that one is not forthcoming).有时间限制版本的Future.get方法满足这个需求,如果结果准备好,它立即返回,如果结果在指定时间范围内没有准备好,就抛出TimeoutException.
				使用有时间限制的任务的第二个问题是在他们运行超时时停止他们,以使他们不再浪费资源.这个可以通过让任务自己严格管理自己的时间预算,并且在它运行超时时中止它.或者在超时时间过期时,取消任务.Future能够对这种情况提供帮助.如果一个定时的get抛出TimeoutException,可以通过相应的Future来取消这个任务.如果任务被编写得是可取消的,那么它可以被更早的终止,以使不再消耗更多的资源.
			6.3.8 一个旅行预约门户
		总结
			
			
	第七章 取消和停止
		让一个任务和线程安全的,快速的,可靠的停止,并不总是很容易.java没有提供任何机制来安全的强制一个线程停止它当前的工作.线程的stop和suspend方法尝试提供这个机制,但很快被认为是有严重瑕疵的,应该避免被使用.相替代的,它提供了中断,一种合作的机制来允许一个线程告诉另一个线程停止它正在做的.
		合作的方式是需要的,因为我们很少想要一个任务,线程或服务立即停止,那样的话,会让数据停留在不一致的状态.相应的,任务和服务可以被合适的编码,当他们被请求停止时,可以清理当前的工作,然后停止.
		7.1 取消任务
			一个活动能够被取消是指外部代码能够使它停止,在它自己正常停止之前.
			有很多原因使你想停止一个活动:
				1. 用户请求取消活动
				2. 有时间限制的活动
				3. 应用事件
					比如很多线程分别搜索自己的范围,一旦一个成功,就取消其他的
				4. Error
				5. 关闭
			7.1.1 中断
				要让一个任务响应中断有两个方法:
					一个是在任务代码中暴露一个标志字段,该任务会去检查该标志字段来决定是否停止,此时,外部代码就可以通过修改标志字段来取消该任务.
					如果任务没有暴露相应的标志字段,但它可以响应中断,就可以通过中断来取消任务.
				没有任何的API和语言规范将中断和特定的取消语义绑定在一起,但是,在取消任务之外的场景下使用中断是脆弱的.
				每个线程都有一个boolean类型的中断状态,通过设置中断状态为true来中断一个线程.Thread包含方法来中断线程,查询线程的中断状态,清理中断状态.interrupt方法中断目标线程.isInterrupted方法返回目标线程的中断状态.interrupted方法清除目标线程当前的中断状态,并返回其之前的中断状态.
				阻塞类库方法,如Thread.sleep和Object.wait都尝试检测线程是否被中断,并尽早返回.他们响应中断的方式是情理当前的中断状态并抛出InterruptedException,表明该阻塞操作是因为中断而提前完成的.JVM不保证阻塞方法有多迅速的检测到中断.
				调用interrupt方法不一定会停止目标线程当前的工作,他只是传递了一个中断被请求的消息.
				中断只是请求一个线程在一个合适的时机中断它自己.一些方法,如sleep,wait和join等严肃的处理了中断,当他们发现中断被设置时,抛出一个异常.一个更好的响应中断的方式是保留中断状态,以使调用代码能够处理它.一个不好的响应中断的方法是将中断吞掉,这种做法将使调用栈的上层没有机会响应中断.
				静态的interrupted方法应该被小心使用,因为它清理了线程的中断状态.如果interrupted方法返回true,除非你想要吞掉中断,那么你就应该作些事情:或者抛出InterruptedException,或者通过interrupt方法重新中断.
				通常,中断是最通情达理的方式来实现取消
			7.1.2 中断政策
				就像任务有一个取消政策一样,线程也应该有它的中断政策.一个中断政策决定一个线程如何解释一个中断请求:当检测到中断时,它应该做些什么;从中断的角度来看,哪些工作被认为是原子性的;多么及时的响应中断.
				任务可能并不是在它自己拥有的线程中执行的,它们从其他服务,比如线程池,借用线程.线程拥有者之外的代码应该小心的保持线程的中断状态,以使线程拥有者最终能够处理它,即使线程拥有者之外的代码也想对中断做些事情.
				这就是为什么阻塞类库的方法只是简单的抛出InterruptedException来响应中断.他们不在自己拥有的线程内执行,所以他们实现了一个最合理的取消策略:尽可能快地避开,使调用者知道中断,使调用栈上层的代码能够做进一步的动作.
				如果一个线程不是简单的通过抛出InterruptedException来传播中断,那么它就应该在捕获到InterruptedException后,重新设置中断状态.
				一个线程应该只能被它的所有者中断,拥有者可以封装线程的中断策略到一个恰当的取消机制中,比如shutdown方法.
				因为每个线程都有其中断政策,因此你不应该中断一个线程,除非你知道中断对该线程意味着什么.
				评论家嘲笑java的中断机制,因为它没有提供抢占式的中断能力,而是强制开发处理InterruptedException.虽然如此,传播一个中断请求允许开发手工制定灵活的中断政策,来恰当的平衡应用的响应性和健壮性.
			7.1.3 响应中断
				当你调用一个可中断的阻塞方法,比如Thread.sleep或BlockingQueue.put,时,有两个实用的策略来处理InterruptedException:
					1. 广播该异常(可能在一些相应的清理之后),使你的方法也成为可中断的阻塞方法.
					2. 重新设置中断状态,以使调用栈更高层的代码能够处理它.
				如果你不想要或不能广播InterruptedException(可能你的任务是一个Runnable类型),你需要找到另外的方法来保持中断请求.标准的方法是通过调用interrupt方法来重新设置中断状态.
				只有实现了线程的中断政策的代码才能够吞掉中断请求.一般目的的任务或类库代码都不应该吞掉中断请求.
				一些活动不支持取消,但仍要调用可中断的阻塞方法,这种情况下,我们需要在一个循环中调用该可中断的阻塞方法,当中断被检测到时重试.这种情况下,我们需要将中断状态保存在本地,并在方法返回时,重新设置中断状态.
				可中断方法通常在阻塞或做一些特殊的工作时检测中断状态,以使中断能够被尽可能快地响应.
				如果你的代码中没有调用可中断的阻塞方法,仍可以通过在任务代码中检测中断状态来响应中断.检测中断状态的频率选择要平衡效率和可响应性.
				取消操作可能会涉及到中断状态之外的其他状态.中断能够用来获取线程的注意.发起中断的线程中存放的其他信息可能会被用来为被中断的线程提供更多的信息.(但要确保在访问这些信息时,使用同步).
				比如,当ThreadPoolExecutor中的工作线程检测到中断时,它将检查线程池是否正在关闭.如果是,它将执行一些池相关的清理.否则,它将创建一个新线程来恢复线程池到指定的大小.
			7.1.4 例子: 限制时间的运行
			7.1.5 通过Future来取消
				Future的cancel方法有个boolean参数,mayInterruptIfRunning(该参数表明是否可以发送中断,而不是任务是否可以检测中断并响应中断),它返回一个值表明取消尝试是否成功.当mayInterruptIfRunning是true,并且当前的任务正在某个线程中运行,那么那个线程被中断.如果这个参数是false,只是意味着如果该任务还没有开始,就不要开始它了.
				因为我们不应该中断一个线程,除非知道其中断政策.那么什么时候使用true参数调用cancel方法才是正确的呢?标准Executor实现创建的工作线程实现的中断政策,允许任务被通过中断取消.所以使用Future的以true作为参数的cancel方法来取消通过标准Executor创建的线程执行的任务是安全的.
				不应该在尝试取消任务是直接中断一个线程池中的线程,因为你不知道当中断被传递时,该线程正在执行什么任务.如果要这样做的话,就通过Future来做.这也是为什么在为任务编码时,将中断处理当作取消任务的请求处理,因为这样做的话,他们就可以通过Future来取消.
			7.1.6 处理不可中断的阻塞
				并不是所有的阻塞方法或阻塞机制都能够响应中断.如果一个线程在执行同步的socket I/O,等待一个固有锁时,中断除了设置线程的中断状态之外没有其它的作用.
				我们有时候可以以类似于中断的方法来说服阻塞在不可中断活动的线程停止,但这需要你很清楚该线程为什么阻塞.
				java.io中的同步的socket I/O.在服务器应用中,通常形式的阻塞I/O是在socket上的读和写.不幸的是,InputStream和OutputStream的read和write方法都不响应中断,但是关闭底层的socket,将使任何阻塞在read和write上的线程抛出SocketException.
				java.nio中的同步I/O.中断一个等待在InterruptibleChannel上的线程将导致它抛出ClosedByInterruptException,并且关闭通道,同时会引起其他所有阻塞在该通道上的线程抛出ClosedByInterruptException.关闭一个InterruptibleChannel,将导致所有阻塞在通道操作上的线程抛出AsynchronousCloseException.多数标准的Channels都实现了InterruptibleChannel.
				使用Selector的异步I/O.如果一个线程阻塞在Selector.select(在java.nio.channels),wakeup方法将导致它通过抛出ClosedSelectorException来过早的返回.
				获取锁.如果一个线程因为等待获取固有锁而阻塞,那么你将不能做任何事情,除了通过其他方法获取它的注意,在它获取锁并且向前进展了一段时间后.虽然如此,显式的Lock类提供了lockInterruptibly方法,允许你等待一个锁,并且能够响应中断.
			7.1.7 使用Newtaskfor来封装非标准的取消
				java 6的ThreadPoolExecutor添加了一个newTaskFor的钩子.当一个Callable被提交到ExecutorService,submit方法返回一个可以用来取消任务的Future.newTaskFor钩子是一个用来创建代表任务的Future的工厂方法.它返回一个RunnableFuture,该接口继承自Future和Runnable,FutureTask实现了该接口.
				自定义Future可以使你重写Future.cancel.自定义的取消代码允许你在取消时写日志或收集统计数据,并且能够用来取消那些不响应中断的活动.
		7.2 停止一个基于线程的服务
			明智的封装实践指明你不应该操作一个线程,中断它,修改它的优先级等,除非你是它的拥有者.线程API没有关于拥有者的正式的概念:一个线程由一个Thread对象表示,可以被自由的在其他对象间共享.然而,认为一个线程是有拥有者的是合情理的,线程的拥有者一般是创建它的类.所以线程池是它内部工作线程的拥有者,如果这些工作线程要被中断,那么就应该由线程池来处理.
			就像其他封装的对象,线程的所有权是不能传递的:应用拥有服务,服务拥有工作线程,但是应用并不拥有工作线程,因此不能直接尝试停止他们.相应的,服务应该提供生命周期方法来停止它以及它所拥有的工作线程.这样应用可以停止服务,服务可以停止线程.ExecutorService提供了shutdown和shutdownNow方法.其他的拥有线程的服务也要提供类似的关闭机制.
			当一个拥有线程的服务的生命周期比创建它的方法长时,就应该提供生命周期方法.
			7.2.1 日志服务
			7.2.2 ExecutorService关闭
				ExecutorService提供了两种方法来关闭:通过shutdown方法来优雅的关闭,通过shutdownNow方法来生硬的关闭.shutdownNow方法返回在尝试关闭所有正在执行的活动线程后,还没有被启动的线程.
				这两个不同的中止选项提供了安全性和响应性直接的平衡.
			7.2.3 毒药丸
				另一个停止生产者-消费者服务的方法是使用毒药丸,一个被放到队列中的约定对象,当碰到该对象时停止.这种方法的前提是生产者和消费者的个数已知.
			7.2.4 一个只使用一次的执行服务
				如果一个方法需要执行一批任务,并且等到所有任务都完成时才返回.这个可以通过使用一个私有的,其生命周期绑定到该方法的Executor来简化服务生命周期的管理.
			7.2.5 Shutdownnow的限制
				当一个ExecutorService被shutdownNow方法生硬的关闭时,它尝试取消当前正在执行的任务,并且返回一个已经提交但还没开始的任务列表,以使它们可以被日志或保存.
				然而,没有一个平常的方法来找出哪些任务已经开始,但还没执行完.这就意味着在关闭时没有办法知道正在执行任务的状态,除非任务自己执行一些检查点.
		7.3 处理非正常的线程中止
			相应的,我们应该在try-catch块中调用任务,来捕获未检查异常,或者是在try-finally块中来确保如果线程非正常退出,框架能够被通知,并且采取正确的动作.
			7.3.1 未捕获异常处理器
				线程API提供了UncaughtExceptionHandler,使你可以检测线程由于未捕获异常而死亡.
				当一个线程因为未捕获异常退出时,JVM将这个事件报告给应用提供的UncaughtExceptionHandler.
				在java 5.0及以后,可以通过Thread.setUncaughtExceptionHandler为每个线程设置一个UncaughtExceptionHandler,也可以通过Thread.setDefaultUncaughtExceptionHandler来设置默认的UncaughtExceptionHandler.然而这些处理器只有一个会被调用,jvm先找每个线程自己的处理器,然后是ThreadGroup的处理器.ThreadGroup处理器的默认实现是委托给它的父线程组.就这样一直往上找,知道有一个处理器的实现能处理未捕获的异常,或者是冒泡到线程组链的最顶层.最顶层的线程组处理器委托给默认的系统处理器(如果存在一个的话,默认是不存在的),否则就在终端打印调用栈.
				为了给池中的线程设置UncaughtExceptionHandler,可以通过ThreadPoolExecutor的构造函数传递一个ThreadFactory.
				标准的线程池允许未捕获任务异常中止线程池,但是使用一个try-finally块使得未捕获异常发生时可以被通知,以便线程能够被替代.如果没有未捕获异常处理器或其他失败通知机制,任务将会安静的失败,那样是非常迷惑的.
				如果想在任务因为异常失败时被通知,以便能够采取一些任务相关的恢复动作,或者将任务封装在能够捕获异常的Runnable或Callable中,或者覆盖ThreadPoolExecutor的afterExecute钩子.
				有一点混乱的是,通过execute方法提交的任务抛出的异常会被传递到未捕获异常处理器.通过submit方法提交的任务,任何抛出的异常,检查的或未检查的,被认为是任务返回状态的一部分.如果通过submit提交的任务因为异常而中止,该异常会被封装在ExecutionException内,通过Future.get再次抛出.
		7.4 JVM关闭
			JVM被关闭可以通过有秩序地或生硬的被关闭.一个有秩序地关闭被初始化,当最后一个用户线程(non-daemon)中止时,或是通过调用System.exit,或是通过其他平台指定的方式(比如发送一个SININT或按下ctrl-c),这是标准的关闭虚拟机的方式.虚拟机可以被生硬的关闭通过调用Runtime.halt,或通过操作系统杀掉JVM的进程(比如发送一个SIGKILL)
			7.4.1 关闭相关的钩子
				在一个有秩序地停止过程中,JVM首先启动所有注册的关闭相关的钩子.关闭相关的钩子是通过Runtime.addShutdownHook注册的,未被启动的线程.JVM不保证这些关闭相关的钩子的启动顺序.
				如果应用相关的线程在关闭时仍然正在运行,它们将继续和关闭相关的进程并发执行.当所有的关闭相关的钩子都执行完时,jvm可能会选择执行终结器,当runFinalizersOnExit为true时,然后停止.
				JVM在关闭的过程中,不会尝试停止过中断正在运行的,应用相关的线程.这些应用相关的进程会在JVM停止时被生硬的停止.
				如果关闭相关的钩子或终结器(finalizer)未完成,有序关闭的过程被挂起,JVM必须被生硬的关闭.
				在生硬关闭JVM的过程中,JVM不会被要求作任何事情,处理中止JVM.关闭相关的钩子将不会被执行.
				关闭的钩子应该是线程安全的:它们在访问共享数据时应该使用同步,并且应该被小心处理来预防死锁,就像其他并发执行的代码一样.更进一步,他们不应该假设应用的状态(比如是否其他线程已经停止,或所有正常的线程已经完成),或者关于虚拟机为什么被关闭.最后,他们应该尽可能快地退出,因为他们的存在延迟了虚拟机的中止.
				关闭相关的钩子应该被用来为服务或应用进行相关的清理.比如删除临时文件,或者清理那些不会被操作系统自动清理的资源.
			7.4.2 守护线程
				有时候你需要一个线程来执行一些辅助功能,但又不想这些线程的存在阻止JVM关闭,这就是守护线程的工作.
				线程被分为两种类型:正常线程和守护线程.当JVM启动时,它创建的所有线程都是守护线程(比如垃圾收集线程或其他内部线程),除了main线程.当一个新的线程被创建,它继承了创建它的线程的daemon状态,所以main线程创建的线程默认是正常线程.
				正常线程和守护线程唯一的区别是他们在退出时将发生什么.当一个线程退出时,JVM检查正在运行的线程的清单,如果只剩下守护线程,JVM将初始化一个有序的关闭.
				当JVM停止时,所有已有的线程都被丢弃,finally块不会被执行,JVM只管退出.
				守护线程应该被很少使用,因为很少的正在被处理的活动能够在不进行任何清理的情况下被安全的丢弃.在实践中,使用守护线程来处理可能进行I/O的任务是危险的.
				守护线程被保留用来执行一些内部的任务,比如一个后台线程定期删除内存中的缓存项.
				守护线程不是一个用来管理应用中的服务的生命周期的好的替代品.
			7.4.3 终结器
				垃圾收集器在释放不再被使用的内存资源的时候能够工作的很好,但对于一些其他资源,比如文件或socket指针,当他们不再被使用时,要被显式的返回给操作系统.为了实现这个,垃圾收集器会对那些有finalize方法的对象进行特殊处理:在他们被收集器释放时,finalize方法被调用,以便持久的资源能被释放.
				因为终结器能在JVM管理的线程中执行,任何被终结器访问的状态将被多个线程访问,因此在访问时必须使用同步.终结器不保证他们什么时候被执行或是否会被执行,并且他们会在有终结器的对象上产生明显的性能损耗.他们也很难被正确编写.
				在很多情况下,finally块和显式的close方法的组合,在资源管理上比终结器更好,唯一的例外是,在管理由本地(native)方法持有的资源时.
				避免使用终结器.
		总结:
			终止生命周期的问题为任务,线程,服务和应用的设计和实现增加了复杂性.java没有提供优先性的机制来取消活动或中止线程.替代的,它提供了一个合作中断的机制来实现取消,但是构造取消协议并一致的使用他们是你自己的任务.使用FutureTask和Executor框架能简化构建可取消的任务和服务.
			
	
	第8章 应用线程池
		8.1 任务和执行器之间的隐式耦合
			一些任务有需要或预先包含特定的执行策略的特性.文档化这些需求以便未来的维护者不会通过一些不合适的执行策略的替代品来降低安全性和生存性.
			8.1.1 线程饥饿死锁(Thread starvation deadlock)
				如果一个任务依赖于同一个线程池中执行的其他任务,死锁就有可能发生.比如所有正在执行的线程都被阻塞,在无限等待在队列中排队的其他任务,而队列中排队的任务由于没有空闲线程得不到执行,我们把这种情况称为饥饿死锁.
				当向一个Executor提交非独立性的任务时,要注意线程饥饿死锁的可能性.并且文档化关于池大小或配置约束相关的信息.
			8.1.2 长时间执行的任务
				一个缓解长时间运行的任务造成的缺点的方法是使用有时间限制的资源等待来代替没有限制的等待.
		8.2 设定线程池的大小
			理想的线程池大小依赖于将要被提交的任务的类型和部署系统的特性.
			设定线程池大小不是一个精确的科学,但要避免太大或太小的极端.太大可能导致竞争加剧,太小导致资源不能充分利用.
			可以在运行时获取cpu的个数:int N_CPUS = Runtime.getRuntime().availableProcessors();
		8.3 配置ThreadPoolExecutor
			ThreadPoolExecutor提供了执行器的基本实现,它通过Executors中的工厂方法,newCachedThreadPool,newFixedThreadPool and newScheduledThreadExecutor,来返回.ThreadPoolExecutor是一个灵活的,健壮的,允许多种自定义的池实现.
			如果默认的执行策略不能满足要求,可以自己通过构造函数初始化一个ThreadPoolExecutor,然后再自定义它.
			8.3.1 线程的创建和拆卸(teardown)
				核心池大小,最大池大小,和存活时间支配线程的创建和拆卸.
				newFixedThreadPool工厂方法设置核心池大小和最大池大小都为请求的池大小,并且存活时间为无限大.newCachedThreadPool工厂方法设置最大池大小为Integer.MAX_VALUE,核心池大小为0,存活时间为1分钟,意味着创建了一个可无限扩展的线程池,并且会在需求减少时自动收缩.其他的组合也是可能的通过使用显式的ThreadPoolExecutor的构造函数.
			8.3.2 管理排队的任务
				有范围的线程池限制了能够并发执行的任务的个数.
				ThreadPoolExecutor允许你提供一个BlockingQueue来持有等待执行的任务.有三个基本的方法来排队任务:无范围的队列,有范围的队列和同步传递.
				newFixedThreadPool和newSingleThreadExecutor的默认是使用一个无限制的LinkedBlockingQueue.
				一个更稳定的资源管理策略是使用一个有范围的队列,比如ArrayBlockingQueue或一个有范围的LinkedBlockingQueue或PriorityBlockingQueue.
				有范围的队列能帮助防止资源耗尽,但是引入了如何处理任务当池满的时候.
				使用一个有范围的工作队列,队列大小和池大小必须同时调整.一个大的队列组合一个小的池能够帮助降低内存,cpu的使用,上下文的切换,但以隐式的约束吞吐量为开销.
				对于一个很大的或没有限制的池,你可以完全绕开队列,相应的,通过使用一个SynchronousQueue来直接从生产者向消费者传递任务.
				SynchronousQueue并不是一个队列,它提供了管理线程建传递的一个机制.
				为了给SynchronousQueue中存放一个元素,必须有另外一个线程正在等待这个传递.如果没有正在等待的线程,但池的大小没有达到最大值,那么ThreadPoolExecutor就创建一个新线程.
				使用直接传递更有效率,因为任务被直接传递给将要执行它的线程,而不需要先放到队列中,再由工作线程从队列中获取它.
				SynchronousQueue是一个实践选择只有当池是无限制的或拒绝额外的任务是可接受的.newCachedThreadPool工厂方法使用了SynchronousQueue.
				使用一个FIFO队列,比如LinkedBlockingQueue或ArrayBlockingQueue,能够使任务按他们到达的顺序启动.为了更进一步控制任务执行的顺序,你可以使用PriorityBlockingQueue,它通过优先级来为任务排队.优先级可以被定义为自然顺序或通过一个Comparator.
				对于一个Executor,newCachedThreadPool能够比固定大小的池提供更好的排队性能.当你出于管理资源的考虑而限制并发执行的任务个数时,比如服务器应用能够接受的网络连接的数量以及那些可能被攻击而导致过载的应用,固定大小的池是个很好的选择.
			8.3.3 饱和策略(saturation policy)
				当一个有限制的队列填满时,饱和策略开始起作用.ThreadPoolExecutor的饱和策略能够通过调用setRejectedExecutionHandler来设置(饱和策略也会被用在当向已经关闭的Executor提交任务时).
				RejectedExecutionHandler的多个实现都被提供,每一个都实现了一个饱和策略:AbortPolicy, CallerRunsPolicy, DiscardPolicy, 和DiscardOldestPolicy.
				默认的策略,中止,会导致execute方法抛出未检查的RejectedExecutionException,调用者可以捕获该异常,实现它自己的溢出处理.丢弃策略安静的丢弃新提交的任务,如果它不能被排队来等待执行.DiscardOldestPolicy将会丢弃即将执行的那个任务,然后重新提交这个新的任务.这种策略一般不适用于优先级队列.
				调用者执行策略实现了一种策略的节流,既不是通过丢弃任务,也不是通过抛出异常,而是相应的,尝试通过将有些工作推回到调用者来减慢新任务从调用者流向到线程池.它不是在线程池里执行新提交的任务,而是在调用execute方法的线程中执行.
			8.3.4 线程工厂
				ThreadFactory只有单一的方法,newThread,在线程池需要新线程时被调用.
				有很多原因来使用一个自定义的线程工厂.你可能想要为池中的线程指定一个UncaughtExceptionHandler,或者初始化一个自定义线程类的实例,或者更改线程的优先级,或者设置线程的daemon状态,或者是为了给池中的线程一个有意义的名字.
				如果你的应用采用安全策略来为特定的代码授权,你可能想要使用Executors中的privilegedThreadFactory来构造你自己的线程工厂.它创建的池中的线程和创建privilegedThreadFactory的线程有相同的优先级,AccessControlContext和contextClassLoader.否则新创建线程的权限将继承自此时通过调用execute或submit来提交任务的客户线程.
			8.3.5 在ThreadPoolExecutor构造后进行自定义
				ThreadPoolExecutor构造函数中的大部分参数也可以通过setter方法来设置.
				Executors包含一个工厂方法,unconfigurableExecutorService,它使用一个已经存在的ExecutorService,对它进行包装,使它只暴露ExecutorService中的方法,以使它不能被进一步的更新.不像其他的池的实现,newSingleThreadExecutor返回一个以这种形式包装的ExecutorService,而不是一个未加工的ThreadPoolExecutor.
				如果要给不信任的代码暴露一个ExecutorService,那么可以通过unconfigurableExecutorService来包装它.
		8.4 扩展ThreadPoolExecutor
			ThreadPoolExecutor被设计为可扩展,它提供了很多的钩子来供子类覆盖.overridebeforeExecute,afterExecute和terminate都是用来扩展ThreadPoolExecutor的.
			beforeExecute和afterExecute在执行任务的线程中被调用,能够用来添加日志,时间信息,监控信息和统计信息收集等.afterExecute会被调用,或者是通过从run方法正常返回或抛出异常来完成时(如果任务是因为Error完成,afterExecute将不会被调用).如果beforeExecute抛出一个RuntimeException,任务将不会被执行,afterExecute不会被调用.
			terminated钩子被调用当线程池完成了关闭过程时,在所有任务都已完成,所有工作线程都被关闭之后.它能够用来释放Executor生命周期中分配的资源,执行通知或记录日至.
			8.4.1 为线程池添加统计信息
				因为钩子是在执行任务的线程中被调用的,所以beforeExecute在ThreadLocal中存放的值可以在afterExecute中获取到.
		8.5 并行化递归算法
			如果想要提交一组任务,并且等待他们所有的都完成,可以使用ExecutorService.invokeAll.
			顺序的循环,反复适合于并行执行,当每次反复之间是相互独立时.
			8.5.1 例子:一个猜谜框架
		总结:
			Executor框架对于可并发执行的任务是强大的和灵活的.它提供了很多的调整选项,比如创建和销毁线程的策略,处理排队的任务,如何处理超过的任务,并且提供了很多的钩子来扩展它的行为.
				
				
				
	第9章 GUI应用
		略过
	
				
第三部分:存活性(liveness),性能和测试.				
	第10章 解决活跃性问题
		安全性和存活性是一个橡皮筋的两端.我们使用锁来确保线程安全,但随意使用锁会产生由锁顺序导致的死锁.
		10.1 死锁
			10.1.1 锁顺序引起的死锁
				一个程序可以采用使所有的线程都以一个固定的,全局的顺序来获取锁的方式来避免锁顺序引起的死锁
			10.1.2 动态锁顺序引起的死锁
			10.1.3 合作对象间的死锁
				在持有锁时调用外部方法可能会导致生存性问题.外部方法可能需要其他的锁(有死锁的风险),或阻塞一个不可预期的很长的时间,会拖延那些需要你持有的锁的线程.
			10.1.4 开放调用(open calls)
				一个方法调用是一个抽象的屏障,它将另一边发生的事情的细节给你屏蔽掉.因为你不知道在调用的另一边发生了什么,在持有锁的情况下调用一个外部方法是很难分析的,因此是有风险的.
				在不持有锁的情况下,调用一个方法称为开放调用.依赖于开放调用的类要比调用时持有锁的类表现的更好,更容易组合.使用开放调用来避免死锁类似于使用封装来提供线程安全.虽然我们可以不用封装来构造一个线程安全的类,但使用封装会使分析程序的线程安全性更容易.同理,依赖于开放调用的程序的存活性分析要更容易.使用开放调用使得分析获取多个锁的代码路径更容易,因此可以确定锁是以一致的顺序获得.
				争取在整个程序中都使用开放调用,依赖于开放调用的程序更容易分析是否会发生死锁.
			10.1.5 资源死锁
				就像线程在等待锁时可能发生死锁一样,它在等待资源时也可能发生死锁.
		10.2 消除和诊断死锁
			如果你必须获取多个锁,锁的顺序必须是你的设计的一部分:试着最小化加锁的交互的数量,遵循和文档化一个获取锁顺序的协议.
			检查你的代码是否会发生死锁包括两部分的策略:首先,确定在哪可能需要获得多个锁,然后全局分析这种实例,来确保它们获取锁的顺序是一致的.
			10.2.1 有时间限制的获取锁尝试
				另一个检测死锁和从死锁中恢复的方法是使用显式的锁的有时间限制的tryLock方法来替代固有锁.固有锁在不能获取锁时将永远阻塞,显式锁在超时时仍不能获取锁时将返回false.
				使用有时间限制的锁获取方法来获取锁可以有效地避免死锁,即使有时间限制的锁获取的顺序在整个程序范围内是不一致的.
			10.2.2 使用线程转储(thread dump)来分析死锁
				JVM可以使用线程转储来帮助识别死锁.线程转储包括每一个正在运行的线程的栈轨迹,类似于异常发生时的栈轨迹.线程转储也包括锁信息,比如哪个锁被线程持有,它是在哪个栈调用时被获取的,以及阻塞的线程正在等待获取哪个锁.在生成线程转储之前,JVM搜索等待图来找到死锁.如果找到了,它就包括死锁相关的信息,比如哪些锁和线程涉及在内,程序的哪个地方违反了锁获取.
				为了触发一个线程转储,在Unix平台上,你可以给JVM进程发送一个SIGQUIT信号(kill -3),或者是在Unix平台上按ctrl-\,在windows平台上按ctrl-break.
				如果使用显式锁来代替固有锁,java 5.0在进行线程转储时不支持相关的锁信息,显式锁在线程转储中完全不会被显示.java 6包括对显式锁的线程转储支持和死锁检测.但是对于锁在哪里获取的信息不如固有锁精确.固有锁和获取它的栈帧相关联,但显式锁只和获取它的线程相关联.
		10.3 其他的存活性问题
			10.3.1 饥饿
				饥饿是指一个线程永久的被拒绝获取使他继续向前执行的资源.最常见的引起饥饿的资源是cpu.在java线程中,不恰当的使用线程优先级可能引起饥饿,或者在持有锁的情况下,进入到一个不可中止的结构,从而使等待该锁的线程饥饿.
				线程API中定义的线程优先级仅仅是调度的一个暗示.线程API定义了10个优先级,JVM将这10个优先级映射到操作系统的优先级.这个映射是平台相关的.
				操作系统调度器竭尽全力提供调度的公平性和存活性,它超出了java语言规范要求的范围.在大多数java应用中,所有的线程默认有相同的优先级,Thread.NORM_PRIORITYN.
				线程优先级是一个迟钝的工具,它并不总是很明显的改变优先级,增加一个线程的优先级可能不会有效果,或者可能导致它相对于其他线程优先调度,从而引起饥饿.
				通常,抵制修改线程优先级的诱惑是明智的.一旦你开始修改优先级,那么你应用的行为就和特定平台相关,从而引入了饥饿的风险.你经常可以看到一个程序中的很多地方尝试从扭曲的优先级或响应性问题中恢复,通过在奇怪的地方使用Thread.sleep或Thread.yield,来尝试给低优先级的线程更多的时间.
				避免使用线程优先级的诱惑,因为它们增加了平台依赖性,并且可能导致存活性问题.大多数并发的应用可以为所有的线程使用默认优先级.
			10.3.2 很差的响应能力
				如果一个任务是被其他线程在后台执行,那么降低他们的优先级可以使前台线程获得更好的响应性.
			10.3.3 活锁
				活锁是一种形式的生存性问题,它是指一个线程没有被阻塞,但是它不能向前执行,因为它一直尝试执行的操作总是失败.这种形式的活锁通常是因为错误修复代码的过度热心,它们将一个不可恢复的任务对待为一个可恢复的任务.
				另一个活锁可能发生的情况是,两个互相合作的线程改变各自的状态来响应对方.就像两个绅士在路上让路,他们同时移向同一边,导致两个人都没办法向前走.解决这种类型的活锁可以在重试机制中引入一些随机性.比如以太网的载波监听回退重试.
		总结:
			存活性失败是一个严重的问题,因为没有办法从这个失败中恢复,除非中止应用.最常见到存活性问题是由于锁获取顺序导致的死锁.避免这种死锁需要从设计阶段开始考虑:确保当线程要获取多个锁时,他们都是以一致的顺序获得的.实现这个的最好的方法是在整个应用中使用开放调用.这样极大的减少了同时获取多个锁的地方,使得这些地方更明显.
		

	第11章 性能和可扩展性
		首先使你的程序正确,然后再使它快,并且是在你的性能需求需要它更快时才这么做.
		11.1 考虑性能
			11.1.1 性能 vs 可扩展性
				应用的性能能够通过多种方法来衡量,他们中的一些是衡量一个任务有多快被执行,一些是衡量对于给定的计算资源,有多少任务可以被执行.
				扩展性是指当添加额外的计算资源时,吞吐量和处理能力的提升能力.
				设计和调整并发应用的可扩展性与传统的性能优化是不同的.当调整性能时,是指花更少的代价来做相同的工作,比如缓存上次计算的结果,使用一个O(nlogn)的算法来代替一个O(n2)的算法.当调整扩展性时,试着并行化要处理的任务,以使添加额外的计算资源时能够做更多的工作.
				性能的这两个方面,多快和对少,是完全分开的,有时候甚至是相互冲突的.
			11.1.2 评估性能权衡(evaluating performance tradeoff)
				测试,而不是去猜
		11.2 阿姆达尔定律
			阿姆达尔定律描述了在增加计算资源时,一个程序理论上能够被多大程度的加速,是基于程序中并行执行和顺序执行的部分的比例.
			11.2.1 例子:框架中隐藏的串行化
			11.2.2 应用阿姆达尔定律的性质
				将一个锁分解(lock split)为多个不能使我们更好的利用多处理器,锁的条带化(lock stripe)做的更好,因为锁条带化后条带集合的大小可以随着处理器数量的增加而增加.
				锁的条带化(lock stripe)是指将要加锁的资源分为多个部分,每个部分可以独立加锁.比如磁盘在某一时刻只能允许指定数量的读取进程,我们可以通过将某一个要存放在磁盘上的数据分为多个部分,分别存储在不同的磁盘上,从而增加对该数据的并行处理能力.
		11.3 多线程引入的开销
			调度和线程间协作会有性能损耗,对于用于改进性能的多线程,并行化带来的好处必须多于并发带来的损耗.
			11.3.1 上下文切换
				上下文切换包括保存当前正在执行线程的上下文,恢复新被调度的线程的上下文.
				当一个新线程被切换进来时,它需要的数据可能不在本地处理器缓存中,所以会引起缓存无法命中,这也是为什么线程在刚被调度时执行有点慢.这也使为什么调度器为每一个可执行的线程分配一个指定的最小的时间,这样做偿还了上下文切换带来的开销,即使有很多其他线程正在等待.
				当一个线程因为等待一个竞争的锁而被阻塞时,JVM通常会暂停这个线程,并且允许它换出.如果线程阻塞过于频繁,它将不能充分利用调度器分配给它的特定的最小时间段.一个程序如果有很多阻塞,那么回导致很多的上下文切换,从而增加调度器的压力,降低吞吐量.
				上下文切换的损耗在不同的平台上不同,但是一个很好的经验是一次上下文切换的损耗相当于5000到10000个时钟周期,或数微秒,在多数现代处理器中.
				Unix系统的vmstat命令和windows系统的perfmon工具报告了上下文切换的次数和内核消耗的时间的比率.好的内核使用率(10%以上)通常表明繁重的调度活动,这个通常是由于I/O或锁竞争导致的阻塞引起的.
			11.3.2 内存同步
				同步的性能损耗来自于多个原因,synchronized和volatile提供的可见性保证需要使用被称为内存屏障的特定指令,它能够刷新缓存或使缓存无效,刷新硬件的写缓冲区,并且停止执行管道(stall execution pipeline).内存屏障对性能有间接的影响,它将禁止编译器优化,当内存屏障存在时,很多操作不能被重排序.
				当评估同步带来的性能影响时,区分有竞争的同步和无竞争(volatile总是无竞争的)的同步是很重要的.对于没有竞争的情况,synchronized是被优化过的,一个无竞争同步的快速路经的性能消耗大概是20到250个时钟周期.无竞争的同步对于整个应用性能的影响不是很明显.
				现代JVM可以降低偶然同步带来的开销,通过优化掉那些被证明不可能有竞争的锁.
				很多聪明的JVM可以通过泄露分析来识别当一个本地的对象饮用不会被发布到堆,因此是线程本地(thread-local)的.
				即使没有泄露分析(escape analysis),编译器也会执行锁的粗粒度化,即将临近的,使用相同锁的同步代码块合并.
				不要过度担心无竞争同步的性能损耗,基本的机制已经很快速,并且JVM能够执行一些额外的优化来进一步降低或消除损耗.将优化的精力放在锁竞争经常发生的区域.
			11.3.3 阻塞
				无竞争的同步能够在JVM内部被完全的处理掉.有竞争的同步可能需要操作系统的活动,它可能产生损耗.当通过竞争获取锁时,获取锁失败的线程必须阻塞.JVM能够实现阻塞,或者通过自旋-等待(反复的尝试获得锁,直到成功),或者通过操作系统停止被阻塞的线程.哪一个更有效取决于上下文切换的开销和锁变为可用需要等待的时间.在等待锁可用需要的时间很短时,自旋-等待是很好的选择.在等待长时间的锁时,停止是很好的选择.一些JVM会根据过去的等待时间在这两种策略之间选择,但大多数都会在等待锁时停止.
				停止线程会导致两次额外的上下文切换,和一些附带的OS和缓存的活动:阻塞的线程在其时间片用完之前被换出,等锁或其他资源可用时再换入.对于由于锁竞争而引起的阻塞,对于当前持有锁的线程也有一些开销,那就是它必须请求操作系统恢复阻塞的线程.
		11.4 降低锁竞争
			减少锁竞争能够提升性能和扩展性
			在并发应用中,可扩展性的最主要的威胁是排他性的资源锁.
			两个因素影响锁竞争的可能性:多久锁被请求一次,以及一旦被获取,将持有多长时间.
			有三个方法可以降低锁竞争:
				降低锁持有的时间
				降低锁被请求的次数
				使用合作机制来替代排他性锁,可以获得更好的并发性.
			11.4.1 缩小锁的作用域
				一个有效的降低竞争可能性的方法是尽可能短时间的持有锁.
			11.4.2 降低锁的粒度
				这个可以通过锁拆分和锁的条带化来实现,由多个锁来保护多个相互独立的状态变量,来代替过去的一个锁.
				如果一个锁在保护多于一个的独立的状态变量,那么你就应该将它拆分成多个锁,每个锁保护一个独立的状态变量,来提高可扩展性,这样可以降低每个锁被请求的频率.
			11.4.3 锁的条带化
				锁的拆分有时候可以被扩展为将锁分割到一个可变大小的,相互独立的对象集合上.这种情况称为锁的条带化.
				锁的条带化的一个缺点是:排他性的保护一个集合将更困难和代价更大,相比于使用单一的锁.这个通常通过获取条带集合中的所有的锁来实现.
			11.4.4 避免热点字段
				锁的粒度不能降低那些被所有操作都需要的变量.这是一个性能和扩展性经常争执的一个区域.比如HashMap,它的实现是单独维护一个size字段来存放其大小信息,在每次add,remove操作时都需要更新size.这样做的好处是在获取其大小时不需要遍历map.但是当并发很大时,size变量就变成一个热点,所有的操作都需要访问该变量,导致可扩展性的问题.ConcurrentHashMap通过动态计算每个stripe部分的大小来获得整个map的大小.这样就解决了热点问题.
			11.4.5 排它锁的其他选择
				另一个减轻锁竞争影响的方法是放弃使用排它锁有利于使用另一种并发友好的方式来管理共享状态.这种方法包括使用并发集合,读写锁,不可变对象和原子变量.
			11.4.6 监控cpu的使用
				当测试可扩展性时,我们的目标通常是保持处理器完全利用.像unix下的vmstat和mpstat工,windows下的perfmon工具能告诉你cpu的运行状态.
				如果cpu没有被完全使用,可能是下面几个原因:
					负载不够
					I/O限制
						磁盘或网络.磁盘问题可以通过iostat(unix)或perfmon(windows)来诊断
					外部限制
						比如数据库或web service
					锁竞争
						剖析工具可以告诉你,你的应用中的锁竞争有多激烈,以及哪个锁是热点.
				vmstat的输出中有一列指出当前有多少线程是可执行的,但当前并没有执行,因为cpu是不可用的.
			11.4.7 只管对对象池说不
				事实上,java中的分配空间已经比C中的malloc快了.在HotSpot 1.4.x和5.0中,通常的创建对象的代码路径大概是10个机器指令.
				使用对象池会导致线程在对象池上的竞争.因为由于竞争阻塞一个线程的代价是分配空间的几百倍.即使很少量的,包含池的竞争都将会是一个扩展的瓶颈.
				即使是一个没有竞争的同步,通常也比为一个对象分配空间昂贵.
				池有它自己的用处,但是对于性能优化只有有限的作用
				为对象分配空间通常比同步便宜
		11.5 例子:比较Map性能
		11.6 降低上下文切换的负载
		总结:
			因为使用多线程的一个原因是充分利用多处理器,在讨论并发应用的性能时,相对于服务时间,我们通常更关心吞吐量或可扩展性.阿姆达尔定律告诉我们一个应用的可扩展性由其代码中串行执行代码的比例来决定.
			由于java程序中串行执行的主要原因是排他性资源锁的使用,因此更短时间的持有锁,或者通过减小锁的粒度,或者通过减少锁持有的时间,或者使用非排他性的,非阻塞的替代品来替代排他性锁,来改进其可扩展性.
		
			
			
	第12章 测试并发程序
		为并发程序构造测试的一个主要挑战是:潜在的错误发生的概率很小.用来发现这些问题的测试必须更广泛,并且需要运行更长的时间.
		大多数并发类的测试可分为两类:安全性和存活性.
		安全性的测试就是检测一个类的行为和它的规范一致,通常是测试它的不变式.
		存活性的测试本来就是一个挑战,因为你无法知道一个线程是被阻塞还是只是运行缓慢,你如何识别一个算法处于死锁状态,你需要等待多长时间,然后声明它失败了,等.
		性能能够通过下面三个方法来衡量:
			1. 吞吐量
			2. 响应性
			3. 可扩展性
		12.1 正确性测试
			为并发类开发单元测试是从分析与其对应的顺序类开始的,识别那些有责任去检测的不变式和前置条件.
			12.1.1 基本的单元测试
			12.1.2 测试阻塞操作
				如果一个方法被认为在某些情况下会阻塞,那么测试这个行为的测试只有在该任务没有继续发生时才成功.测试一个方法阻塞类似于测试一个方法抛出异常,如果该方法运行正常,那么这个测试失败.
				测试阻塞方法引入了额外的复杂性:一旦一个方法被成功的阻塞,你必须使它以一定的方式停止阻塞.最明显的方式是通过中断.
				使用Thread.getState来判断一个线程是否确实阻塞在一个条件等待上的方法是不可靠的.没有任何需求要求阻塞的线程一定进入WAITING或TIMED_WAITING状态,因为JVM可能选择通过自旋-等待来实现阻塞.
				由于来自于Object.wait或Condition.await的欺骗性的唤醒是允许的,一个处于WAITING或TIMED_WAITING状态的线程可能临时性的转化为RUNNABLE状态,即使它正在等待的条件没有变为true.即使忽略掉这些实现选项,被阻塞的线程也需要一定时间来进入阻塞状态.
				Thread.getState的结果不应该用来做并发控制,并且它对于测试的有用性很有限.它的主要的作用是提供调试信息.
			12.1.3 安全性测试
				构造测试来发现并发类中的错误是一个类似于鸡生蛋的问题,因为测试程序自己就是并发程序.
				为并发类构造有效的安全测试的挑战在于确定很容易检测的属性,这些属性在一些事情发生时,有很大的可能失败.同时,不要使错误检测的代码限制了并发行.在测试检测属性时,不使用同步是最好的.
				测试应该运行在一个多处理器系统上,以增加潜在交错执行的多样性.然而,使得一些cpu不是必须的,可以使测试更加有效率.为了最大化检测时间敏感的数据竞争的机会,应该有比cpu更多的活跃线程,以使在任何时候都有一些线程在运行,一些线程在换出,因此降低线程见交互的可预测性.
			12.1.4 测试资源管理
				到目前为止的测试关心的都是一个类对其规范的忠诚度,即做它们被认为要做的事.测试的第二个概念是它不做它被认为不会做的事.
			12.1.5 使用回调(callback)
				针对客户代码的回调在构造测试用例时很有用,回调一般在一个对象的一个已知的点被调用,它被认为是检测不变式的很好的机会.
			12.1.6 产生更多的交错执行
				一个有用的诡计来增加程序交错执行的次数,并因此可以更有效的研究你的程序的状态空间(state space),是在访问共享变量时,使用Thread.yield来鼓励上下文切换.这种技术的有效性是和平台相关的,因为JVM可能会自由的针对Thread.yield不进行任何操作.使用一个短暂的,非0的sleep将会比较慢,但比较可靠.
		12.2 测试性能
			事实上,大部分时候,在性能测试中包含一些基本的功能测试是值得的,以确保你不是在为破损的代码测试性能.
			12.2.1 扩展PutTakeTest来添加时间限制
			12.2.2 比较多个算法
			12.2.3 测试响应性
		12.3 避免性能测试的毒药
			在实践中,你需要注意那些影响性能的毒药.
			12.3.1 垃圾收集
				垃圾回收的时机是不可预测的,所以有可能在你进行性能测试时,发生垃圾回收,影响测试结果.
			12.3.2 动态编译
				HotSpot JVM结合使用了字节码解释和动态编译.当类第一次被加载时,JVM通过字节码解释来执行它,如果有方法被频繁的使用,动态编译器会将它编译成机器码,以后的执行中就直接使用机器码了.
				动态编译的时机也是不可预测的.
				在HotSpot上,运行程序时带上-XX:+PrintCompilation参数,那么在动态编译运行时,将会打印一条消息.
			12.3.3 不切实际的代码路径取样
				运行时编译器使用剖析信息来帮助优化将要被编译的代码.JVM被允许使用运行时的特定信息来帮助产生更好的代码,这就意味着同一个方法M会在不同的程序里会被编译为不同的代码.
				在一些情况下,JVM可能会基于一些临时性为真的假定来做一些优化,然后过一会,等这个假定不再为真时,它会收回这些编译过的代码来使其无效.
			12.3.4 不切实际的竞争程度
				并发应用在两种不同类型的工作之间交互:访问共享数据,例如从共享队列中获取下一个任务,线程本地的计算(执行任务,假设任务自己不需要访问共享数据).根据这两部分工作的比例,决定了应用的竞争程度,从而展示出不同的性能和扩展性.
			12.3.5 清除没有用的代码
				一个好的基准测试的挑战是被优化的编译器擅长于找出和清除那些对结果没有用的代码.
				编写一个有效的性能测试需要哄骗编译器不要将你的基准测试作为没有用的代码优化掉.这就需要所有的计算结果以某种方式被你的程序使用,以不需要同步和复杂计算的方式.
				不只是要每一个计算结果都不被使用,而且要结果是不可猜的,否则,一个聪明的动态优化编译器是被允许通过预先计算来代替一些操作的.
		12.4 补充的测试方法
			不同的QA测试方法对于找出某一种类型的错误很有效,但对于其他的则没有太大作用.通过使用补充的测试方法,比如代码审查和静态分析,来获得相对于使用单一方法更大的信心.
			12.4.1 代码审查
				单元测试和压力测试不能代替严格的,多个人进行的代码审查.花一些时间来让其他人审查代码总是值得的.
			12.4.2 静态分析工具
				静态代码分析是一个分析它而不用执行它的过程.代码审查工具能够分析类来找出一些常见的bug模式.
				到目前为止,FindBugs包括检测下面的并发相关的bug模式:
					1. 不一致的同步策略.即对于某些状态变量,在有些代码路径中是在同步下访问的,在有些代码路径中不是在同步下访问的.
					2. 调用Thread.run.通常直接调用Thread.run是错误的,通常是调用Thread.start.
					3. 没有释放的锁.这是对于显式锁说的.
					4. 空的同步块.虽然空的同步块也含有java内存模型的语义,但他们通常被错误的使用.
					5. 加锁的doulbe-check.加锁时的双重检测是一个在延迟初始化中降低同步负载的损坏的习语.它涉及到在没有恰当同步的情况下访问可变的共享变量.
					6. 在构造函数中启动一个线程.
					7. 通知错误.一个同步块在没有改变锁状态的情况下调用notify或notifyAll可能是个错误.
					8. 状态等待错误.调用Object.wait或Condition.await,在没有持有锁的情况下,或不在一个循环里,或没有测试一些状态的情况,一般被认为是错误的.
					9. 错误的使用Lock和Condition.就像使用Condition.wait来替代await一样(因为Condition也是一个对象,所以也有wait方法),使用Lock对象作为同步块的锁参数也可能是一个输入错误.
					10. 在持有锁的情况下睡眠或等待.
					11. 自旋循环.一个不做任何事情,只是自旋(忙等待)检测某个字段是否为指定的值,会浪费cpu,并且如果字段不是volatile,它不能保证会停止.
			12.4.3 面向切面的测试技术
			12.4.4 剖析和检测工具
		总结:
			测试并发程序的正确性会极其的有挑战性,因为并发程序的很多失败方式都是小概率事件,他们和时间,负载和其他不可重现的条件有关.更进一步,测试框架会引入额外的同步和时间限制,他们会掩盖被测试代码的并发问题.
			测试并发程序的性能也极其有挑战性,java程序比其他静态编译的程序更难测试,因为时间指标会被动态编译,垃圾收集和适当的优化影响.
			为了尽可能的找出潜在的问题,在传统的测试技术之外,可以结合代码审查和自动静态分析工具.这些技术能够找到其他人可能错过的问题.
			

第三部分: 高级主题
	第13章 显式锁
		在java 5.0之前,协调访问共享代码的机制是synchronized和volatile. java 5.0添加了另外一个选项:ReentrantLock.ReentrantLock不是固有锁的一个替代,而是在固有锁被证明有限制的地方的一个有高级功能的一个选择.
		13.1 锁和可重入锁
			和固有锁不同,Lock提供了一种无条件的,通过拉的,由时间限制的和可中断的锁获取策略.并且所有的加锁和释放锁的操作都是显式的.Lock的实现必须提供和固有锁一样的内存可见性语义,但可能在加锁语义,调度算法,顺序保证和性能等方面不同.
			ReentrantLock实现了Lock,提供了和synchronized相同的排他性互斥和内存可见性保证.获取一个ReentrantLock和进入一个synchronized块有相同的内存语义,释放一个ReentrantLock和离开一个synchronized块有相同的内存语义.像synchronized一样,ReentrantLock也提供了重入锁的语义.
			一个不使用ReentrantLock来完全替代synchronized的原因是:ReentrantLock有可能是更危险的,因为当控制权离开被保护的代码块时,它没有自动的清理锁.
			13.1.1 通过拉(poll)的方式和有时间限制的获取锁
				TryLock提供的主动获取和有时间限制的获取锁的模式,更擅长于处理错误恢复.对于固有锁,死锁是致命的,只能通过重启应用来恢复.但是有时间限制的和主动获取的方式获取锁,提供了避免死锁的可能.
				使用主动获取的,有时间限制的方式获取锁,允许你在不能获取所有的锁时,重新拥有控制权,释放一个已经获得的锁,再进行尝试.
			13.1.2 可中断的锁获取
				就像有时间限制的锁获取允许在有时间限制的活动中排他性的加锁.可中断的锁获取允许它被使用在可取消的活动中.
			13.1.3 非块结构(non-block-structured)的加锁
				对于固有锁,获取和释放对是块结构的,一个锁总是在获取的它块中被释放,不管控制权是如何离开这个块的.自动的锁释放简化了分析和预防潜在的编码错误,但有时候,一个更灵活的锁策略是需要的.
		13.2 性能考虑
			当ReentrantLock被添加到java 5.0时,它提供了比固有锁更好的竞争性能.
			java 6使用了类似于ReentrantLock的,改进的算法来管理固有锁,很大程度上填补了其扩展性的空白.
		13.3 公平性
			ReentrantLock提供了两个公平性的选项:创建一个非公平锁(默认)或一个公平锁.线程以他们请求的顺序获得公平锁,然而,非公平锁允许冲入:请求锁的线程可以跳到等待队列的最前面,当它请求锁时,锁恰好是可用状态的情况下.Semaphore也能提供公平和非公平获取顺序的选择.
			对于公平锁,如果锁被另一个线程持有,那么新请求的线程就要排队.对于非公平锁,新请求的线程只有在当前锁不可用时才排队.
			公平性有一个明显的性能损耗,因为停止和恢复线程的负载.在大多数情况下,非公平锁带来的性能上的好处要超过公平排队的好处.
			公平锁倾向于工作的很好,当他们会被持有相对较长的一段时间,或两次所请求之间的平均时间较长时.
			像默认的ReentrantLock一样,固有锁提供了一个不确定的公平保证,但是对于大多数锁实现的统计意义上的公平性,对于很多情况是可以的.语言规范不要求JVM公平的实现固有锁,并且没有JVM产品这样做.
		13.4 在Synchronized和ReentrantLock之间选择
			ReentrantLock提供了和固有锁一样的锁和内存语义,同时也提供了一些附加的功能,比如有时间限制的锁等待,可中断的锁等待,公平性和实现一个非块结构的锁的能力.ReentrantLock的性能要比固有锁的性能好,在java 5中明显的好,在java 6中只好一点,因为java 6中对固有锁进行了优化.
			固有锁同样也有一些比显式锁明显的优点:
				ReentrantLock是一个比synchronized更危险的工具,因为它的锁不会自动释放,如果你忘记了在finally块中调用unlock,你的代码看上去可以正常运行,但是却是错误的.
			ReentrantLock是一个更先进的工具,对于那些固有锁不适用的情况.使用它,如果你需要它的高级特性:有时间限制,拉的(polled),可中断的锁获取，公平队列，或非块结构的加锁.否则,选择synchronized.
			在java 5.0中,固有锁相比于ReentrantLock,还有一个优点:可以通过线程转储展示哪个栈帧获得的哪个锁,并且能够监测和识别死锁线程.JVM完全不知道哪个线程持有ReentrantLocks,因此在调试使用ReentrantLocks的线程问题时,不能帮忙.
			这种不一致性,在java 6.0中得到了解决.它提供了供锁可以注册的,管理和监控的接口.允许ReentrantLocks相关的锁信息出现在线程转储中.
		13.5 读写锁
			ReentrantLock实现了一个标准的互斥锁:在某一时刻,最多只有一个线程可以持有ReentrantLock.读-写锁允许:一个资源可以被多个读访问,或只能被一个写访问,但读和写不能同时访问.
			读写锁之间的交互允许很多可能的实现,一个ReadWriteLock的实现选项有:
				1. 释放后的选择倾向.当一个写线程释放写锁时,同时有读线程和写线程在排队等待,哪个应该给与优先权,读线程,写线程,或者是先访问的哪个?
				2. 读闯入.如果锁正在被读线程持有,并且有写线程在等待.应该新到达的读线程被授予立即访问,或者他们应该在写线程之后等待?允许读线程闯入到写线程前面,可以增强并发行,但是有可能使写线程饥饿.
				3. 可重入性.读线程和写线程是否可重入.
				4. 降级.如果一个线程持有写锁,那么它能不能在不释放写锁的情况下,获取读锁?这将使一个写锁降级为一个读锁,同时使其他写线程不会修改被保护的资源.
				5. 升级. 一个读锁能否优先于其他正在等待的读线程和写线程,被升级为一个写锁?大多数读写锁的实现不支持升级.
			ReentrantReadWriteLock为两个锁提供了可重入语义.像ReentrantLock一样,ReentrantReadWriteLock能够被构造为公平的和非公平的.对于公平锁,优先权被给与那个等待时间最长的线程.如果锁正在被读线程持有,然后一个写线程请求获取写锁,那么不再有读线程被允许获取锁,直到那个写线程服务完毕,释放写锁为止.
			对于非公平锁,线程被授予访问权限的顺序是不确定的.从写锁降级为读锁是允许的,但从读锁升级为写锁是不被允许的.
			在java 5.0中,读锁表现得更像一个Semaphore,它只是维护当前活动的读线程的数量,而不是读线程.这种行为在java 6中被改变,它将跟踪哪些线程被授予了读锁.
		总结
			显式锁相比于固有锁提供了一个扩展的功能集,包括在处理锁不可用的问题上提供了更好的灵活性,并且对排队行为提供了更好的控制.但ReentrantLock不能完全替代synchronized,只有当你需要synchronized不具有的功能时再使用它.
			读写锁允许多个读线程并发的访问被保护的资源.对于访问读频繁的数据结构,提供了改进可扩展性的潜在可能.
	
	
	第14章 构建自定义的同步器
		如果类库没有提供你要的功能,你可以使用类库或语言提供的低等级的机制来实现自己的同步器,包括固有的条件队列,显式的Condition对象,和AbstractQueuedSynchronizer框架.
		14.1 管理状态依赖
			并发对象中有状态依赖的方法有时候会失败,当他们的前置条件没有满足的时候,这种情况下,通常很好的替代方法是:等待它的前置条件变为true.
			14.1.1 传播前置条件失败到调用者
				
				
				
				
				
				
				
				
